/* applications-widget.c generated by valac 0.14.2, the Vala compiler
 * generated from applications-widget.vala, do not modify */

/* -*- Mode: vala; tab-width: 4; intend-tabs-mode: t -*- */
/* alm
 *
 * Copyright (C) 2012 Seif Lotfy <seif@lotfy.com>
 * Copyright (C) 2012 Stefano Candori <stefano.candori@gmail.com>
 * Copyright (C) 2012 Manish Sinha <manishsinha@ubuntu.com>
 * Copyright (C) 2012 Intel Corp.
 *               Authored by: Seif Lotfy <seif.lotfy@collabora.co.uk>
 *
 * alm is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * alm is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.";
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <zeitgeist.h>
#include <glib/gi18n-lib.h>
#include <float.h>
#include <math.h>
#include <gee.h>
#include <gio/gdesktopappinfo.h>
#include <gio/gio.h>
#include <gdk-pixbuf/gdk-pixdata.h>
#include <pango/pango.h>
#include <gdk/gdk.h>
#include <cairo.h>
#include <gobject/gvaluecollector.h>


#define ALM_TYPE_APPLICATIONS_WIDGET (alm_applications_widget_get_type ())
#define ALM_APPLICATIONS_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ALM_TYPE_APPLICATIONS_WIDGET, AlmApplicationsWidget))
#define ALM_APPLICATIONS_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ALM_TYPE_APPLICATIONS_WIDGET, AlmApplicationsWidgetClass))
#define ALM_IS_APPLICATIONS_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ALM_TYPE_APPLICATIONS_WIDGET))
#define ALM_IS_APPLICATIONS_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ALM_TYPE_APPLICATIONS_WIDGET))
#define ALM_APPLICATIONS_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ALM_TYPE_APPLICATIONS_WIDGET, AlmApplicationsWidgetClass))

typedef struct _AlmApplicationsWidget AlmApplicationsWidget;
typedef struct _AlmApplicationsWidgetClass AlmApplicationsWidgetClass;
typedef struct _AlmApplicationsWidgetPrivate AlmApplicationsWidgetPrivate;

#define ALM_TYPE_BLACKLIST (alm_blacklist_get_type ())
#define ALM_BLACKLIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ALM_TYPE_BLACKLIST, AlmBlacklist))
#define ALM_BLACKLIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ALM_TYPE_BLACKLIST, AlmBlacklistClass))
#define ALM_IS_BLACKLIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ALM_TYPE_BLACKLIST))
#define ALM_IS_BLACKLIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ALM_TYPE_BLACKLIST))
#define ALM_BLACKLIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ALM_TYPE_BLACKLIST, AlmBlacklistClass))

typedef struct _AlmBlacklist AlmBlacklist;
typedef struct _AlmBlacklistClass AlmBlacklistClass;

#define ALM_TYPE_APPLICATION_BLACKLIST (alm_application_blacklist_get_type ())
#define ALM_APPLICATION_BLACKLIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ALM_TYPE_APPLICATION_BLACKLIST, AlmApplicationBlacklist))
#define ALM_APPLICATION_BLACKLIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ALM_TYPE_APPLICATION_BLACKLIST, AlmApplicationBlacklistClass))
#define ALM_IS_APPLICATION_BLACKLIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ALM_TYPE_APPLICATION_BLACKLIST))
#define ALM_IS_APPLICATION_BLACKLIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ALM_TYPE_APPLICATION_BLACKLIST))
#define ALM_APPLICATION_BLACKLIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ALM_TYPE_APPLICATION_BLACKLIST, AlmApplicationBlacklistClass))

typedef struct _AlmApplicationBlacklist AlmApplicationBlacklist;
typedef struct _AlmApplicationBlacklistClass AlmApplicationBlacklistClass;

#define ALM_TYPE_APPLICATIONS_CHOOSER_DIALOG (alm_applications_chooser_dialog_get_type ())
#define ALM_APPLICATIONS_CHOOSER_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ALM_TYPE_APPLICATIONS_CHOOSER_DIALOG, AlmApplicationsChooserDialog))
#define ALM_APPLICATIONS_CHOOSER_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ALM_TYPE_APPLICATIONS_CHOOSER_DIALOG, AlmApplicationsChooserDialogClass))
#define ALM_IS_APPLICATIONS_CHOOSER_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ALM_TYPE_APPLICATIONS_CHOOSER_DIALOG))
#define ALM_IS_APPLICATIONS_CHOOSER_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ALM_TYPE_APPLICATIONS_CHOOSER_DIALOG))
#define ALM_APPLICATIONS_CHOOSER_DIALOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ALM_TYPE_APPLICATIONS_CHOOSER_DIALOG, AlmApplicationsChooserDialogClass))

typedef struct _AlmApplicationsChooserDialog AlmApplicationsChooserDialog;
typedef struct _AlmApplicationsChooserDialogClass AlmApplicationsChooserDialogClass;

#define ALM_TYPE_APPLICATIONS_TREE_VIEW (alm_applications_tree_view_get_type ())
#define ALM_APPLICATIONS_TREE_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ALM_TYPE_APPLICATIONS_TREE_VIEW, AlmApplicationsTreeView))
#define ALM_APPLICATIONS_TREE_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ALM_TYPE_APPLICATIONS_TREE_VIEW, AlmApplicationsTreeViewClass))
#define ALM_IS_APPLICATIONS_TREE_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ALM_TYPE_APPLICATIONS_TREE_VIEW))
#define ALM_IS_APPLICATIONS_TREE_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ALM_TYPE_APPLICATIONS_TREE_VIEW))
#define ALM_APPLICATIONS_TREE_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ALM_TYPE_APPLICATIONS_TREE_VIEW, AlmApplicationsTreeViewClass))

typedef struct _AlmApplicationsTreeView AlmApplicationsTreeView;
typedef struct _AlmApplicationsTreeViewClass AlmApplicationsTreeViewClass;

#define ALM_TYPE_APP_CHOOSE_INFO (alm_app_choose_info_get_type ())
#define ALM_APP_CHOOSE_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ALM_TYPE_APP_CHOOSE_INFO, AlmAppChooseInfo))
#define ALM_APP_CHOOSE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ALM_TYPE_APP_CHOOSE_INFO, AlmAppChooseInfoClass))
#define ALM_IS_APP_CHOOSE_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ALM_TYPE_APP_CHOOSE_INFO))
#define ALM_IS_APP_CHOOSE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ALM_TYPE_APP_CHOOSE_INFO))
#define ALM_APP_CHOOSE_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ALM_TYPE_APP_CHOOSE_INFO, AlmAppChooseInfoClass))

typedef struct _AlmAppChooseInfo AlmAppChooseInfo;
typedef struct _AlmAppChooseInfoClass AlmAppChooseInfoClass;
#define _alm_blacklist_unref0(var) ((var == NULL) ? NULL : (var = (alm_blacklist_unref (var), NULL)))
#define _alm_application_blacklist_unref0(var) ((var == NULL) ? NULL : (var = (alm_application_blacklist_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _alm_app_choose_info_unref0(var) ((var == NULL) ? NULL : (var = (alm_app_choose_info_unref (var), NULL)))
typedef struct _AlmApplicationBlacklistPrivate AlmApplicationBlacklistPrivate;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
typedef struct _AlmParamSpecApplicationBlacklist AlmParamSpecApplicationBlacklist;
typedef struct _AlmApplicationsTreeViewPrivate AlmApplicationsTreeViewPrivate;

#define ALM_APPLICATIONS_TREE_VIEW_TYPE_TREE_VIEW_COLS (alm_applications_tree_view_tree_view_cols_get_type ())
#define _gtk_icon_info_free0(var) ((var == NULL) ? NULL : (var = (gtk_icon_info_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define ALM_TYPE_APP_SELECTION_TREE_VIEW (alm_app_selection_tree_view_get_type ())
#define ALM_APP_SELECTION_TREE_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ALM_TYPE_APP_SELECTION_TREE_VIEW, AlmAppSelectionTreeView))
#define ALM_APP_SELECTION_TREE_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ALM_TYPE_APP_SELECTION_TREE_VIEW, AlmAppSelectionTreeViewClass))
#define ALM_IS_APP_SELECTION_TREE_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ALM_TYPE_APP_SELECTION_TREE_VIEW))
#define ALM_IS_APP_SELECTION_TREE_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ALM_TYPE_APP_SELECTION_TREE_VIEW))
#define ALM_APP_SELECTION_TREE_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ALM_TYPE_APP_SELECTION_TREE_VIEW, AlmAppSelectionTreeViewClass))

typedef struct _AlmAppSelectionTreeView AlmAppSelectionTreeView;
typedef struct _AlmAppSelectionTreeViewClass AlmAppSelectionTreeViewClass;
typedef struct _AlmAppSelectionTreeViewPrivate AlmAppSelectionTreeViewPrivate;

#define ALM_APP_SELECTION_TREE_VIEW_TYPE_TREE_VIEW_COLS (alm_app_selection_tree_view_tree_view_cols_get_type ())

#define ALM_TYPE_USAGE_CELL_RENDERER (alm_usage_cell_renderer_get_type ())
#define ALM_USAGE_CELL_RENDERER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ALM_TYPE_USAGE_CELL_RENDERER, AlmUsageCellRenderer))
#define ALM_USAGE_CELL_RENDERER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ALM_TYPE_USAGE_CELL_RENDERER, AlmUsageCellRendererClass))
#define ALM_IS_USAGE_CELL_RENDERER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ALM_TYPE_USAGE_CELL_RENDERER))
#define ALM_IS_USAGE_CELL_RENDERER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ALM_TYPE_USAGE_CELL_RENDERER))
#define ALM_USAGE_CELL_RENDERER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ALM_TYPE_USAGE_CELL_RENDERER, AlmUsageCellRendererClass))

typedef struct _AlmUsageCellRenderer AlmUsageCellRenderer;
typedef struct _AlmUsageCellRendererClass AlmUsageCellRendererClass;
typedef struct _AlmApplicationsChooserDialogPrivate AlmApplicationsChooserDialogPrivate;
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
typedef struct _AlmUsageCellRendererPrivate AlmUsageCellRendererPrivate;
typedef struct _AlmAppChooseInfoPrivate AlmAppChooseInfoPrivate;
typedef struct _AlmParamSpecAppChooseInfo AlmParamSpecAppChooseInfo;

struct _AlmApplicationsWidget {
	GtkBox parent_instance;
	AlmApplicationsWidgetPrivate * priv;
};

struct _AlmApplicationsWidgetClass {
	GtkBoxClass parent_class;
};

struct _AlmApplicationsWidgetPrivate {
	AlmBlacklist* blacklist_interface;
	AlmApplicationBlacklist* app_blacklist;
	AlmApplicationsChooserDialog* app_dialog;
	AlmApplicationsTreeView* app_treeview;
	GtkBox* container_box;
	GHashTable* blocked_list;
	GHashTable* unblocked_list;
	gboolean app_change_recursive;
};

struct _AlmApplicationBlacklist {
	GTypeInstance parent_instance;
	volatile int ref_count;
	AlmApplicationBlacklistPrivate * priv;
};

struct _AlmApplicationBlacklistClass {
	GTypeClass parent_class;
	void (*finalize) (AlmApplicationBlacklist *self);
};

struct _AlmApplicationBlacklistPrivate {
	AlmBlacklist* blacklist_interface;
	GeeHashSet* all_blocked_apps;
};

struct _AlmParamSpecApplicationBlacklist {
	GParamSpec parent_instance;
};

struct _AlmApplicationsTreeView {
	GtkBox parent_instance;
	AlmApplicationsTreeViewPrivate * priv;
};

struct _AlmApplicationsTreeViewClass {
	GtkBoxClass parent_class;
};

struct _AlmApplicationsTreeViewPrivate {
	AlmApplicationBlacklist* app_blacklist;
	GtkListStore* store;
	GtkTreeView* treeview;
	GHashTable* blocked_apps;
	GHashTable* unblocked_apps;
};

typedef enum  {
	ALM_APPLICATIONS_TREE_VIEW_TREE_VIEW_COLS_APP_NAME,
	ALM_APPLICATIONS_TREE_VIEW_TREE_VIEW_COLS_ICON,
	ALM_APPLICATIONS_TREE_VIEW_TREE_VIEW_COLS_DESKTOP_FILE,
	ALM_APPLICATIONS_TREE_VIEW_TREE_VIEW_COLS_N_COLS
} AlmApplicationsTreeViewTreeViewCols;

struct _AlmAppSelectionTreeView {
	GtkBox parent_instance;
	AlmAppSelectionTreeViewPrivate * priv;
};

struct _AlmAppSelectionTreeViewClass {
	GtkBoxClass parent_class;
};

struct _AlmAppSelectionTreeViewPrivate {
	AlmApplicationBlacklist* app_blacklist;
	GtkListStore* store;
	GtkTreeView* treeview;
};

typedef enum  {
	ALM_APP_SELECTION_TREE_VIEW_TREE_VIEW_COLS_APP_NAME,
	ALM_APP_SELECTION_TREE_VIEW_TREE_VIEW_COLS_ICON,
	ALM_APP_SELECTION_TREE_VIEW_TREE_VIEW_COLS_DESKTOP_FILE,
	ALM_APP_SELECTION_TREE_VIEW_TREE_VIEW_COLS_LAST_ACCESSED_STRING,
	ALM_APP_SELECTION_TREE_VIEW_TREE_VIEW_COLS_LAST_ACCESSED_INT,
	ALM_APP_SELECTION_TREE_VIEW_TREE_VIEW_COLS_USAGE,
	ALM_APP_SELECTION_TREE_VIEW_TREE_VIEW_COLS_N_COLS
} AlmAppSelectionTreeViewTreeViewCols;

struct _AlmApplicationsChooserDialog {
	GtkDialog parent_instance;
	AlmApplicationsChooserDialogPrivate * priv;
};

struct _AlmApplicationsChooserDialogClass {
	GtkDialogClass parent_class;
};

struct _AlmApplicationsChooserDialogPrivate {
	AlmApplicationBlacklist* app_blacklist;
	AlmAppSelectionTreeView* treeview;
	GHashTable* all_actors_list;
	GHashTable* actors_iter;
	GHashTable* blocked_apps;
	GHashTable* unblocked_apps;
};

struct _AlmUsageCellRenderer {
	GtkCellRenderer parent_instance;
	AlmUsageCellRendererPrivate * priv;
};

struct _AlmUsageCellRendererClass {
	GtkCellRendererClass parent_class;
};

struct _AlmUsageCellRendererPrivate {
	gint usage_num;
};

struct _AlmAppChooseInfo {
	GTypeInstance parent_instance;
	volatile int ref_count;
	AlmAppChooseInfoPrivate * priv;
};

struct _AlmAppChooseInfoClass {
	GTypeClass parent_class;
	void (*finalize) (AlmAppChooseInfo *self);
};

struct _AlmAppChooseInfoPrivate {
	gchar* app_id;
	gchar* app_name;
	GdkPixbuf* app_icon;
	gchar* last_accessed_time_s;
	gint64 last_accessed_time_i;
	guint usage_rating;
};

struct _AlmParamSpecAppChooseInfo {
	GParamSpec parent_instance;
};


static gpointer alm_applications_widget_parent_class = NULL;
static gpointer alm_application_blacklist_parent_class = NULL;
extern gchar* alm_application_blacklist_interpretation_prefix;
gchar* alm_application_blacklist_interpretation_prefix = NULL;
extern gchar* alm_application_blacklist_launcher_prefix;
gchar* alm_application_blacklist_launcher_prefix = NULL;
static gpointer alm_applications_tree_view_parent_class = NULL;
static gpointer alm_app_selection_tree_view_parent_class = NULL;
static gpointer alm_applications_chooser_dialog_parent_class = NULL;
static gpointer alm_usage_cell_renderer_parent_class = NULL;
static gpointer alm_app_choose_info_parent_class = NULL;

GType alm_applications_widget_get_type (void) G_GNUC_CONST;
gpointer alm_blacklist_ref (gpointer instance);
void alm_blacklist_unref (gpointer instance);
GParamSpec* alm_param_spec_blacklist (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void alm_value_set_blacklist (GValue* value, gpointer v_object);
void alm_value_take_blacklist (GValue* value, gpointer v_object);
gpointer alm_value_get_blacklist (const GValue* value);
GType alm_blacklist_get_type (void) G_GNUC_CONST;
gpointer alm_application_blacklist_ref (gpointer instance);
void alm_application_blacklist_unref (gpointer instance);
GParamSpec* alm_param_spec_application_blacklist (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void alm_value_set_application_blacklist (GValue* value, gpointer v_object);
void alm_value_take_application_blacklist (GValue* value, gpointer v_object);
gpointer alm_value_get_application_blacklist (const GValue* value);
GType alm_application_blacklist_get_type (void) G_GNUC_CONST;
GType alm_applications_chooser_dialog_get_type (void) G_GNUC_CONST;
GType alm_applications_tree_view_get_type (void) G_GNUC_CONST;
gpointer alm_app_choose_info_ref (gpointer instance);
void alm_app_choose_info_unref (gpointer instance);
GParamSpec* alm_param_spec_app_choose_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void alm_value_set_app_choose_info (GValue* value, gpointer v_object);
void alm_value_take_app_choose_info (GValue* value, gpointer v_object);
gpointer alm_value_get_app_choose_info (const GValue* value);
GType alm_app_choose_info_get_type (void) G_GNUC_CONST;
#define ALM_APPLICATIONS_WIDGET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ALM_TYPE_APPLICATIONS_WIDGET, AlmApplicationsWidgetPrivate))
enum  {
	ALM_APPLICATIONS_WIDGET_DUMMY_PROPERTY
};
AlmApplicationsWidget* alm_applications_widget_new (AlmBlacklist* blacklist_inter);
AlmApplicationsWidget* alm_applications_widget_construct (GType object_type, AlmBlacklist* blacklist_inter);
static void _g_free0_ (gpointer var);
static void _alm_app_choose_info_unref0_ (gpointer var);
AlmApplicationBlacklist* alm_application_blacklist_new (AlmBlacklist* blacklist);
AlmApplicationBlacklist* alm_application_blacklist_construct (GType object_type, AlmBlacklist* blacklist);
AlmApplicationsTreeView* alm_applications_tree_view_new (AlmApplicationBlacklist* app_blacklist, GHashTable* blocked, GHashTable* unblocked);
AlmApplicationsTreeView* alm_applications_tree_view_construct (GType object_type, AlmApplicationBlacklist* app_blacklist, GHashTable* blocked, GHashTable* unblocked);
static void alm_applications_widget_set_up_ui (AlmApplicationsWidget* self);
static void __lambda6_ (AlmApplicationsWidget* self, const gchar* app, ZeitgeistEvent* event);
void alm_applications_tree_view_remove_app_from_view (AlmApplicationsTreeView* self, const gchar* app);
static void ___lambda6__alm_application_blacklist_application_removed (AlmApplicationBlacklist* _sender, const gchar* app, ZeitgeistEvent* ev, gpointer self);
static void __lambda7_ (AlmApplicationsWidget* self, const gchar* app, ZeitgeistEvent* event);
void alm_applications_tree_view_add_application_to_view (AlmApplicationsTreeView* self, const gchar* app);
static void ___lambda7__alm_application_blacklist_application_added (AlmApplicationBlacklist* _sender, const gchar* app, ZeitgeistEvent* ev, gpointer self);
void alm_applications_widget_app_add_clicked (AlmApplicationsWidget* self, GtkToolButton* button);
static void _alm_applications_widget_app_add_clicked_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
void alm_applications_widget_app_remove_clicked (AlmApplicationsWidget* self, GtkToolButton* button);
static void _alm_applications_widget_app_remove_clicked_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
GeeHashSet* alm_application_blacklist_get_all_apps (AlmApplicationBlacklist* self);
static void alm_applications_widget_populate_view (AlmApplicationsWidget* self, GeeHashSet* app_list);
AlmApplicationsChooserDialog* alm_applications_chooser_dialog_new (AlmApplicationBlacklist* app_blacklist, GHashTable* blocked_list, GHashTable* unblocked_list);
AlmApplicationsChooserDialog* alm_applications_chooser_dialog_construct (GType object_type, AlmApplicationBlacklist* app_blacklist, GHashTable* blocked_list, GHashTable* unblocked_list);
GtkTreeView* alm_applications_chooser_dialog_get_tree (AlmApplicationsChooserDialog* self);
GtkListStore* alm_applications_chooser_dialog_get_liststore (AlmApplicationsChooserDialog* self);
void alm_application_blacklist_block (AlmApplicationBlacklist* self, const gchar* application);
gchar* alm_applications_tree_view_remove_selected_app (AlmApplicationsTreeView* self);
void alm_application_blacklist_unblock (AlmApplicationBlacklist* self, const gchar* application);
void alm_applications_chooser_dialog_insert_app_liststore (AlmApplicationsChooserDialog* self, const gchar* app);
gchar* alm_applications_widget_markup_for_app (GDesktopAppInfo* app_info);
static void alm_applications_widget_finalize (GObject* obj);
#define ALM_APPLICATION_BLACKLIST_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ALM_TYPE_APPLICATION_BLACKLIST, AlmApplicationBlacklistPrivate))
enum  {
	ALM_APPLICATION_BLACKLIST_DUMMY_PROPERTY
};
static void alm_application_blacklist_on_blacklist_added (AlmApplicationBlacklist* self, const gchar* blacklist_id, ZeitgeistEvent* ev);
static void _alm_application_blacklist_on_blacklist_added_alm_blacklist_template_added (AlmBlacklist* _sender, const gchar* blacklist_id, ZeitgeistEvent* blacklist_template, gpointer self);
static void alm_application_blacklist_on_blacklist_removed (AlmApplicationBlacklist* self, const gchar* blacklist_id, ZeitgeistEvent* ev);
static void _alm_application_blacklist_on_blacklist_removed_alm_blacklist_template_removed (AlmBlacklist* _sender, const gchar* blacklist_id, ZeitgeistEvent* blacklist_template, gpointer self);
static GeeHashSet* alm_application_blacklist_get_blocked_apps (AlmApplicationBlacklist* self);
void alm_application_blacklist_get_all_applications (AlmApplicationBlacklist* self, AlmApplicationsChooserDialog* dialog);
void alm_blacklist_get_all_applications (AlmBlacklist* self, AlmApplicationsChooserDialog* dialog);
void alm_application_blacklist_get_count_for_app (AlmApplicationBlacklist* self, const gchar* id, GtkTreeIter* iter, GtkListStore* store);
void alm_blacklist_get_count_for_app (AlmBlacklist* self, const gchar* app_id, GtkTreeIter* iter, GtkListStore* store);
GHashTable* alm_blacklist_get_all_templates (AlmBlacklist* self);
void alm_blacklist_add_template (AlmBlacklist* self, const gchar* blacklist_id, ZeitgeistEvent* blacklist_template);
void alm_blacklist_remove_template (AlmBlacklist* self, const gchar* blacklist_id);
static void g_cclosure_user_marshal_VOID__STRING_OBJECT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void alm_application_blacklist_finalize (AlmApplicationBlacklist* obj);
#define ALM_APPLICATIONS_TREE_VIEW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ALM_TYPE_APPLICATIONS_TREE_VIEW, AlmApplicationsTreeViewPrivate))
enum  {
	ALM_APPLICATIONS_TREE_VIEW_DUMMY_PROPERTY,
	ALM_APPLICATIONS_TREE_VIEW_LISTSTORE
};
static GType alm_applications_tree_view_tree_view_cols_get_type (void) G_GNUC_UNUSED;
static void alm_applications_tree_view_set_up_ui (AlmApplicationsTreeView* self);
GdkPixbuf* alm_applications_tree_view_get_pixbuf_from_gio_icon (GIcon* icon, gint size);
GtkListStore* alm_applications_tree_view_get_liststore (AlmApplicationsTreeView* self);
AlmAppChooseInfo* alm_app_choose_info_new (const gchar* id, const gchar* app_name, GdkPixbuf* app_icon, const gchar* last_accessed_time_s, gint64 last_accessed_time_i, guint usage_rating);
AlmAppChooseInfo* alm_app_choose_info_construct (GType object_type, const gchar* id, const gchar* app_name, GdkPixbuf* app_icon, const gchar* last_accessed_time_s, gint64 last_accessed_time_i, guint usage_rating);
static void alm_applications_tree_view_finalize (GObject* obj);
static void _vala_alm_applications_tree_view_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
GType alm_app_selection_tree_view_get_type (void) G_GNUC_CONST;
#define ALM_APP_SELECTION_TREE_VIEW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ALM_TYPE_APP_SELECTION_TREE_VIEW, AlmAppSelectionTreeViewPrivate))
enum  {
	ALM_APP_SELECTION_TREE_VIEW_DUMMY_PROPERTY,
	ALM_APP_SELECTION_TREE_VIEW_TREE,
	ALM_APP_SELECTION_TREE_VIEW_LISTSTORE
};
static GType alm_app_selection_tree_view_tree_view_cols_get_type (void) G_GNUC_UNUSED;
AlmAppSelectionTreeView* alm_app_selection_tree_view_new (AlmApplicationBlacklist* app_blacklist);
AlmAppSelectionTreeView* alm_app_selection_tree_view_construct (GType object_type, AlmApplicationBlacklist* app_blacklist);
static void alm_app_selection_tree_view_set_up_ui (AlmAppSelectionTreeView* self);
AlmUsageCellRenderer* alm_usage_cell_renderer_new (void);
AlmUsageCellRenderer* alm_usage_cell_renderer_construct (GType object_type);
GType alm_usage_cell_renderer_get_type (void) G_GNUC_CONST;
GtkTreeView* alm_app_selection_tree_view_get_tree (AlmAppSelectionTreeView* self);
GtkListStore* alm_app_selection_tree_view_get_liststore (AlmAppSelectionTreeView* self);
static void alm_app_selection_tree_view_finalize (GObject* obj);
static void _vala_alm_app_selection_tree_view_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
#define ALM_APPLICATIONS_CHOOSER_DIALOG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ALM_TYPE_APPLICATIONS_CHOOSER_DIALOG, AlmApplicationsChooserDialogPrivate))
enum  {
	ALM_APPLICATIONS_CHOOSER_DIALOG_DUMMY_PROPERTY,
	ALM_APPLICATIONS_CHOOSER_DIALOG_TREE,
	ALM_APPLICATIONS_CHOOSER_DIALOG_LISTSTORE
};
static void alm_applications_chooser_dialog_set_up_ui (AlmApplicationsChooserDialog* self);
static gint alm_applications_chooser_dialog_compare_dates (AlmApplicationsChooserDialog* self, GDateTime* now, GDateTime* time);
void alm_applications_chooser_dialog_handle_app_population (AlmApplicationsChooserDialog* self, GHashTable* all_actors);
static gint64* _int64_dup (gint64* self);
void alm_applications_chooser_dialog_insert_liststore (AlmApplicationsChooserDialog* self, GAppInfo* app_info, const gchar* last_accessed, gint64 last_accessed_time, guint usage);
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
void alm_app_choose_info_set_last_accessed (AlmAppChooseInfo* self, const gchar* value);
void alm_app_choose_info_set_usage (AlmAppChooseInfo* self, guint value);
const gchar* alm_app_choose_info_get_name (AlmAppChooseInfo* self);
GdkPixbuf* alm_app_choose_info_get_icon (AlmAppChooseInfo* self);
const gchar* alm_app_choose_info_get_last_accessed (AlmAppChooseInfo* self);
gint64 alm_app_choose_info_get_last_accessed_time (AlmAppChooseInfo* self);
gchar* alm_app_choose_info_get_id (AlmAppChooseInfo* self);
static void alm_applications_chooser_dialog_finalize (GObject* obj);
static void _vala_alm_applications_chooser_dialog_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
#define ALM_USAGE_CELL_RENDERER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ALM_TYPE_USAGE_CELL_RENDERER, AlmUsageCellRendererPrivate))
enum  {
	ALM_USAGE_CELL_RENDERER_DUMMY_PROPERTY,
	ALM_USAGE_CELL_RENDERER_USAGE
};
#define ALM_USAGE_CELL_RENDERER_RECT_NUM 10
#define ALM_USAGE_CELL_RENDERER_RECT_WIDTH 5
#define ALM_USAGE_CELL_RENDERER_RECT_HEIGHT 20
#define ALM_USAGE_CELL_RENDERER_RECT_SPACING 3
#define ALM_USAGE_CELL_RENDERER_xpadding 25
#define ALM_USAGE_CELL_RENDERER_ypadding 10
static void alm_usage_cell_renderer_real_get_size (GtkCellRenderer* base, GtkWidget* widget, GdkRectangle* cell_area, gint* x_offset, gint* y_offset, gint* width, gint* height);
static void alm_usage_cell_renderer_real_render (GtkCellRenderer* base, cairo_t* ctx, GtkWidget* widget, GdkRectangle* background_area, GdkRectangle* cell_area, GtkCellRendererState flags);
gint alm_usage_cell_renderer_get_usage (AlmUsageCellRenderer* self);
void alm_usage_cell_renderer_set_usage (AlmUsageCellRenderer* self, gint value);
static void alm_usage_cell_renderer_finalize (GObject* obj);
static void _vala_alm_usage_cell_renderer_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_alm_usage_cell_renderer_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define ALM_APP_CHOOSE_INFO_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ALM_TYPE_APP_CHOOSE_INFO, AlmAppChooseInfoPrivate))
enum  {
	ALM_APP_CHOOSE_INFO_DUMMY_PROPERTY
};
void alm_app_choose_info_set_name (AlmAppChooseInfo* self, const gchar* value);
void alm_app_choose_info_set_icon (AlmAppChooseInfo* self, GdkPixbuf* value);
void alm_app_choose_info_set_last_accessed_time (AlmAppChooseInfo* self, gint64 value);
guint alm_app_choose_info_get_usage (AlmAppChooseInfo* self);
static void alm_app_choose_info_finalize (AlmAppChooseInfo* obj);


static gpointer _alm_blacklist_ref0 (gpointer self) {
	return self ? alm_blacklist_ref (self) : NULL;
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _alm_app_choose_info_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (alm_app_choose_info_unref (var), NULL));
}


AlmApplicationsWidget* alm_applications_widget_construct (GType object_type, AlmBlacklist* blacklist_inter) {
	AlmApplicationsWidget * self = NULL;
	AlmBlacklist* _tmp0_;
	AlmBlacklist* _tmp1_;
	GHashFunc _tmp2_;
	GEqualFunc _tmp3_;
	GHashTable* _tmp4_;
	GHashFunc _tmp5_;
	GEqualFunc _tmp6_;
	GHashTable* _tmp7_;
	AlmBlacklist* _tmp8_;
	AlmApplicationBlacklist* _tmp9_;
	AlmApplicationBlacklist* _tmp10_;
	GHashTable* _tmp11_;
	GHashTable* _tmp12_;
	AlmApplicationsTreeView* _tmp13_;
	AlmApplicationsTreeView* _tmp14_;
	g_return_val_if_fail (blacklist_inter != NULL, NULL);
	self = (AlmApplicationsWidget*) g_object_new (object_type, "orientation", GTK_ORIENTATION_VERTICAL, NULL);
	_tmp0_ = blacklist_inter;
	_tmp1_ = _alm_blacklist_ref0 (_tmp0_);
	_alm_blacklist_unref0 (self->priv->blacklist_interface);
	self->priv->blacklist_interface = _tmp1_;
	_tmp2_ = g_str_hash;
	_tmp3_ = g_str_equal;
	_tmp4_ = g_hash_table_new_full (_tmp2_, _tmp3_, _g_free0_, _alm_app_choose_info_unref0_);
	_g_hash_table_unref0 (self->priv->blocked_list);
	self->priv->blocked_list = _tmp4_;
	_tmp5_ = g_str_hash;
	_tmp6_ = g_str_equal;
	_tmp7_ = g_hash_table_new_full (_tmp5_, _tmp6_, _g_free0_, _alm_app_choose_info_unref0_);
	_g_hash_table_unref0 (self->priv->unblocked_list);
	self->priv->unblocked_list = _tmp7_;
	_tmp8_ = self->priv->blacklist_interface;
	_tmp9_ = alm_application_blacklist_new (_tmp8_);
	_alm_application_blacklist_unref0 (self->priv->app_blacklist);
	self->priv->app_blacklist = _tmp9_;
	_tmp10_ = self->priv->app_blacklist;
	_tmp11_ = self->priv->blocked_list;
	_tmp12_ = self->priv->unblocked_list;
	_tmp13_ = alm_applications_tree_view_new (_tmp10_, _tmp11_, _tmp12_);
	_tmp14_ = g_object_ref_sink (_tmp13_);
	_g_object_unref0 (self->priv->app_treeview);
	self->priv->app_treeview = _tmp14_;
	alm_applications_widget_set_up_ui (self);
	return self;
}


AlmApplicationsWidget* alm_applications_widget_new (AlmBlacklist* blacklist_inter) {
	return alm_applications_widget_construct (ALM_TYPE_APPLICATIONS_WIDGET, blacklist_inter);
}


static void __lambda6_ (AlmApplicationsWidget* self, const gchar* app, ZeitgeistEvent* event) {
	gboolean _tmp0_;
	g_return_if_fail (app != NULL);
	g_return_if_fail (event != NULL);
	_tmp0_ = self->priv->app_change_recursive;
	if (!_tmp0_) {
		AlmApplicationsTreeView* _tmp1_;
		const gchar* _tmp2_;
		_tmp1_ = self->priv->app_treeview;
		_tmp2_ = app;
		alm_applications_tree_view_remove_app_from_view (_tmp1_, _tmp2_);
	}
	self->priv->app_change_recursive = FALSE;
}


static void ___lambda6__alm_application_blacklist_application_removed (AlmApplicationBlacklist* _sender, const gchar* app, ZeitgeistEvent* ev, gpointer self) {
	__lambda6_ (self, app, ev);
}


static void __lambda7_ (AlmApplicationsWidget* self, const gchar* app, ZeitgeistEvent* event) {
	gboolean _tmp0_;
	g_return_if_fail (app != NULL);
	g_return_if_fail (event != NULL);
	_tmp0_ = self->priv->app_change_recursive;
	if (!_tmp0_) {
		AlmApplicationsTreeView* _tmp1_;
		const gchar* _tmp2_;
		_tmp1_ = self->priv->app_treeview;
		_tmp2_ = app;
		alm_applications_tree_view_add_application_to_view (_tmp1_, _tmp2_);
	}
	self->priv->app_change_recursive = FALSE;
}


static void ___lambda7__alm_application_blacklist_application_added (AlmApplicationBlacklist* _sender, const gchar* app, ZeitgeistEvent* ev, gpointer self) {
	__lambda7_ (self, app, ev);
}


static void _alm_applications_widget_app_add_clicked_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	alm_applications_widget_app_add_clicked (self, _sender);
}


static void _alm_applications_widget_app_remove_clicked_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	alm_applications_widget_app_remove_clicked (self, _sender);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void alm_applications_widget_set_up_ui (AlmApplicationsWidget* self) {
	GtkBox* _tmp0_;
	GtkBox* _tmp1_;
	AlmApplicationBlacklist* _tmp2_;
	AlmApplicationBlacklist* _tmp3_;
	AlmApplicationsTreeView* _tmp4_;
	GtkToolbar* _tmp5_;
	GtkToolbar* _tmp6_;
	GtkToolbar* app_toolbar;
	GtkStyleContext* _tmp7_ = NULL;
	GtkStyleContext* _tmp8_ = NULL;
	const gchar* _tmp9_ = NULL;
	GtkToolButton* _tmp10_;
	GtkToolButton* _tmp11_;
	GtkToolButton* app_add;
	const gchar* _tmp12_ = NULL;
	GtkToolButton* _tmp13_;
	GtkToolButton* _tmp14_;
	GtkToolButton* app_remove;
	GtkBox* _tmp15_;
	AlmApplicationsTreeView* _tmp16_;
	GtkBox* _tmp17_;
	GtkLabel* _tmp18_;
	GtkLabel* _tmp19_;
	GtkLabel* label;
	const gchar* _tmp20_ = NULL;
	gchar* _tmp21_ = NULL;
	gchar* _tmp22_;
	GtkBox* _tmp23_;
	AlmApplicationBlacklist* _tmp24_;
	GeeHashSet* _tmp25_;
	GeeHashSet* _tmp26_;
	GeeHashSet* _tmp27_;
	GeeHashSet* app_list;
	AlmApplicationBlacklist* _tmp28_;
	GHashTable* _tmp29_;
	GHashTable* _tmp30_;
	AlmApplicationsChooserDialog* _tmp31_;
	AlmApplicationsChooserDialog* _tmp32_;
	g_return_if_fail (self != NULL);
	gtk_box_set_spacing ((GtkBox*) self, 6);
	gtk_container_set_border_width ((GtkContainer*) self, (guint) 12);
	_tmp0_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
	_tmp1_ = g_object_ref_sink (_tmp0_);
	_g_object_unref0 (self->priv->container_box);
	self->priv->container_box = _tmp1_;
	_tmp2_ = self->priv->app_blacklist;
	g_signal_connect_object (_tmp2_, "application-removed", (GCallback) ___lambda6__alm_application_blacklist_application_removed, self, 0);
	_tmp3_ = self->priv->app_blacklist;
	g_signal_connect_object (_tmp3_, "application-added", (GCallback) ___lambda7__alm_application_blacklist_application_added, self, 0);
	_tmp4_ = self->priv->app_treeview;
	gtk_widget_set_visible ((GtkWidget*) _tmp4_, TRUE);
	_tmp5_ = (GtkToolbar*) gtk_toolbar_new ();
	_tmp6_ = g_object_ref_sink (_tmp5_);
	app_toolbar = _tmp6_;
	g_object_set (app_toolbar, "toolbar-style", GTK_TOOLBAR_ICONS, NULL);
	gtk_toolbar_set_icon_size (app_toolbar, 1);
	g_object_set (app_toolbar, "icon-size-set", TRUE, NULL);
	gtk_widget_set_visible ((GtkWidget*) app_toolbar, TRUE);
	_tmp7_ = gtk_widget_get_style_context ((GtkWidget*) app_toolbar);
	gtk_style_context_add_class (_tmp7_, GTK_STYLE_CLASS_INLINE_TOOLBAR);
	_tmp8_ = gtk_widget_get_style_context ((GtkWidget*) app_toolbar);
	gtk_style_context_set_junction_sides (_tmp8_, GTK_JUNCTION_TOP);
	_tmp9_ = _ ("Add Application");
	_tmp10_ = (GtkToolButton*) gtk_tool_button_new (NULL, _tmp9_);
	_tmp11_ = g_object_ref_sink (_tmp10_);
	app_add = _tmp11_;
	gtk_tool_button_set_icon_name (app_add, "list-add-symbolic");
	g_signal_connect_object (app_add, "clicked", (GCallback) _alm_applications_widget_app_add_clicked_gtk_tool_button_clicked, self, 0);
	_tmp12_ = _ ("Remove Application");
	_tmp13_ = (GtkToolButton*) gtk_tool_button_new (NULL, _tmp12_);
	_tmp14_ = g_object_ref_sink (_tmp13_);
	app_remove = _tmp14_;
	gtk_tool_button_set_icon_name (app_remove, "list-remove-symbolic");
	g_signal_connect_object (app_remove, "clicked", (GCallback) _alm_applications_widget_app_remove_clicked_gtk_tool_button_clicked, self, 0);
	gtk_toolbar_insert (app_toolbar, (GtkToolItem*) app_add, 0);
	gtk_toolbar_insert (app_toolbar, (GtkToolItem*) app_remove, 1);
	_tmp15_ = self->priv->container_box;
	_tmp16_ = self->priv->app_treeview;
	gtk_box_pack_start (_tmp15_, (GtkWidget*) _tmp16_, TRUE, TRUE, (guint) 0);
	_tmp17_ = self->priv->container_box;
	gtk_box_pack_start (_tmp17_, (GtkWidget*) app_toolbar, FALSE, FALSE, (guint) 0);
	_tmp18_ = (GtkLabel*) gtk_label_new (NULL);
	_tmp19_ = g_object_ref_sink (_tmp18_);
	label = _tmp19_;
	_tmp20_ = _ ("Do not log activity from the following applications:");
	_tmp21_ = g_strdup_printf ("<b>%s</b>", _tmp20_);
	_tmp22_ = _tmp21_;
	gtk_label_set_markup (label, _tmp22_);
	_g_free0 (_tmp22_);
	gtk_misc_set_alignment ((GtkMisc*) label, (gfloat) 0, 0.5f);
	gtk_box_pack_start ((GtkBox*) self, (GtkWidget*) label, FALSE, FALSE, (guint) 0);
	_tmp23_ = self->priv->container_box;
	gtk_box_pack_start ((GtkBox*) self, (GtkWidget*) _tmp23_, TRUE, TRUE, (guint) 0);
	_tmp24_ = self->priv->app_blacklist;
	_tmp25_ = alm_application_blacklist_get_all_apps (_tmp24_);
	_tmp26_ = _tmp25_;
	_tmp27_ = _g_object_ref0 (_tmp26_);
	app_list = _tmp27_;
	alm_applications_widget_populate_view (self, app_list);
	_tmp28_ = self->priv->app_blacklist;
	_tmp29_ = self->priv->blocked_list;
	_tmp30_ = self->priv->unblocked_list;
	_tmp31_ = alm_applications_chooser_dialog_new (_tmp28_, _tmp29_, _tmp30_);
	_tmp32_ = g_object_ref_sink (_tmp31_);
	_g_object_unref0 (self->priv->app_dialog);
	self->priv->app_dialog = _tmp32_;
	_g_object_unref0 (app_list);
	_g_object_unref0 (label);
	_g_object_unref0 (app_remove);
	_g_object_unref0 (app_add);
	_g_object_unref0 (app_toolbar);
}


static gpointer _alm_app_choose_info_ref0 (gpointer self) {
	return self ? alm_app_choose_info_ref (self) : NULL;
}


void alm_applications_widget_app_add_clicked (AlmApplicationsWidget* self, GtkToolButton* button) {
	AlmApplicationsChooserDialog* _tmp0_;
	GtkWidget* _tmp1_ = NULL;
	GtkWidget* _tmp2_ = NULL;
	AlmApplicationsChooserDialog* _tmp3_;
	AlmApplicationsChooserDialog* _tmp4_;
	const gchar* _tmp5_ = NULL;
	AlmApplicationsChooserDialog* _tmp6_;
	gint _tmp7_ = 0;
	gint res;
	GtkWidget* _tmp8_ = NULL;
	gint _tmp9_;
	AlmApplicationsChooserDialog* _tmp49_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (button != NULL);
	_tmp0_ = self->priv->app_dialog;
	_tmp1_ = gtk_widget_get_toplevel ((GtkWidget*) self);
	gtk_window_set_transient_for ((GtkWindow*) _tmp0_, GTK_WINDOW (_tmp1_));
	_tmp2_ = gtk_widget_get_toplevel ((GtkWidget*) self);
	gtk_widget_set_sensitive (_tmp2_, FALSE);
	_tmp3_ = self->priv->app_dialog;
	gtk_window_set_modal ((GtkWindow*) _tmp3_, TRUE);
	_tmp4_ = self->priv->app_dialog;
	_tmp5_ = _ ("Select Application");
	gtk_window_set_title ((GtkWindow*) _tmp4_, _tmp5_);
	_tmp6_ = self->priv->app_dialog;
	_tmp7_ = gtk_dialog_run ((GtkDialog*) _tmp6_);
	res = _tmp7_;
	_tmp8_ = gtk_widget_get_toplevel ((GtkWidget*) self);
	gtk_widget_set_sensitive (_tmp8_, TRUE);
	_tmp9_ = res;
	if (_tmp9_ == ((gint) GTK_RESPONSE_OK)) {
		AlmApplicationsChooserDialog* _tmp10_;
		GtkTreeView* _tmp11_;
		GtkTreeView* _tmp12_;
		GtkTreeSelection* _tmp13_ = NULL;
		GtkTreeSelection* _tmp14_;
		GtkTreeSelection* sel;
		GtkTreeModel* model = NULL;
		GtkTreeIter iter = {0};
		GtkTreeSelection* _tmp15_;
		GtkTreeModel* _tmp16_ = NULL;
		GtkTreeIter _tmp17_ = {0};
		GtkTreeModel* _tmp18_;
		gchar* app = NULL;
		GtkTreeModel* _tmp19_;
		GtkTreeIter _tmp20_;
		AlmApplicationsChooserDialog* _tmp21_;
		GtkListStore* _tmp22_;
		GtkListStore* _tmp23_;
		GtkTreeIter _tmp24_;
		AlmApplicationsTreeView* _tmp25_;
		const gchar* _tmp26_;
		AlmApplicationBlacklist* _tmp27_;
		const gchar* _tmp28_;
		GHashTable* _tmp29_;
		const gchar* _tmp30_;
		gconstpointer _tmp31_ = NULL;
		AlmAppChooseInfo* _tmp32_;
		AlmAppChooseInfo* info;
		AlmAppChooseInfo* _tmp33_;
		_tmp10_ = self->priv->app_dialog;
		_tmp11_ = alm_applications_chooser_dialog_get_tree (_tmp10_);
		_tmp12_ = _tmp11_;
		_tmp13_ = gtk_tree_view_get_selection (_tmp12_);
		_tmp14_ = _g_object_ref0 (_tmp13_);
		sel = _tmp14_;
		_tmp15_ = sel;
		gtk_tree_selection_get_selected (_tmp15_, &_tmp16_, &_tmp17_);
		_g_object_unref0 (model);
		_tmp18_ = _g_object_ref0 (_tmp16_);
		model = _tmp18_;
		iter = _tmp17_;
		_tmp19_ = model;
		_tmp20_ = iter;
		gtk_tree_model_get (_tmp19_, &_tmp20_, 2, &app, -1);
		_tmp21_ = self->priv->app_dialog;
		_tmp22_ = alm_applications_chooser_dialog_get_liststore (_tmp21_);
		_tmp23_ = _tmp22_;
		_tmp24_ = iter;
		gtk_list_store_remove (_tmp23_, &_tmp24_);
		self->priv->app_change_recursive = TRUE;
		_tmp25_ = self->priv->app_treeview;
		_tmp26_ = app;
		alm_applications_tree_view_add_application_to_view (_tmp25_, _tmp26_);
		_tmp27_ = self->priv->app_blacklist;
		_tmp28_ = app;
		alm_application_blacklist_block (_tmp27_, _tmp28_);
		_tmp29_ = self->priv->unblocked_list;
		_tmp30_ = app;
		_tmp31_ = g_hash_table_lookup (_tmp29_, _tmp30_);
		_tmp32_ = _alm_app_choose_info_ref0 ((AlmAppChooseInfo*) _tmp31_);
		info = _tmp32_;
		_tmp33_ = info;
		if (_tmp33_ != NULL) {
			GHashTable* _tmp34_;
			const gchar* _tmp35_;
			GHashTable* _tmp36_;
			const gchar* _tmp37_;
			gconstpointer _tmp38_ = NULL;
			_tmp34_ = self->priv->unblocked_list;
			_tmp35_ = app;
			g_hash_table_remove (_tmp34_, _tmp35_);
			_tmp36_ = self->priv->blocked_list;
			_tmp37_ = app;
			_tmp38_ = g_hash_table_lookup (_tmp36_, _tmp37_);
			if (((AlmAppChooseInfo*) _tmp38_) == NULL) {
				GHashTable* _tmp39_;
				const gchar* _tmp40_;
				gchar* _tmp41_;
				AlmAppChooseInfo* _tmp42_;
				AlmAppChooseInfo* _tmp43_;
				_tmp39_ = self->priv->blocked_list;
				_tmp40_ = app;
				_tmp41_ = g_strdup (_tmp40_);
				_tmp42_ = info;
				_tmp43_ = _alm_app_choose_info_ref0 (_tmp42_);
				g_hash_table_insert (_tmp39_, _tmp41_, _tmp43_);
			} else {
				GHashTable* _tmp44_;
				const gchar* _tmp45_;
				gchar* _tmp46_;
				AlmAppChooseInfo* _tmp47_;
				AlmAppChooseInfo* _tmp48_;
				_tmp44_ = self->priv->blocked_list;
				_tmp45_ = app;
				_tmp46_ = g_strdup (_tmp45_);
				_tmp47_ = info;
				_tmp48_ = _alm_app_choose_info_ref0 (_tmp47_);
				g_hash_table_replace (_tmp44_, _tmp46_, _tmp48_);
			}
		}
		_alm_app_choose_info_unref0 (info);
		_g_free0 (app);
		_g_object_unref0 (model);
		_g_object_unref0 (sel);
	}
	_tmp49_ = self->priv->app_dialog;
	gtk_widget_hide ((GtkWidget*) _tmp49_);
}


void alm_applications_widget_app_remove_clicked (AlmApplicationsWidget* self, GtkToolButton* button) {
	AlmApplicationsTreeView* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* app;
	const gchar* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (button != NULL);
	_tmp0_ = self->priv->app_treeview;
	_tmp1_ = alm_applications_tree_view_remove_selected_app (_tmp0_);
	app = _tmp1_;
	_tmp2_ = app;
	if (_tmp2_ != NULL) {
		AlmApplicationBlacklist* _tmp3_;
		const gchar* _tmp4_;
		GHashTable* _tmp5_;
		const gchar* _tmp6_;
		gconstpointer _tmp7_ = NULL;
		AlmAppChooseInfo* _tmp8_;
		AlmAppChooseInfo* info;
		AlmAppChooseInfo* _tmp9_;
		AlmApplicationsChooserDialog* _tmp25_;
		const gchar* _tmp26_;
		self->priv->app_change_recursive = TRUE;
		_tmp3_ = self->priv->app_blacklist;
		_tmp4_ = app;
		alm_application_blacklist_unblock (_tmp3_, _tmp4_);
		_tmp5_ = self->priv->blocked_list;
		_tmp6_ = app;
		_tmp7_ = g_hash_table_lookup (_tmp5_, _tmp6_);
		_tmp8_ = _alm_app_choose_info_ref0 ((AlmAppChooseInfo*) _tmp7_);
		info = _tmp8_;
		_tmp9_ = info;
		if (_tmp9_ != NULL) {
			GHashTable* _tmp10_;
			const gchar* _tmp11_;
			GHashTable* _tmp12_;
			const gchar* _tmp13_;
			gconstpointer _tmp14_ = NULL;
			_tmp10_ = self->priv->blocked_list;
			_tmp11_ = app;
			g_hash_table_remove (_tmp10_, _tmp11_);
			_tmp12_ = self->priv->unblocked_list;
			_tmp13_ = app;
			_tmp14_ = g_hash_table_lookup (_tmp12_, _tmp13_);
			if (((AlmAppChooseInfo*) _tmp14_) == NULL) {
				GHashTable* _tmp15_;
				const gchar* _tmp16_;
				gchar* _tmp17_;
				AlmAppChooseInfo* _tmp18_;
				AlmAppChooseInfo* _tmp19_;
				_tmp15_ = self->priv->unblocked_list;
				_tmp16_ = app;
				_tmp17_ = g_strdup (_tmp16_);
				_tmp18_ = info;
				_tmp19_ = _alm_app_choose_info_ref0 (_tmp18_);
				g_hash_table_insert (_tmp15_, _tmp17_, _tmp19_);
			} else {
				GHashTable* _tmp20_;
				const gchar* _tmp21_;
				gchar* _tmp22_;
				AlmAppChooseInfo* _tmp23_;
				AlmAppChooseInfo* _tmp24_;
				_tmp20_ = self->priv->unblocked_list;
				_tmp21_ = app;
				_tmp22_ = g_strdup (_tmp21_);
				_tmp23_ = info;
				_tmp24_ = _alm_app_choose_info_ref0 (_tmp23_);
				g_hash_table_replace (_tmp20_, _tmp22_, _tmp24_);
			}
		}
		_tmp25_ = self->priv->app_dialog;
		_tmp26_ = app;
		alm_applications_chooser_dialog_insert_app_liststore (_tmp25_, _tmp26_);
		_alm_app_choose_info_unref0 (info);
	}
	_g_free0 (app);
}


static void alm_applications_widget_populate_view (AlmApplicationsWidget* self, GeeHashSet* app_list) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (app_list != NULL);
	{
		GeeHashSet* _tmp0_;
		GeeIterator* _tmp1_ = NULL;
		GeeIterator* _app_it;
		_tmp0_ = app_list;
		_tmp1_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp0_);
		_app_it = _tmp1_;
		while (TRUE) {
			GeeIterator* _tmp2_;
			gboolean _tmp3_ = FALSE;
			GeeIterator* _tmp4_;
			gpointer _tmp5_ = NULL;
			gchar* app;
			AlmApplicationsTreeView* _tmp6_;
			const gchar* _tmp7_;
			_tmp2_ = _app_it;
			_tmp3_ = gee_iterator_next (_tmp2_);
			if (!_tmp3_) {
				break;
			}
			_tmp4_ = _app_it;
			_tmp5_ = gee_iterator_get (_tmp4_);
			app = (gchar*) _tmp5_;
			_tmp6_ = self->priv->app_treeview;
			_tmp7_ = app;
			alm_applications_tree_view_add_application_to_view (_tmp6_, _tmp7_);
			_g_free0 (app);
		}
		_g_object_unref0 (_app_it);
	}
}


gchar* alm_applications_widget_markup_for_app (GDesktopAppInfo* app_info) {
	gchar* result = NULL;
	GDesktopAppInfo* _tmp0_;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* app_name;
	GDesktopAppInfo* _tmp3_;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	gchar* description;
	const gchar* _tmp6_ = NULL;
	const gchar* _tmp7_;
	const gchar* _tmp10_;
	gchar* _tmp11_;
	const gchar* _tmp12_;
	gchar* _tmp13_ = NULL;
	gchar* _tmp14_;
	const gchar* _tmp15_;
	gchar* _tmp16_ = NULL;
	gchar* _tmp17_;
	gchar* _tmp18_ = NULL;
	gchar* _tmp19_;
	g_return_val_if_fail (app_info != NULL, NULL);
	_tmp0_ = app_info;
	_tmp1_ = g_app_info_get_name ((GAppInfo*) _tmp0_);
	_tmp2_ = g_strdup (_tmp1_);
	app_name = _tmp2_;
	_tmp3_ = app_info;
	_tmp4_ = g_app_info_get_description ((GAppInfo*) _tmp3_);
	_tmp5_ = g_strdup (_tmp4_);
	description = _tmp5_;
	_tmp7_ = description;
	if (_tmp7_ != NULL) {
		const gchar* _tmp8_;
		_tmp8_ = description;
		_tmp6_ = _tmp8_;
	} else {
		const gchar* _tmp9_ = NULL;
		_tmp9_ = _ ("No description available");
		_tmp6_ = _tmp9_;
	}
	_tmp10_ = _tmp6_;
	_tmp11_ = g_strdup (_tmp10_);
	_g_free0 (description);
	description = _tmp11_;
	_tmp12_ = app_name;
	_tmp13_ = g_markup_escape_text (_tmp12_, (gssize) (-1));
	_tmp14_ = _tmp13_;
	_tmp15_ = description;
	_tmp16_ = g_markup_escape_text (_tmp15_, (gssize) (-1));
	_tmp17_ = _tmp16_;
	_tmp18_ = g_strdup_printf ("<b>%s</b>\n%s", _tmp14_, _tmp17_);
	_tmp19_ = _tmp18_;
	_g_free0 (_tmp17_);
	_g_free0 (_tmp14_);
	result = _tmp19_;
	_g_free0 (description);
	_g_free0 (app_name);
	return result;
}


static void alm_applications_widget_class_init (AlmApplicationsWidgetClass * klass) {
	alm_applications_widget_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (AlmApplicationsWidgetPrivate));
	G_OBJECT_CLASS (klass)->finalize = alm_applications_widget_finalize;
}


static void alm_applications_widget_instance_init (AlmApplicationsWidget * self) {
	self->priv = ALM_APPLICATIONS_WIDGET_GET_PRIVATE (self);
}


static void alm_applications_widget_finalize (GObject* obj) {
	AlmApplicationsWidget * self;
	self = ALM_APPLICATIONS_WIDGET (obj);
	_alm_blacklist_unref0 (self->priv->blacklist_interface);
	_alm_application_blacklist_unref0 (self->priv->app_blacklist);
	_g_object_unref0 (self->priv->app_dialog);
	_g_object_unref0 (self->priv->app_treeview);
	_g_object_unref0 (self->priv->container_box);
	_g_hash_table_unref0 (self->priv->blocked_list);
	_g_hash_table_unref0 (self->priv->unblocked_list);
	G_OBJECT_CLASS (alm_applications_widget_parent_class)->finalize (obj);
}


GType alm_applications_widget_get_type (void) {
	static volatile gsize alm_applications_widget_type_id__volatile = 0;
	if (g_once_init_enter (&alm_applications_widget_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AlmApplicationsWidgetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) alm_applications_widget_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AlmApplicationsWidget), 0, (GInstanceInitFunc) alm_applications_widget_instance_init, NULL };
		GType alm_applications_widget_type_id;
		alm_applications_widget_type_id = g_type_register_static (GTK_TYPE_BOX, "AlmApplicationsWidget", &g_define_type_info, 0);
		g_once_init_leave (&alm_applications_widget_type_id__volatile, alm_applications_widget_type_id);
	}
	return alm_applications_widget_type_id__volatile;
}


static void _alm_application_blacklist_on_blacklist_added_alm_blacklist_template_added (AlmBlacklist* _sender, const gchar* blacklist_id, ZeitgeistEvent* blacklist_template, gpointer self) {
	alm_application_blacklist_on_blacklist_added (self, blacklist_id, blacklist_template);
}


static void _alm_application_blacklist_on_blacklist_removed_alm_blacklist_template_removed (AlmBlacklist* _sender, const gchar* blacklist_id, ZeitgeistEvent* blacklist_template, gpointer self) {
	alm_application_blacklist_on_blacklist_removed (self, blacklist_id, blacklist_template);
}


AlmApplicationBlacklist* alm_application_blacklist_construct (GType object_type, AlmBlacklist* blacklist) {
	AlmApplicationBlacklist* self = NULL;
	AlmBlacklist* _tmp0_;
	AlmBlacklist* _tmp1_;
	AlmBlacklist* _tmp2_;
	AlmBlacklist* _tmp3_;
	GeeHashSet* _tmp4_ = NULL;
	GeeHashSet* _tmp5_;
	g_return_val_if_fail (blacklist != NULL, NULL);
	self = (AlmApplicationBlacklist*) g_type_create_instance (object_type);
	_tmp0_ = blacklist;
	_tmp1_ = _alm_blacklist_ref0 (_tmp0_);
	_alm_blacklist_unref0 (self->priv->blacklist_interface);
	self->priv->blacklist_interface = _tmp1_;
	_tmp2_ = self->priv->blacklist_interface;
	g_signal_connect (_tmp2_, "template-added", (GCallback) _alm_application_blacklist_on_blacklist_added_alm_blacklist_template_added, self);
	_tmp3_ = self->priv->blacklist_interface;
	g_signal_connect (_tmp3_, "template-removed", (GCallback) _alm_application_blacklist_on_blacklist_removed_alm_blacklist_template_removed, self);
	_tmp4_ = alm_application_blacklist_get_blocked_apps (self);
	_tmp5_ = _tmp4_;
	_g_object_unref0 (_tmp5_);
	return self;
}


AlmApplicationBlacklist* alm_application_blacklist_new (AlmBlacklist* blacklist) {
	return alm_application_blacklist_construct (ALM_TYPE_APPLICATION_BLACKLIST, blacklist);
}


void alm_application_blacklist_get_all_applications (AlmApplicationBlacklist* self, AlmApplicationsChooserDialog* dialog) {
	AlmBlacklist* _tmp0_;
	AlmApplicationsChooserDialog* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dialog != NULL);
	_tmp0_ = self->priv->blacklist_interface;
	_tmp1_ = dialog;
	alm_blacklist_get_all_applications (_tmp0_, _tmp1_);
}


void alm_application_blacklist_get_count_for_app (AlmApplicationBlacklist* self, const gchar* id, GtkTreeIter* iter, GtkListStore* store) {
	AlmBlacklist* _tmp0_;
	const gchar* _tmp1_;
	GtkTreeIter _tmp2_;
	GtkListStore* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id != NULL);
	g_return_if_fail (iter != NULL);
	g_return_if_fail (store != NULL);
	_tmp0_ = self->priv->blacklist_interface;
	_tmp1_ = id;
	_tmp2_ = *iter;
	_tmp3_ = store;
	alm_blacklist_get_count_for_app (_tmp0_, _tmp1_, &_tmp2_, _tmp3_);
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* _tmp0_;
	glong _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* end;
	gchar* _tmp3_;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_;
	gboolean _tmp3_;
	glong _tmp9_;
	glong _tmp15_;
	glong _tmp18_;
	glong _tmp19_;
	glong _tmp20_;
	glong _tmp21_;
	glong _tmp22_;
	gchar* _tmp23_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		glong _tmp4_;
		glong _tmp5_;
		glong _tmp6_ = 0L;
		_tmp4_ = offset;
		_tmp5_ = len;
		_tmp6_ = string_strnlen ((gchar*) self, _tmp4_ + _tmp5_);
		string_length = _tmp6_;
	} else {
		gint _tmp7_;
		gint _tmp8_;
		_tmp7_ = strlen (self);
		_tmp8_ = _tmp7_;
		string_length = (glong) _tmp8_;
	}
	_tmp9_ = offset;
	if (_tmp9_ < ((glong) 0)) {
		glong _tmp10_;
		glong _tmp11_;
		glong _tmp12_;
		_tmp10_ = string_length;
		_tmp11_ = offset;
		offset = _tmp10_ + _tmp11_;
		_tmp12_ = offset;
		g_return_val_if_fail (_tmp12_ >= ((glong) 0), NULL);
	} else {
		glong _tmp13_;
		glong _tmp14_;
		_tmp13_ = offset;
		_tmp14_ = string_length;
		g_return_val_if_fail (_tmp13_ <= _tmp14_, NULL);
	}
	_tmp15_ = len;
	if (_tmp15_ < ((glong) 0)) {
		glong _tmp16_;
		glong _tmp17_;
		_tmp16_ = string_length;
		_tmp17_ = offset;
		len = _tmp16_ - _tmp17_;
	}
	_tmp18_ = offset;
	_tmp19_ = len;
	_tmp20_ = string_length;
	g_return_val_if_fail ((_tmp18_ + _tmp19_) <= _tmp20_, NULL);
	_tmp21_ = offset;
	_tmp22_ = len;
	_tmp23_ = g_strndup (((gchar*) self) + _tmp21_, (gsize) _tmp22_);
	result = _tmp23_;
	return result;
}


static GeeHashSet* alm_application_blacklist_get_blocked_apps (AlmApplicationBlacklist* self) {
	GeeHashSet* result = NULL;
	GeeHashSet* _tmp0_;
	AlmBlacklist* _tmp1_;
	GHashTable* _tmp2_;
	GHashTable* _tmp3_;
	GList* _tmp4_ = NULL;
	GeeHashSet* _tmp13_;
	GeeHashSet* _tmp14_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL);
	_g_object_unref0 (self->priv->all_blocked_apps);
	self->priv->all_blocked_apps = _tmp0_;
	_tmp1_ = self->priv->blacklist_interface;
	_tmp2_ = alm_blacklist_get_all_templates (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_hash_table_get_keys (_tmp3_);
	{
		GList* key_collection = NULL;
		GList* key_it = NULL;
		key_collection = _tmp4_;
		for (key_it = key_collection; key_it != NULL; key_it = key_it->next) {
			gchar* _tmp5_;
			gchar* key = NULL;
			_tmp5_ = g_strdup ((const gchar*) key_it->data);
			key = _tmp5_;
			{
				const gchar* _tmp6_;
				const gchar* _tmp7_;
				gboolean _tmp8_ = FALSE;
				_tmp6_ = key;
				_tmp7_ = alm_application_blacklist_interpretation_prefix;
				_tmp8_ = g_str_has_prefix (_tmp6_, _tmp7_);
				if (_tmp8_) {
					const gchar* _tmp9_;
					gchar* _tmp10_ = NULL;
					gchar* app;
					GeeHashSet* _tmp11_;
					const gchar* _tmp12_;
					_tmp9_ = key;
					_tmp10_ = string_substring (_tmp9_, (glong) 4, (glong) (-1));
					app = _tmp10_;
					_tmp11_ = self->priv->all_blocked_apps;
					_tmp12_ = app;
					gee_abstract_collection_add ((GeeAbstractCollection*) _tmp11_, _tmp12_);
					_g_free0 (app);
				}
				_g_free0 (key);
			}
		}
		_g_list_free0 (key_collection);
	}
	_tmp13_ = self->priv->all_blocked_apps;
	_tmp14_ = _g_object_ref0 (_tmp13_);
	result = _tmp14_;
	return result;
}


static void alm_application_blacklist_on_blacklist_added (AlmApplicationBlacklist* self, const gchar* blacklist_id, ZeitgeistEvent* ev) {
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	gboolean _tmp2_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (blacklist_id != NULL);
	g_return_if_fail (ev != NULL);
	_tmp0_ = blacklist_id;
	_tmp1_ = alm_application_blacklist_interpretation_prefix;
	_tmp2_ = g_str_has_prefix (_tmp0_, _tmp1_);
	if (_tmp2_) {
		const gchar* _tmp3_;
		gchar* _tmp4_ = NULL;
		gchar* app;
		const gchar* _tmp5_;
		ZeitgeistEvent* _tmp6_;
		GeeHashSet* _tmp7_;
		GeeHashSet* _tmp8_;
		const gchar* _tmp9_;
		gboolean _tmp10_ = FALSE;
		_tmp3_ = blacklist_id;
		_tmp4_ = string_substring (_tmp3_, (glong) 4, (glong) (-1));
		app = _tmp4_;
		_tmp5_ = app;
		_tmp6_ = ev;
		g_signal_emit_by_name (self, "application-added", _tmp5_, _tmp6_);
		_tmp7_ = alm_application_blacklist_get_all_apps (self);
		_tmp8_ = _tmp7_;
		_tmp9_ = app;
		_tmp10_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp8_, _tmp9_);
		if (!_tmp10_) {
			GeeHashSet* _tmp11_;
			GeeHashSet* _tmp12_;
			const gchar* _tmp13_;
			_tmp11_ = alm_application_blacklist_get_all_apps (self);
			_tmp12_ = _tmp11_;
			_tmp13_ = app;
			gee_abstract_collection_add ((GeeAbstractCollection*) _tmp12_, _tmp13_);
		}
		_g_free0 (app);
	}
}


static void alm_application_blacklist_on_blacklist_removed (AlmApplicationBlacklist* self, const gchar* blacklist_id, ZeitgeistEvent* ev) {
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	gboolean _tmp2_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (blacklist_id != NULL);
	g_return_if_fail (ev != NULL);
	_tmp0_ = blacklist_id;
	_tmp1_ = alm_application_blacklist_interpretation_prefix;
	_tmp2_ = g_str_has_prefix (_tmp0_, _tmp1_);
	if (_tmp2_) {
		const gchar* _tmp3_;
		gchar* _tmp4_ = NULL;
		gchar* app;
		const gchar* _tmp5_;
		ZeitgeistEvent* _tmp6_;
		GeeHashSet* _tmp7_;
		GeeHashSet* _tmp8_;
		const gchar* _tmp9_;
		gboolean _tmp10_ = FALSE;
		_tmp3_ = blacklist_id;
		_tmp4_ = string_substring (_tmp3_, (glong) 4, (glong) (-1));
		app = _tmp4_;
		_tmp5_ = app;
		_tmp6_ = ev;
		g_signal_emit_by_name (self, "application-removed", _tmp5_, _tmp6_);
		_tmp7_ = alm_application_blacklist_get_all_apps (self);
		_tmp8_ = _tmp7_;
		_tmp9_ = app;
		_tmp10_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp8_, _tmp9_);
		if (_tmp10_) {
			GeeHashSet* _tmp11_;
			GeeHashSet* _tmp12_;
			const gchar* _tmp13_;
			_tmp11_ = alm_application_blacklist_get_all_apps (self);
			_tmp12_ = _tmp11_;
			_tmp13_ = app;
			gee_abstract_collection_remove ((GeeAbstractCollection*) _tmp12_, _tmp13_);
		}
		_g_free0 (app);
	}
}


void alm_application_blacklist_block (AlmApplicationBlacklist* self, const gchar* application) {
	ZeitgeistEvent* _tmp0_;
	ZeitgeistEvent* _tmp1_;
	ZeitgeistEvent* ev;
	ZeitgeistEvent* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	ZeitgeistSubject* _tmp6_;
	ZeitgeistSubject* _tmp7_;
	ZeitgeistSubject* sub;
	ZeitgeistEvent* _tmp8_;
	ZeitgeistSubject* _tmp9_;
	ZeitgeistEvent* _tmp10_;
	ZeitgeistEvent* _tmp11_;
	ZeitgeistEvent* launch_ev;
	ZeitgeistSubject* _tmp12_;
	ZeitgeistSubject* _tmp13_;
	ZeitgeistSubject* launch_sub;
	ZeitgeistSubject* _tmp14_;
	const gchar* _tmp15_;
	gchar* _tmp16_ = NULL;
	gchar* _tmp17_;
	ZeitgeistEvent* _tmp18_;
	ZeitgeistSubject* _tmp19_;
	AlmBlacklist* _tmp20_;
	const gchar* _tmp21_;
	const gchar* _tmp22_;
	gchar* _tmp23_ = NULL;
	gchar* _tmp24_;
	ZeitgeistEvent* _tmp25_;
	AlmBlacklist* _tmp26_;
	const gchar* _tmp27_;
	const gchar* _tmp28_;
	gchar* _tmp29_ = NULL;
	gchar* _tmp30_;
	ZeitgeistEvent* _tmp31_;
	GeeHashSet* _tmp32_;
	GeeHashSet* _tmp33_;
	const gchar* _tmp34_;
	gboolean _tmp35_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (application != NULL);
	_tmp0_ = zeitgeist_event_new ();
	_tmp1_ = g_object_ref_sink (_tmp0_);
	ev = _tmp1_;
	_tmp2_ = ev;
	_tmp3_ = application;
	_tmp4_ = g_strdup_printf ("application://%s", _tmp3_);
	_tmp5_ = _tmp4_;
	zeitgeist_event_set_actor (_tmp2_, _tmp5_);
	_g_free0 (_tmp5_);
	_tmp6_ = zeitgeist_subject_new ();
	_tmp7_ = g_object_ref_sink (_tmp6_);
	sub = _tmp7_;
	_tmp8_ = ev;
	_tmp9_ = sub;
	zeitgeist_event_add_subject (_tmp8_, _tmp9_);
	_tmp10_ = zeitgeist_event_new ();
	_tmp11_ = g_object_ref_sink (_tmp10_);
	launch_ev = _tmp11_;
	_tmp12_ = zeitgeist_subject_new ();
	_tmp13_ = g_object_ref_sink (_tmp12_);
	launch_sub = _tmp13_;
	_tmp14_ = launch_sub;
	_tmp15_ = application;
	_tmp16_ = g_strdup_printf ("application://%s", _tmp15_);
	_tmp17_ = _tmp16_;
	zeitgeist_subject_set_uri (_tmp14_, _tmp17_);
	_g_free0 (_tmp17_);
	_tmp18_ = launch_ev;
	_tmp19_ = launch_sub;
	zeitgeist_event_add_subject (_tmp18_, _tmp19_);
	_tmp20_ = self->priv->blacklist_interface;
	_tmp21_ = alm_application_blacklist_interpretation_prefix;
	_tmp22_ = application;
	_tmp23_ = g_strdup_printf ("%s%s", _tmp21_, _tmp22_);
	_tmp24_ = _tmp23_;
	_tmp25_ = ev;
	alm_blacklist_add_template (_tmp20_, _tmp24_, _tmp25_);
	_g_free0 (_tmp24_);
	_tmp26_ = self->priv->blacklist_interface;
	_tmp27_ = alm_application_blacklist_launcher_prefix;
	_tmp28_ = application;
	_tmp29_ = g_strdup_printf ("%s%s", _tmp27_, _tmp28_);
	_tmp30_ = _tmp29_;
	_tmp31_ = launch_ev;
	alm_blacklist_add_template (_tmp26_, _tmp30_, _tmp31_);
	_g_free0 (_tmp30_);
	_tmp32_ = alm_application_blacklist_get_all_apps (self);
	_tmp33_ = _tmp32_;
	_tmp34_ = application;
	_tmp35_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp33_, _tmp34_);
	if (!_tmp35_) {
		GeeHashSet* _tmp36_;
		GeeHashSet* _tmp37_;
		const gchar* _tmp38_;
		_tmp36_ = alm_application_blacklist_get_all_apps (self);
		_tmp37_ = _tmp36_;
		_tmp38_ = application;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp37_, _tmp38_);
	}
	_g_object_unref0 (launch_sub);
	_g_object_unref0 (launch_ev);
	_g_object_unref0 (sub);
	_g_object_unref0 (ev);
}


void alm_application_blacklist_unblock (AlmApplicationBlacklist* self, const gchar* application) {
	AlmBlacklist* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	AlmBlacklist* _tmp5_;
	const gchar* _tmp6_;
	const gchar* _tmp7_;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_;
	GeeHashSet* _tmp10_;
	GeeHashSet* _tmp11_;
	const gchar* _tmp12_;
	gboolean _tmp13_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (application != NULL);
	_tmp0_ = self->priv->blacklist_interface;
	_tmp1_ = alm_application_blacklist_interpretation_prefix;
	_tmp2_ = application;
	_tmp3_ = g_strdup_printf ("%s%s", _tmp1_, _tmp2_);
	_tmp4_ = _tmp3_;
	alm_blacklist_remove_template (_tmp0_, _tmp4_);
	_g_free0 (_tmp4_);
	_tmp5_ = self->priv->blacklist_interface;
	_tmp6_ = alm_application_blacklist_launcher_prefix;
	_tmp7_ = application;
	_tmp8_ = g_strdup_printf ("%s%s", _tmp6_, _tmp7_);
	_tmp9_ = _tmp8_;
	alm_blacklist_remove_template (_tmp5_, _tmp9_);
	_g_free0 (_tmp9_);
	_tmp10_ = alm_application_blacklist_get_all_apps (self);
	_tmp11_ = _tmp10_;
	_tmp12_ = application;
	_tmp13_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp11_, _tmp12_);
	if (_tmp13_) {
		GeeHashSet* _tmp14_;
		GeeHashSet* _tmp15_;
		const gchar* _tmp16_;
		_tmp14_ = alm_application_blacklist_get_all_apps (self);
		_tmp15_ = _tmp14_;
		_tmp16_ = application;
		gee_abstract_collection_remove ((GeeAbstractCollection*) _tmp15_, _tmp16_);
	}
}


GeeHashSet* alm_application_blacklist_get_all_apps (AlmApplicationBlacklist* self) {
	GeeHashSet* result;
	GeeHashSet* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->all_blocked_apps;
	result = _tmp0_;
	return result;
}


static void g_cclosure_user_marshal_VOID__STRING_OBJECT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_OBJECT) (gpointer data1, const char* arg_1, gpointer arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_OBJECT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_OBJECT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_object (param_values + 2), data2);
}


static void alm_value_application_blacklist_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void alm_value_application_blacklist_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		alm_application_blacklist_unref (value->data[0].v_pointer);
	}
}


static void alm_value_application_blacklist_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = alm_application_blacklist_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer alm_value_application_blacklist_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* alm_value_application_blacklist_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		AlmApplicationBlacklist* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = alm_application_blacklist_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* alm_value_application_blacklist_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	AlmApplicationBlacklist** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = alm_application_blacklist_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* alm_param_spec_application_blacklist (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	AlmParamSpecApplicationBlacklist* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ALM_TYPE_APPLICATION_BLACKLIST), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer alm_value_get_application_blacklist (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ALM_TYPE_APPLICATION_BLACKLIST), NULL);
	return value->data[0].v_pointer;
}


void alm_value_set_application_blacklist (GValue* value, gpointer v_object) {
	AlmApplicationBlacklist* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ALM_TYPE_APPLICATION_BLACKLIST));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ALM_TYPE_APPLICATION_BLACKLIST));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		alm_application_blacklist_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		alm_application_blacklist_unref (old);
	}
}


void alm_value_take_application_blacklist (GValue* value, gpointer v_object) {
	AlmApplicationBlacklist* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ALM_TYPE_APPLICATION_BLACKLIST));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ALM_TYPE_APPLICATION_BLACKLIST));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		alm_application_blacklist_unref (old);
	}
}


static void alm_application_blacklist_class_init (AlmApplicationBlacklistClass * klass) {
	gchar* _tmp0_;
	gchar* _tmp1_;
	alm_application_blacklist_parent_class = g_type_class_peek_parent (klass);
	ALM_APPLICATION_BLACKLIST_CLASS (klass)->finalize = alm_application_blacklist_finalize;
	g_type_class_add_private (klass, sizeof (AlmApplicationBlacklistPrivate));
	g_signal_new ("application_added", ALM_TYPE_APPLICATION_BLACKLIST, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_OBJECT, G_TYPE_NONE, 2, G_TYPE_STRING, ZEITGEIST_TYPE_EVENT);
	g_signal_new ("application_removed", ALM_TYPE_APPLICATION_BLACKLIST, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_OBJECT, G_TYPE_NONE, 2, G_TYPE_STRING, ZEITGEIST_TYPE_EVENT);
	_tmp0_ = g_strdup ("app-");
	alm_application_blacklist_interpretation_prefix = _tmp0_;
	_tmp1_ = g_strdup ("launch-");
	alm_application_blacklist_launcher_prefix = _tmp1_;
}


static void alm_application_blacklist_instance_init (AlmApplicationBlacklist * self) {
	self->priv = ALM_APPLICATION_BLACKLIST_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void alm_application_blacklist_finalize (AlmApplicationBlacklist* obj) {
	AlmApplicationBlacklist * self;
	self = ALM_APPLICATION_BLACKLIST (obj);
	_alm_blacklist_unref0 (self->priv->blacklist_interface);
	_g_object_unref0 (self->priv->all_blocked_apps);
}


GType alm_application_blacklist_get_type (void) {
	static volatile gsize alm_application_blacklist_type_id__volatile = 0;
	if (g_once_init_enter (&alm_application_blacklist_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { alm_value_application_blacklist_init, alm_value_application_blacklist_free_value, alm_value_application_blacklist_copy_value, alm_value_application_blacklist_peek_pointer, "p", alm_value_application_blacklist_collect_value, "p", alm_value_application_blacklist_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (AlmApplicationBlacklistClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) alm_application_blacklist_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AlmApplicationBlacklist), 0, (GInstanceInitFunc) alm_application_blacklist_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType alm_application_blacklist_type_id;
		alm_application_blacklist_type_id = g_type_register_fundamental (g_type_fundamental_next (), "AlmApplicationBlacklist", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&alm_application_blacklist_type_id__volatile, alm_application_blacklist_type_id);
	}
	return alm_application_blacklist_type_id__volatile;
}


gpointer alm_application_blacklist_ref (gpointer instance) {
	AlmApplicationBlacklist* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void alm_application_blacklist_unref (gpointer instance) {
	AlmApplicationBlacklist* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ALM_APPLICATION_BLACKLIST_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static GType alm_applications_tree_view_tree_view_cols_get_type (void) {
	static volatile gsize alm_applications_tree_view_tree_view_cols_type_id__volatile = 0;
	if (g_once_init_enter (&alm_applications_tree_view_tree_view_cols_type_id__volatile)) {
		static const GEnumValue values[] = {{ALM_APPLICATIONS_TREE_VIEW_TREE_VIEW_COLS_APP_NAME, "ALM_APPLICATIONS_TREE_VIEW_TREE_VIEW_COLS_APP_NAME", "app-name"}, {ALM_APPLICATIONS_TREE_VIEW_TREE_VIEW_COLS_ICON, "ALM_APPLICATIONS_TREE_VIEW_TREE_VIEW_COLS_ICON", "icon"}, {ALM_APPLICATIONS_TREE_VIEW_TREE_VIEW_COLS_DESKTOP_FILE, "ALM_APPLICATIONS_TREE_VIEW_TREE_VIEW_COLS_DESKTOP_FILE", "desktop-file"}, {ALM_APPLICATIONS_TREE_VIEW_TREE_VIEW_COLS_N_COLS, "ALM_APPLICATIONS_TREE_VIEW_TREE_VIEW_COLS_N_COLS", "n-cols"}, {0, NULL, NULL}};
		GType alm_applications_tree_view_tree_view_cols_type_id;
		alm_applications_tree_view_tree_view_cols_type_id = g_enum_register_static ("AlmApplicationsTreeViewTreeViewCols", values);
		g_once_init_leave (&alm_applications_tree_view_tree_view_cols_type_id__volatile, alm_applications_tree_view_tree_view_cols_type_id);
	}
	return alm_applications_tree_view_tree_view_cols_type_id__volatile;
}


static gpointer _alm_application_blacklist_ref0 (gpointer self) {
	return self ? alm_application_blacklist_ref (self) : NULL;
}


static gpointer _g_hash_table_ref0 (gpointer self) {
	return self ? g_hash_table_ref (self) : NULL;
}


AlmApplicationsTreeView* alm_applications_tree_view_construct (GType object_type, AlmApplicationBlacklist* app_blacklist, GHashTable* blocked, GHashTable* unblocked) {
	AlmApplicationsTreeView * self = NULL;
	AlmApplicationBlacklist* _tmp0_;
	AlmApplicationBlacklist* _tmp1_;
	GHashTable* _tmp2_;
	GHashTable* _tmp3_;
	GHashTable* _tmp4_;
	GHashTable* _tmp5_;
	GtkListStore* _tmp6_;
	GtkListStore* _tmp7_;
	GtkTreeView* _tmp8_;
	GtkTreeView* _tmp9_;
	GtkTreeView* _tmp10_;
	GtkTreeView* _tmp11_;
	g_return_val_if_fail (app_blacklist != NULL, NULL);
	g_return_val_if_fail (blocked != NULL, NULL);
	g_return_val_if_fail (unblocked != NULL, NULL);
	self = (AlmApplicationsTreeView*) g_object_new (object_type, "orientation", GTK_ORIENTATION_VERTICAL, NULL);
	_tmp0_ = app_blacklist;
	_tmp1_ = _alm_application_blacklist_ref0 (_tmp0_);
	_alm_application_blacklist_unref0 (self->priv->app_blacklist);
	self->priv->app_blacklist = _tmp1_;
	_tmp2_ = blocked;
	_tmp3_ = _g_hash_table_ref0 (_tmp2_);
	_g_hash_table_unref0 (self->priv->blocked_apps);
	self->priv->blocked_apps = _tmp3_;
	_tmp4_ = unblocked;
	_tmp5_ = _g_hash_table_ref0 (_tmp4_);
	_g_hash_table_unref0 (self->priv->unblocked_apps);
	self->priv->unblocked_apps = _tmp5_;
	_tmp6_ = gtk_list_store_new ((gint) ALM_APPLICATIONS_TREE_VIEW_TREE_VIEW_COLS_N_COLS, G_TYPE_STRING, GDK_TYPE_PIXBUF, G_TYPE_STRING);
	_g_object_unref0 (self->priv->store);
	self->priv->store = _tmp6_;
	_tmp7_ = self->priv->store;
	_tmp8_ = (GtkTreeView*) gtk_tree_view_new_with_model ((GtkTreeModel*) _tmp7_);
	_tmp9_ = g_object_ref_sink (_tmp8_);
	_g_object_unref0 (self->priv->treeview);
	self->priv->treeview = _tmp9_;
	_tmp10_ = self->priv->treeview;
	gtk_tree_view_set_headers_visible (_tmp10_, FALSE);
	_tmp11_ = self->priv->treeview;
	gtk_tree_view_set_rules_hint (_tmp11_, TRUE);
	alm_applications_tree_view_set_up_ui (self);
	return self;
}


AlmApplicationsTreeView* alm_applications_tree_view_new (AlmApplicationBlacklist* app_blacklist, GHashTable* blocked, GHashTable* unblocked) {
	return alm_applications_tree_view_construct (ALM_TYPE_APPLICATIONS_TREE_VIEW, app_blacklist, blocked, unblocked);
}


static void alm_applications_tree_view_set_up_ui (AlmApplicationsTreeView* self) {
	GtkTreeViewColumn* _tmp0_;
	GtkTreeViewColumn* _tmp1_;
	GtkTreeViewColumn* column_pix_name;
	const gchar* _tmp2_ = NULL;
	GtkTreeView* _tmp3_;
	GtkCellRendererPixbuf* _tmp4_;
	GtkCellRendererPixbuf* _tmp5_;
	GtkCellRendererPixbuf* pix_rend;
	GtkCellRendererText* _tmp6_;
	GtkCellRendererText* _tmp7_;
	GtkCellRendererText* name_rend;
	GValue _tmp8_ = {0};
	GtkScrolledWindow* _tmp9_;
	GtkScrolledWindow* _tmp10_;
	GtkScrolledWindow* scroll;
	GtkTreeView* _tmp11_;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_tree_view_column_new ();
	_tmp1_ = g_object_ref_sink (_tmp0_);
	column_pix_name = _tmp1_;
	_tmp2_ = _ ("Name");
	gtk_tree_view_column_set_title (column_pix_name, _tmp2_);
	_tmp3_ = self->priv->treeview;
	gtk_tree_view_append_column (_tmp3_, column_pix_name);
	_tmp4_ = (GtkCellRendererPixbuf*) gtk_cell_renderer_pixbuf_new ();
	_tmp5_ = g_object_ref_sink (_tmp4_);
	pix_rend = _tmp5_;
	gtk_cell_layout_pack_start ((GtkCellLayout*) column_pix_name, (GtkCellRenderer*) pix_rend, FALSE);
	gtk_cell_layout_add_attribute ((GtkCellLayout*) column_pix_name, (GtkCellRenderer*) pix_rend, "pixbuf", 1);
	_tmp6_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	_tmp7_ = g_object_ref_sink (_tmp6_);
	name_rend = _tmp7_;
	g_value_init (&_tmp8_, PANGO_TYPE_ELLIPSIZE_MODE);
	g_value_set_enum (&_tmp8_, PANGO_ELLIPSIZE_END);
	g_object_set_property ((GObject*) name_rend, "ellipsize", &_tmp8_);
	G_IS_VALUE (&_tmp8_) ? (g_value_unset (&_tmp8_), NULL) : NULL;
	gtk_cell_layout_pack_start ((GtkCellLayout*) column_pix_name, (GtkCellRenderer*) name_rend, TRUE);
	gtk_cell_layout_add_attribute ((GtkCellLayout*) column_pix_name, (GtkCellRenderer*) name_rend, "markup", 0);
	gtk_tree_view_column_set_resizable (column_pix_name, TRUE);
	_tmp9_ = (GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL);
	_tmp10_ = g_object_ref_sink (_tmp9_);
	scroll = _tmp10_;
	_tmp11_ = self->priv->treeview;
	gtk_container_add ((GtkContainer*) scroll, (GtkWidget*) _tmp11_);
	gtk_scrolled_window_set_policy (scroll, GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_set_shadow_type (scroll, GTK_SHADOW_IN);
	gtk_container_set_border_width ((GtkContainer*) scroll, (guint) 1);
	gtk_box_pack_start ((GtkBox*) self, (GtkWidget*) scroll, TRUE, TRUE, (guint) 0);
	_g_object_unref0 (scroll);
	_g_object_unref0 (name_rend);
	_g_object_unref0 (pix_rend);
	_g_object_unref0 (column_pix_name);
}


GdkPixbuf* alm_applications_tree_view_get_pixbuf_from_gio_icon (GIcon* icon, gint size) {
	GdkPixbuf* result = NULL;
	GdkPixbuf* pix;
	GtkIconTheme* _tmp0_ = NULL;
	GtkIconTheme* _tmp1_;
	GtkIconTheme* theme;
	GtkIconInfo* icon_info;
	GIcon* _tmp2_;
	GError * _inner_error_ = NULL;
	pix = NULL;
	_tmp0_ = gtk_icon_theme_get_default ();
	_tmp1_ = _g_object_ref0 (_tmp0_);
	theme = _tmp1_;
	icon_info = NULL;
	_tmp2_ = icon;
	if (_tmp2_ == NULL) {
		GtkIconTheme* _tmp3_;
		gint _tmp4_;
		GtkIconInfo* _tmp5_ = NULL;
		_tmp3_ = theme;
		_tmp4_ = size;
		_tmp5_ = gtk_icon_theme_lookup_icon (_tmp3_, "gtk-execute", _tmp4_, GTK_ICON_LOOKUP_FORCE_SVG);
		_gtk_icon_info_free0 (icon_info);
		icon_info = _tmp5_;
	} else {
		GtkIconTheme* _tmp6_;
		GIcon* _tmp7_;
		gint _tmp8_;
		GtkIconInfo* _tmp9_ = NULL;
		GtkIconInfo* _tmp10_;
		_tmp6_ = theme;
		_tmp7_ = icon;
		_tmp8_ = size;
		_tmp9_ = gtk_icon_theme_lookup_by_gicon (_tmp6_, _tmp7_, _tmp8_, GTK_ICON_LOOKUP_FORCE_SVG);
		_gtk_icon_info_free0 (icon_info);
		icon_info = _tmp9_;
		_tmp10_ = icon_info;
		if (_tmp10_ == NULL) {
			GtkIconTheme* _tmp11_;
			gint _tmp12_;
			GtkIconInfo* _tmp13_ = NULL;
			_tmp11_ = theme;
			_tmp12_ = size;
			_tmp13_ = gtk_icon_theme_lookup_icon (_tmp11_, "gtk-execute", _tmp12_, GTK_ICON_LOOKUP_FORCE_SVG);
			_gtk_icon_info_free0 (icon_info);
			icon_info = _tmp13_;
		}
	}
	{
		GtkIconInfo* _tmp14_;
		GdkPixbuf* _tmp15_ = NULL;
		GdkPixbuf* _tmp16_;
		_tmp14_ = icon_info;
		_tmp15_ = gtk_icon_info_load_icon (_tmp14_, &_inner_error_);
		_tmp16_ = _tmp15_;
		if (_inner_error_ != NULL) {
			goto __catch3_g_error;
		}
		_g_object_unref0 (pix);
		pix = _tmp16_;
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		result = NULL;
		_g_error_free0 (e);
		_gtk_icon_info_free0 (icon_info);
		_g_object_unref0 (theme);
		_g_object_unref0 (pix);
		return result;
	}
	__finally3:
	if (_inner_error_ != NULL) {
		_gtk_icon_info_free0 (icon_info);
		_g_object_unref0 (theme);
		_g_object_unref0 (pix);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = pix;
	_gtk_icon_info_free0 (icon_info);
	_g_object_unref0 (theme);
	return result;
}


void alm_applications_tree_view_add_application_to_view (AlmApplicationsTreeView* self, const gchar* app) {
	const gchar* _tmp0_;
	GDesktopAppInfo* _tmp1_;
	GDesktopAppInfo* app_info;
	GDesktopAppInfo* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (app != NULL);
	_tmp0_ = app;
	_tmp1_ = g_desktop_app_info_new (_tmp0_);
	app_info = _tmp1_;
	_tmp2_ = app_info;
	if (_tmp2_ != NULL) {
		GDesktopAppInfo* _tmp3_;
		GIcon* _tmp4_ = NULL;
		GdkPixbuf* _tmp5_ = NULL;
		GdkPixbuf* pix;
		GDesktopAppInfo* _tmp6_;
		gchar* _tmp7_ = NULL;
		gchar* markup;
		GtkTreeIter iter = {0};
		GtkListStore* _tmp8_;
		GtkListStore* _tmp9_;
		GtkTreeIter _tmp10_ = {0};
		GtkListStore* _tmp11_;
		GtkListStore* _tmp12_;
		GtkTreeIter _tmp13_;
		const gchar* _tmp14_;
		GdkPixbuf* _tmp15_;
		const gchar* _tmp16_;
		GHashTable* _tmp17_;
		const gchar* _tmp18_;
		gconstpointer _tmp19_ = NULL;
		_tmp3_ = app_info;
		_tmp4_ = g_app_info_get_icon ((GAppInfo*) _tmp3_);
		_tmp5_ = alm_applications_tree_view_get_pixbuf_from_gio_icon (_tmp4_, 32);
		pix = _tmp5_;
		_tmp6_ = app_info;
		_tmp7_ = alm_applications_widget_markup_for_app (_tmp6_);
		markup = _tmp7_;
		_tmp8_ = alm_applications_tree_view_get_liststore (self);
		_tmp9_ = _tmp8_;
		gtk_list_store_append (_tmp9_, &_tmp10_);
		iter = _tmp10_;
		_tmp11_ = alm_applications_tree_view_get_liststore (self);
		_tmp12_ = _tmp11_;
		_tmp13_ = iter;
		_tmp14_ = markup;
		_tmp15_ = pix;
		_tmp16_ = app;
		gtk_list_store_set (_tmp12_, &_tmp13_, 0, _tmp14_, 1, _tmp15_, 2, _tmp16_, -1, -1);
		_tmp17_ = self->priv->blocked_apps;
		_tmp18_ = app;
		_tmp19_ = g_hash_table_lookup (_tmp17_, _tmp18_);
		if (((AlmAppChooseInfo*) _tmp19_) == NULL) {
			GHashTable* _tmp20_;
			const gchar* _tmp21_;
			gchar* _tmp22_;
			GDesktopAppInfo* _tmp23_;
			const gchar* _tmp24_ = NULL;
			GDesktopAppInfo* _tmp25_;
			const gchar* _tmp26_ = NULL;
			GdkPixbuf* _tmp27_;
			AlmAppChooseInfo* _tmp28_;
			_tmp20_ = self->priv->blocked_apps;
			_tmp21_ = app;
			_tmp22_ = g_strdup (_tmp21_);
			_tmp23_ = app_info;
			_tmp24_ = g_app_info_get_id ((GAppInfo*) _tmp23_);
			_tmp25_ = app_info;
			_tmp26_ = g_app_info_get_name ((GAppInfo*) _tmp25_);
			_tmp27_ = pix;
			_tmp28_ = alm_app_choose_info_new (_tmp24_, _tmp26_, _tmp27_, "", (gint64) 0, (guint) 0);
			g_hash_table_insert (_tmp20_, _tmp22_, _tmp28_);
		}
		_g_free0 (markup);
		_g_object_unref0 (pix);
	}
	_g_object_unref0 (app_info);
}


void alm_applications_tree_view_remove_app_from_view (AlmApplicationsTreeView* self, const gchar* app) {
	GtkTreeView* _tmp0_;
	GtkTreeModel* _tmp1_ = NULL;
	GtkTreeModel* _tmp2_;
	GtkTreeModel* model;
	GtkTreeIter iter = {0};
	GtkTreeModel* _tmp3_;
	GtkTreeIter _tmp4_ = {0};
	g_return_if_fail (self != NULL);
	g_return_if_fail (app != NULL);
	_tmp0_ = self->priv->treeview;
	_tmp1_ = gtk_tree_view_get_model (_tmp0_);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	model = _tmp2_;
	_tmp3_ = model;
	gtk_tree_model_get_iter_first (_tmp3_, &_tmp4_);
	iter = _tmp4_;
	while (TRUE) {
		GValue can_app_value = {0};
		GtkTreeModel* _tmp5_;
		GtkTreeIter _tmp6_;
		GValue _tmp7_ = {0};
		const gchar* _tmp8_ = NULL;
		gchar* _tmp9_;
		gchar* can_app;
		const gchar* _tmp10_;
		const gchar* _tmp11_;
		GtkTreeModel* _tmp14_;
		gboolean _tmp15_ = FALSE;
		gboolean more_entires;
		gboolean _tmp16_;
		_tmp5_ = model;
		_tmp6_ = iter;
		gtk_tree_model_get_value (_tmp5_, &_tmp6_, 2, &_tmp7_);
		G_IS_VALUE (&can_app_value) ? (g_value_unset (&can_app_value), NULL) : NULL;
		can_app_value = _tmp7_;
		_tmp8_ = g_value_get_string (&can_app_value);
		_tmp9_ = g_strdup (_tmp8_);
		can_app = _tmp9_;
		_tmp10_ = app;
		_tmp11_ = can_app;
		if (g_strcmp0 (_tmp10_, _tmp11_) == 0) {
			GtkListStore* _tmp12_;
			GtkTreeIter _tmp13_;
			_tmp12_ = self->priv->store;
			_tmp13_ = iter;
			gtk_list_store_remove (_tmp12_, &_tmp13_);
			_g_free0 (can_app);
			G_IS_VALUE (&can_app_value) ? (g_value_unset (&can_app_value), NULL) : NULL;
			break;
		}
		_tmp14_ = model;
		_tmp15_ = gtk_tree_model_iter_next (_tmp14_, &iter);
		more_entires = _tmp15_;
		_tmp16_ = more_entires;
		if (!_tmp16_) {
			_g_free0 (can_app);
			G_IS_VALUE (&can_app_value) ? (g_value_unset (&can_app_value), NULL) : NULL;
			break;
		}
		_g_free0 (can_app);
		G_IS_VALUE (&can_app_value) ? (g_value_unset (&can_app_value), NULL) : NULL;
	}
	_g_object_unref0 (model);
}


gchar* alm_applications_tree_view_remove_selected_app (AlmApplicationsTreeView* self) {
	gchar* result = NULL;
	GtkTreeView* _tmp0_;
	GtkTreeSelection* _tmp1_ = NULL;
	GtkTreeSelection* _tmp2_;
	GtkTreeSelection* selection;
	GtkTreeModel* model = NULL;
	GtkTreeIter iter = {0};
	gchar* app;
	GtkTreeSelection* _tmp3_;
	GtkTreeModel* _tmp4_ = NULL;
	GtkTreeIter _tmp5_ = {0};
	gboolean _tmp6_ = FALSE;
	GtkTreeModel* _tmp7_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->treeview;
	_tmp1_ = gtk_tree_view_get_selection (_tmp0_);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	selection = _tmp2_;
	app = NULL;
	_tmp3_ = selection;
	_tmp6_ = gtk_tree_selection_get_selected (_tmp3_, &_tmp4_, &_tmp5_);
	_g_object_unref0 (model);
	_tmp7_ = _g_object_ref0 (_tmp4_);
	model = _tmp7_;
	iter = _tmp5_;
	if (_tmp6_) {
		GtkTreeModel* _tmp8_;
		GtkTreeIter _tmp9_;
		GtkListStore* _tmp10_;
		GtkListStore* _tmp11_;
		GtkTreeIter _tmp12_;
		_tmp8_ = model;
		_tmp9_ = iter;
		gtk_tree_model_get (_tmp8_, &_tmp9_, 2, &app, -1);
		_tmp10_ = alm_applications_tree_view_get_liststore (self);
		_tmp11_ = _tmp10_;
		_tmp12_ = iter;
		gtk_list_store_remove (_tmp11_, &_tmp12_);
	}
	result = app;
	_g_object_unref0 (model);
	_g_object_unref0 (selection);
	return result;
}


GtkListStore* alm_applications_tree_view_get_liststore (AlmApplicationsTreeView* self) {
	GtkListStore* result;
	GtkListStore* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->store;
	result = _tmp0_;
	return result;
}


static void alm_applications_tree_view_class_init (AlmApplicationsTreeViewClass * klass) {
	alm_applications_tree_view_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (AlmApplicationsTreeViewPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_alm_applications_tree_view_get_property;
	G_OBJECT_CLASS (klass)->finalize = alm_applications_tree_view_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), ALM_APPLICATIONS_TREE_VIEW_LISTSTORE, g_param_spec_object ("liststore", "liststore", "liststore", GTK_TYPE_LIST_STORE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void alm_applications_tree_view_instance_init (AlmApplicationsTreeView * self) {
	self->priv = ALM_APPLICATIONS_TREE_VIEW_GET_PRIVATE (self);
}


static void alm_applications_tree_view_finalize (GObject* obj) {
	AlmApplicationsTreeView * self;
	self = ALM_APPLICATIONS_TREE_VIEW (obj);
	_alm_application_blacklist_unref0 (self->priv->app_blacklist);
	_g_object_unref0 (self->priv->store);
	_g_object_unref0 (self->priv->treeview);
	_g_hash_table_unref0 (self->priv->blocked_apps);
	_g_hash_table_unref0 (self->priv->unblocked_apps);
	G_OBJECT_CLASS (alm_applications_tree_view_parent_class)->finalize (obj);
}


GType alm_applications_tree_view_get_type (void) {
	static volatile gsize alm_applications_tree_view_type_id__volatile = 0;
	if (g_once_init_enter (&alm_applications_tree_view_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AlmApplicationsTreeViewClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) alm_applications_tree_view_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AlmApplicationsTreeView), 0, (GInstanceInitFunc) alm_applications_tree_view_instance_init, NULL };
		GType alm_applications_tree_view_type_id;
		alm_applications_tree_view_type_id = g_type_register_static (GTK_TYPE_BOX, "AlmApplicationsTreeView", &g_define_type_info, 0);
		g_once_init_leave (&alm_applications_tree_view_type_id__volatile, alm_applications_tree_view_type_id);
	}
	return alm_applications_tree_view_type_id__volatile;
}


static void _vala_alm_applications_tree_view_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	AlmApplicationsTreeView * self;
	self = ALM_APPLICATIONS_TREE_VIEW (object);
	switch (property_id) {
		case ALM_APPLICATIONS_TREE_VIEW_LISTSTORE:
		g_value_set_object (value, alm_applications_tree_view_get_liststore (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static GType alm_app_selection_tree_view_tree_view_cols_get_type (void) {
	static volatile gsize alm_app_selection_tree_view_tree_view_cols_type_id__volatile = 0;
	if (g_once_init_enter (&alm_app_selection_tree_view_tree_view_cols_type_id__volatile)) {
		static const GEnumValue values[] = {{ALM_APP_SELECTION_TREE_VIEW_TREE_VIEW_COLS_APP_NAME, "ALM_APP_SELECTION_TREE_VIEW_TREE_VIEW_COLS_APP_NAME", "app-name"}, {ALM_APP_SELECTION_TREE_VIEW_TREE_VIEW_COLS_ICON, "ALM_APP_SELECTION_TREE_VIEW_TREE_VIEW_COLS_ICON", "icon"}, {ALM_APP_SELECTION_TREE_VIEW_TREE_VIEW_COLS_DESKTOP_FILE, "ALM_APP_SELECTION_TREE_VIEW_TREE_VIEW_COLS_DESKTOP_FILE", "desktop-file"}, {ALM_APP_SELECTION_TREE_VIEW_TREE_VIEW_COLS_LAST_ACCESSED_STRING, "ALM_APP_SELECTION_TREE_VIEW_TREE_VIEW_COLS_LAST_ACCESSED_STRING", "last-accessed-string"}, {ALM_APP_SELECTION_TREE_VIEW_TREE_VIEW_COLS_LAST_ACCESSED_INT, "ALM_APP_SELECTION_TREE_VIEW_TREE_VIEW_COLS_LAST_ACCESSED_INT", "last-accessed-int"}, {ALM_APP_SELECTION_TREE_VIEW_TREE_VIEW_COLS_USAGE, "ALM_APP_SELECTION_TREE_VIEW_TREE_VIEW_COLS_USAGE", "usage"}, {ALM_APP_SELECTION_TREE_VIEW_TREE_VIEW_COLS_N_COLS, "ALM_APP_SELECTION_TREE_VIEW_TREE_VIEW_COLS_N_COLS", "n-cols"}, {0, NULL, NULL}};
		GType alm_app_selection_tree_view_tree_view_cols_type_id;
		alm_app_selection_tree_view_tree_view_cols_type_id = g_enum_register_static ("AlmAppSelectionTreeViewTreeViewCols", values);
		g_once_init_leave (&alm_app_selection_tree_view_tree_view_cols_type_id__volatile, alm_app_selection_tree_view_tree_view_cols_type_id);
	}
	return alm_app_selection_tree_view_tree_view_cols_type_id__volatile;
}


AlmAppSelectionTreeView* alm_app_selection_tree_view_construct (GType object_type, AlmApplicationBlacklist* app_blacklist) {
	AlmAppSelectionTreeView * self = NULL;
	AlmApplicationBlacklist* _tmp0_;
	AlmApplicationBlacklist* _tmp1_;
	GtkListStore* _tmp2_;
	GtkListStore* _tmp3_;
	GtkTreeView* _tmp4_;
	GtkTreeView* _tmp5_;
	GtkTreeView* _tmp6_;
	GtkTreeView* _tmp7_;
	g_return_val_if_fail (app_blacklist != NULL, NULL);
	self = (AlmAppSelectionTreeView*) g_object_new (object_type, "orientation", GTK_ORIENTATION_VERTICAL, NULL);
	_tmp0_ = app_blacklist;
	_tmp1_ = _alm_application_blacklist_ref0 (_tmp0_);
	_alm_application_blacklist_unref0 (self->priv->app_blacklist);
	self->priv->app_blacklist = _tmp1_;
	_tmp2_ = gtk_list_store_new ((gint) ALM_APP_SELECTION_TREE_VIEW_TREE_VIEW_COLS_N_COLS, G_TYPE_STRING, GDK_TYPE_PIXBUF, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_INT64, G_TYPE_UINT);
	_g_object_unref0 (self->priv->store);
	self->priv->store = _tmp2_;
	_tmp3_ = self->priv->store;
	_tmp4_ = (GtkTreeView*) gtk_tree_view_new_with_model ((GtkTreeModel*) _tmp3_);
	_tmp5_ = g_object_ref_sink (_tmp4_);
	_g_object_unref0 (self->priv->treeview);
	self->priv->treeview = _tmp5_;
	_tmp6_ = self->priv->treeview;
	gtk_tree_view_set_headers_visible (_tmp6_, TRUE);
	_tmp7_ = self->priv->treeview;
	gtk_tree_view_set_rules_hint (_tmp7_, TRUE);
	alm_app_selection_tree_view_set_up_ui (self);
	return self;
}


AlmAppSelectionTreeView* alm_app_selection_tree_view_new (AlmApplicationBlacklist* app_blacklist) {
	return alm_app_selection_tree_view_construct (ALM_TYPE_APP_SELECTION_TREE_VIEW, app_blacklist);
}


static void alm_app_selection_tree_view_set_up_ui (AlmAppSelectionTreeView* self) {
	GtkTreeViewColumn* _tmp0_;
	GtkTreeViewColumn* _tmp1_;
	GtkTreeViewColumn* column_pix_name;
	const gchar* _tmp2_ = NULL;
	GtkTreeView* _tmp3_;
	GtkCellRendererPixbuf* _tmp4_;
	GtkCellRendererPixbuf* _tmp5_;
	GtkCellRendererPixbuf* pix_rend;
	GtkCellRendererText* _tmp6_;
	GtkCellRendererText* _tmp7_;
	GtkCellRendererText* name_rend;
	GValue _tmp8_ = {0};
	GtkTreeViewColumn* _tmp9_;
	GtkTreeViewColumn* _tmp10_;
	GtkTreeViewColumn* column_used_name;
	const gchar* _tmp11_ = NULL;
	GtkTreeView* _tmp12_;
	GtkCellRendererText* _tmp13_;
	GtkCellRendererText* _tmp14_;
	GtkCellRendererText* used_rend;
	GValue _tmp15_ = {0};
	GValue _tmp16_ = {0};
	GtkTreeViewColumn* _tmp17_;
	GtkTreeViewColumn* _tmp18_;
	GtkTreeViewColumn* column_usage_name;
	const gchar* _tmp19_ = NULL;
	GtkTreeView* _tmp20_;
	AlmUsageCellRenderer* _tmp21_;
	AlmUsageCellRenderer* _tmp22_;
	AlmUsageCellRenderer* usage_rend;
	GtkScrolledWindow* _tmp23_;
	GtkScrolledWindow* _tmp24_;
	GtkScrolledWindow* scroll;
	GtkTreeView* _tmp25_;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_tree_view_column_new ();
	_tmp1_ = g_object_ref_sink (_tmp0_);
	column_pix_name = _tmp1_;
	_tmp2_ = _ ("Name");
	gtk_tree_view_column_set_title (column_pix_name, _tmp2_);
	_tmp3_ = self->priv->treeview;
	gtk_tree_view_append_column (_tmp3_, column_pix_name);
	_tmp4_ = (GtkCellRendererPixbuf*) gtk_cell_renderer_pixbuf_new ();
	_tmp5_ = g_object_ref_sink (_tmp4_);
	pix_rend = _tmp5_;
	gtk_cell_layout_pack_start ((GtkCellLayout*) column_pix_name, (GtkCellRenderer*) pix_rend, FALSE);
	gtk_cell_layout_add_attribute ((GtkCellLayout*) column_pix_name, (GtkCellRenderer*) pix_rend, "pixbuf", 1);
	_tmp6_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	_tmp7_ = g_object_ref_sink (_tmp6_);
	name_rend = _tmp7_;
	g_value_init (&_tmp8_, PANGO_TYPE_ELLIPSIZE_MODE);
	g_value_set_enum (&_tmp8_, PANGO_ELLIPSIZE_END);
	g_object_set_property ((GObject*) name_rend, "ellipsize", &_tmp8_);
	G_IS_VALUE (&_tmp8_) ? (g_value_unset (&_tmp8_), NULL) : NULL;
	gtk_cell_layout_pack_start ((GtkCellLayout*) column_pix_name, (GtkCellRenderer*) name_rend, TRUE);
	gtk_cell_layout_add_attribute ((GtkCellLayout*) column_pix_name, (GtkCellRenderer*) name_rend, "text", 0);
	gtk_tree_view_column_set_resizable (column_pix_name, TRUE);
	gtk_tree_view_column_set_min_width (column_pix_name, 200);
	gtk_tree_view_column_set_max_width (column_pix_name, 400);
	gtk_tree_view_column_set_sort_column_id (column_pix_name, 0);
	_tmp9_ = gtk_tree_view_column_new ();
	_tmp10_ = g_object_ref_sink (_tmp9_);
	column_used_name = _tmp10_;
	_tmp11_ = _ ("Last Used");
	gtk_tree_view_column_set_title (column_used_name, _tmp11_);
	_tmp12_ = self->priv->treeview;
	gtk_tree_view_append_column (_tmp12_, column_used_name);
	_tmp13_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	_tmp14_ = g_object_ref_sink (_tmp13_);
	used_rend = _tmp14_;
	g_value_init (&_tmp15_, PANGO_TYPE_ELLIPSIZE_MODE);
	g_value_set_enum (&_tmp15_, PANGO_ELLIPSIZE_END);
	g_object_set_property ((GObject*) used_rend, "ellipsize", &_tmp15_);
	G_IS_VALUE (&_tmp15_) ? (g_value_unset (&_tmp15_), NULL) : NULL;
	gtk_cell_layout_pack_start ((GtkCellLayout*) column_used_name, (GtkCellRenderer*) used_rend, TRUE);
	gtk_cell_layout_add_attribute ((GtkCellLayout*) column_used_name, (GtkCellRenderer*) used_rend, "text", 3);
	gtk_tree_view_column_set_resizable (column_used_name, TRUE);
	gtk_tree_view_column_set_min_width (column_used_name, 200);
	gtk_tree_view_column_set_max_width (column_used_name, 400);
	gtk_tree_view_column_set_sort_column_id (column_used_name, 4);
	g_value_init (&_tmp16_, G_TYPE_INT);
	g_value_set_int (&_tmp16_, 0);
	g_object_set_property ((GObject*) used_rend, "xalign", &_tmp16_);
	G_IS_VALUE (&_tmp16_) ? (g_value_unset (&_tmp16_), NULL) : NULL;
	_tmp17_ = gtk_tree_view_column_new ();
	_tmp18_ = g_object_ref_sink (_tmp17_);
	column_usage_name = _tmp18_;
	_tmp19_ = _ ("Activity");
	gtk_tree_view_column_set_title (column_usage_name, _tmp19_);
	_tmp20_ = self->priv->treeview;
	gtk_tree_view_append_column (_tmp20_, column_usage_name);
	_tmp21_ = alm_usage_cell_renderer_new ();
	_tmp22_ = g_object_ref_sink (_tmp21_);
	usage_rend = _tmp22_;
	gtk_cell_layout_pack_start ((GtkCellLayout*) column_usage_name, (GtkCellRenderer*) usage_rend, TRUE);
	gtk_cell_layout_add_attribute ((GtkCellLayout*) column_usage_name, (GtkCellRenderer*) usage_rend, "usage", 5);
	gtk_tree_view_column_set_sort_column_id (column_usage_name, 5);
	gtk_tree_view_column_clicked (column_usage_name);
	gtk_tree_view_column_clicked (column_usage_name);
	_tmp23_ = (GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL);
	_tmp24_ = g_object_ref_sink (_tmp23_);
	scroll = _tmp24_;
	_tmp25_ = self->priv->treeview;
	gtk_container_add ((GtkContainer*) scroll, (GtkWidget*) _tmp25_);
	gtk_scrolled_window_set_policy (scroll, GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_set_shadow_type (scroll, GTK_SHADOW_IN);
	gtk_container_set_border_width ((GtkContainer*) scroll, (guint) 1);
	gtk_box_pack_start ((GtkBox*) self, (GtkWidget*) scroll, TRUE, TRUE, (guint) 0);
	_g_object_unref0 (scroll);
	_g_object_unref0 (usage_rend);
	_g_object_unref0 (column_usage_name);
	_g_object_unref0 (used_rend);
	_g_object_unref0 (column_used_name);
	_g_object_unref0 (name_rend);
	_g_object_unref0 (pix_rend);
	_g_object_unref0 (column_pix_name);
}


GtkTreeView* alm_app_selection_tree_view_get_tree (AlmAppSelectionTreeView* self) {
	GtkTreeView* result;
	GtkTreeView* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->treeview;
	result = _tmp0_;
	return result;
}


GtkListStore* alm_app_selection_tree_view_get_liststore (AlmAppSelectionTreeView* self) {
	GtkListStore* result;
	GtkListStore* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->store;
	result = _tmp0_;
	return result;
}


static void alm_app_selection_tree_view_class_init (AlmAppSelectionTreeViewClass * klass) {
	alm_app_selection_tree_view_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (AlmAppSelectionTreeViewPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_alm_app_selection_tree_view_get_property;
	G_OBJECT_CLASS (klass)->finalize = alm_app_selection_tree_view_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), ALM_APP_SELECTION_TREE_VIEW_TREE, g_param_spec_object ("tree", "tree", "tree", GTK_TYPE_TREE_VIEW, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), ALM_APP_SELECTION_TREE_VIEW_LISTSTORE, g_param_spec_object ("liststore", "liststore", "liststore", GTK_TYPE_LIST_STORE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void alm_app_selection_tree_view_instance_init (AlmAppSelectionTreeView * self) {
	self->priv = ALM_APP_SELECTION_TREE_VIEW_GET_PRIVATE (self);
}


static void alm_app_selection_tree_view_finalize (GObject* obj) {
	AlmAppSelectionTreeView * self;
	self = ALM_APP_SELECTION_TREE_VIEW (obj);
	_alm_application_blacklist_unref0 (self->priv->app_blacklist);
	_g_object_unref0 (self->priv->store);
	_g_object_unref0 (self->priv->treeview);
	G_OBJECT_CLASS (alm_app_selection_tree_view_parent_class)->finalize (obj);
}


GType alm_app_selection_tree_view_get_type (void) {
	static volatile gsize alm_app_selection_tree_view_type_id__volatile = 0;
	if (g_once_init_enter (&alm_app_selection_tree_view_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AlmAppSelectionTreeViewClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) alm_app_selection_tree_view_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AlmAppSelectionTreeView), 0, (GInstanceInitFunc) alm_app_selection_tree_view_instance_init, NULL };
		GType alm_app_selection_tree_view_type_id;
		alm_app_selection_tree_view_type_id = g_type_register_static (GTK_TYPE_BOX, "AlmAppSelectionTreeView", &g_define_type_info, 0);
		g_once_init_leave (&alm_app_selection_tree_view_type_id__volatile, alm_app_selection_tree_view_type_id);
	}
	return alm_app_selection_tree_view_type_id__volatile;
}


static void _vala_alm_app_selection_tree_view_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	AlmAppSelectionTreeView * self;
	self = ALM_APP_SELECTION_TREE_VIEW (object);
	switch (property_id) {
		case ALM_APP_SELECTION_TREE_VIEW_TREE:
		g_value_set_object (value, alm_app_selection_tree_view_get_tree (self));
		break;
		case ALM_APP_SELECTION_TREE_VIEW_LISTSTORE:
		g_value_set_object (value, alm_app_selection_tree_view_get_liststore (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


AlmApplicationsChooserDialog* alm_applications_chooser_dialog_construct (GType object_type, AlmApplicationBlacklist* app_blacklist, GHashTable* blocked_list, GHashTable* unblocked_list) {
	AlmApplicationsChooserDialog * self = NULL;
	AlmApplicationBlacklist* _tmp0_;
	AlmApplicationBlacklist* _tmp1_;
	GHashTable* _tmp2_;
	GHashTable* _tmp3_;
	GHashTable* _tmp4_;
	GHashTable* _tmp5_;
	GHashFunc _tmp6_;
	GEqualFunc _tmp7_;
	GHashTable* _tmp8_;
	const gchar* _tmp9_ = NULL;
	AlmApplicationBlacklist* _tmp10_;
	g_return_val_if_fail (app_blacklist != NULL, NULL);
	g_return_val_if_fail (blocked_list != NULL, NULL);
	g_return_val_if_fail (unblocked_list != NULL, NULL);
	self = (AlmApplicationsChooserDialog*) g_object_new (object_type, NULL);
	_tmp0_ = app_blacklist;
	_tmp1_ = _alm_application_blacklist_ref0 (_tmp0_);
	_alm_application_blacklist_unref0 (self->priv->app_blacklist);
	self->priv->app_blacklist = _tmp1_;
	_tmp2_ = blocked_list;
	_tmp3_ = _g_hash_table_ref0 (_tmp2_);
	_g_hash_table_unref0 (self->priv->blocked_apps);
	self->priv->blocked_apps = _tmp3_;
	_tmp4_ = unblocked_list;
	_tmp5_ = _g_hash_table_ref0 (_tmp4_);
	_g_hash_table_unref0 (self->priv->unblocked_apps);
	self->priv->unblocked_apps = _tmp5_;
	_tmp6_ = g_str_hash;
	_tmp7_ = g_str_equal;
	_tmp8_ = g_hash_table_new_full (_tmp6_, _tmp7_, _g_free0_, _g_free0_);
	_g_hash_table_unref0 (self->priv->actors_iter);
	self->priv->actors_iter = _tmp8_;
	_tmp9_ = _ ("Select Application");
	gtk_window_set_title ((GtkWindow*) self, _tmp9_);
	gtk_window_set_destroy_with_parent ((GtkWindow*) self, TRUE);
	gtk_widget_set_size_request ((GtkWidget*) self, 600, 400);
	gtk_window_set_skip_taskbar_hint ((GtkWindow*) self, TRUE);
	gtk_container_set_border_width ((GtkContainer*) self, (guint) 12);
	gtk_window_set_resizable ((GtkWindow*) self, FALSE);
	alm_applications_chooser_dialog_set_up_ui (self);
	_tmp10_ = self->priv->app_blacklist;
	alm_application_blacklist_get_all_applications (_tmp10_, self);
	return self;
}


AlmApplicationsChooserDialog* alm_applications_chooser_dialog_new (AlmApplicationBlacklist* app_blacklist, GHashTable* blocked_list, GHashTable* unblocked_list) {
	return alm_applications_chooser_dialog_construct (ALM_TYPE_APPLICATIONS_CHOOSER_DIALOG, app_blacklist, blocked_list, unblocked_list);
}


static gint alm_applications_chooser_dialog_compare_dates (AlmApplicationsChooserDialog* self, GDateTime* now, GDateTime* time) {
	gint result = 0;
	gint res;
	gint now_y = 0;
	gint now_m = 0;
	gint now_d = 0;
	gint time_y = 0;
	gint time_m = 0;
	gint time_d = 0;
	GDateTime* _tmp0_;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	GDateTime* _tmp4_;
	gint _tmp5_ = 0;
	gint _tmp6_ = 0;
	gint _tmp7_ = 0;
	gboolean _tmp8_ = FALSE;
	gboolean _tmp9_ = FALSE;
	gint _tmp10_;
	gint _tmp11_;
	gboolean _tmp14_;
	gboolean _tmp17_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (now != NULL, 0);
	g_return_val_if_fail (time != NULL, 0);
	res = -1;
	_tmp0_ = now;
	g_date_time_get_ymd (_tmp0_, &_tmp1_, &_tmp2_, &_tmp3_);
	now_y = _tmp1_;
	now_m = _tmp2_;
	now_d = _tmp3_;
	_tmp4_ = time;
	g_date_time_get_ymd (_tmp4_, &_tmp5_, &_tmp6_, &_tmp7_);
	time_y = _tmp5_;
	time_m = _tmp6_;
	time_d = _tmp7_;
	_tmp10_ = now_y;
	_tmp11_ = time_y;
	if (_tmp10_ == _tmp11_) {
		gint _tmp12_;
		gint _tmp13_;
		_tmp12_ = now_m;
		_tmp13_ = time_m;
		_tmp9_ = _tmp12_ == _tmp13_;
	} else {
		_tmp9_ = FALSE;
	}
	_tmp14_ = _tmp9_;
	if (_tmp14_) {
		gint _tmp15_;
		gint _tmp16_;
		_tmp15_ = now_d;
		_tmp16_ = time_d;
		_tmp8_ = _tmp15_ == _tmp16_;
	} else {
		_tmp8_ = FALSE;
	}
	_tmp17_ = _tmp8_;
	if (_tmp17_) {
		result = 0;
		return result;
	} else {
		gboolean _tmp18_ = FALSE;
		gboolean _tmp19_ = FALSE;
		gint _tmp20_;
		gint _tmp21_;
		gboolean _tmp24_;
		gboolean _tmp27_;
		_tmp20_ = now_y;
		_tmp21_ = time_y;
		if (_tmp20_ == _tmp21_) {
			gint _tmp22_;
			gint _tmp23_;
			_tmp22_ = now_m;
			_tmp23_ = time_m;
			_tmp19_ = _tmp22_ == _tmp23_;
		} else {
			_tmp19_ = FALSE;
		}
		_tmp24_ = _tmp19_;
		if (_tmp24_) {
			gint _tmp25_;
			gint _tmp26_;
			_tmp25_ = now_d;
			_tmp26_ = time_d;
			_tmp18_ = _tmp25_ == (_tmp26_ + 1);
		} else {
			_tmp18_ = FALSE;
		}
		_tmp27_ = _tmp18_;
		if (_tmp27_) {
			result = 1;
			return result;
		}
	}
	result = res;
	return result;
}


static gint64* _int64_dup (gint64* self) {
	gint64* dup;
	dup = g_new0 (gint64, 1);
	memcpy (dup, self, sizeof (gint64));
	return dup;
}


static gpointer __int64_dup0 (gpointer self) {
	return self ? _int64_dup (self) : NULL;
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


void alm_applications_chooser_dialog_handle_app_population (AlmApplicationsChooserDialog* self, GHashTable* all_actors) {
	GHashTable* _tmp0_;
	GHashTable* _tmp1_;
	GList* _tmp2_ = NULL;
	GList* all_infos;
	GList* other_appinfo;
	GList* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (all_actors != NULL);
	_tmp0_ = all_actors;
	_tmp1_ = _g_hash_table_ref0 (_tmp0_);
	_g_hash_table_unref0 (self->priv->all_actors_list);
	self->priv->all_actors_list = _tmp1_;
	_tmp2_ = g_app_info_get_all ();
	all_infos = _tmp2_;
	other_appinfo = NULL;
	_tmp3_ = all_infos;
	{
		GList* app_info_collection = NULL;
		GList* app_info_it = NULL;
		app_info_collection = _tmp3_;
		for (app_info_it = app_info_collection; app_info_it != NULL; app_info_it = app_info_it->next) {
			GAppInfo* _tmp4_;
			GAppInfo* app_info = NULL;
			_tmp4_ = _g_object_ref0 ((GAppInfo*) app_info_it->data);
			app_info = _tmp4_;
			{
				GAppInfo* _tmp5_;
				const gchar* _tmp6_ = NULL;
				gchar* _tmp7_;
				gchar* id;
				GHashTable* _tmp8_;
				const gchar* _tmp9_;
				gconstpointer _tmp10_ = NULL;
				gint64* _tmp11_;
				gint64* last_accessed_time;
				gint64* _tmp12_;
				_tmp5_ = app_info;
				_tmp6_ = g_app_info_get_id (_tmp5_);
				_tmp7_ = g_strdup (_tmp6_);
				id = _tmp7_;
				_tmp8_ = all_actors;
				_tmp9_ = id;
				_tmp10_ = g_hash_table_lookup (_tmp8_, _tmp9_);
				_tmp11_ = __int64_dup0 ((gint64*) _tmp10_);
				last_accessed_time = _tmp11_;
				_tmp12_ = last_accessed_time;
				if (_tmp12_ != NULL) {
					gint64* _tmp13_;
					GDateTime* _tmp14_;
					GDateTime* time;
					GDateTime* _tmp15_;
					GDateTime* now;
					GDateTime* _tmp16_;
					GDateTime* _tmp17_;
					gint _tmp18_ = 0;
					gint res;
					gchar* _tmp19_;
					gchar* last_accessed;
					gint _tmp20_;
					GAppInfo* _tmp31_;
					const gchar* _tmp32_;
					gint64* _tmp33_;
					_tmp13_ = last_accessed_time;
					_tmp14_ = g_date_time_new_from_unix_local ((*_tmp13_) / 1000);
					time = _tmp14_;
					_tmp15_ = g_date_time_new_now_local ();
					now = _tmp15_;
					_tmp16_ = now;
					_tmp17_ = time;
					_tmp18_ = alm_applications_chooser_dialog_compare_dates (self, _tmp16_, _tmp17_);
					res = _tmp18_;
					_tmp19_ = g_strdup ("");
					last_accessed = _tmp19_;
					_tmp20_ = res;
					if (_tmp20_ == 0) {
						GDateTime* _tmp21_;
						const gchar* _tmp22_ = NULL;
						gchar* _tmp23_ = NULL;
						_tmp21_ = time;
						_tmp22_ = _ ("Today, %H:%M");
						_tmp23_ = g_date_time_format (_tmp21_, _tmp22_);
						_g_free0 (last_accessed);
						last_accessed = _tmp23_;
					} else {
						gint _tmp24_;
						_tmp24_ = res;
						if (_tmp24_ == 1) {
							GDateTime* _tmp25_;
							const gchar* _tmp26_ = NULL;
							gchar* _tmp27_ = NULL;
							_tmp25_ = time;
							_tmp26_ = _ ("Yesterday, %H:%M");
							_tmp27_ = g_date_time_format (_tmp25_, _tmp26_);
							_g_free0 (last_accessed);
							last_accessed = _tmp27_;
						} else {
							GDateTime* _tmp28_;
							const gchar* _tmp29_ = NULL;
							gchar* _tmp30_ = NULL;
							_tmp28_ = time;
							_tmp29_ = _ ("%e %B %Y, %H:%M");
							_tmp30_ = g_date_time_format (_tmp28_, _tmp29_);
							_g_free0 (last_accessed);
							last_accessed = _tmp30_;
						}
					}
					_tmp31_ = app_info;
					_tmp32_ = last_accessed;
					_tmp33_ = last_accessed_time;
					alm_applications_chooser_dialog_insert_liststore (self, _tmp31_, _tmp32_, *_tmp33_, (guint) 0);
					_g_free0 (last_accessed);
					_g_date_time_unref0 (now);
					_g_date_time_unref0 (time);
				} else {
					GAppInfo* _tmp34_;
					GAppInfo* _tmp35_;
					GAppInfo* _tmp36_;
					const gchar* _tmp37_ = NULL;
					_tmp34_ = app_info;
					_tmp35_ = _g_object_ref0 (_tmp34_);
					other_appinfo = g_list_append (other_appinfo, _tmp35_);
					_tmp36_ = app_info;
					_tmp37_ = _ ("Never");
					alm_applications_chooser_dialog_insert_liststore (self, _tmp36_, _tmp37_, (gint64) 0, (guint) 0);
				}
				_g_free0 (last_accessed_time);
				_g_free0 (id);
				_g_object_unref0 (app_info);
			}
		}
	}
	__g_list_free__g_object_unref0_0 (other_appinfo);
	__g_list_free__g_object_unref0_0 (all_infos);
}


void alm_applications_chooser_dialog_insert_liststore (AlmApplicationsChooserDialog* self, GAppInfo* app_info, const gchar* last_accessed, gint64 last_accessed_time, guint usage) {
	GAppInfo* _tmp0_;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* id;
	GAppInfo* _tmp3_;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	gchar* name;
	GAppInfo* _tmp6_;
	GIcon* _tmp7_ = NULL;
	GIcon* _tmp8_;
	GIcon* icon;
	GIcon* _tmp9_;
	GdkPixbuf* _tmp10_ = NULL;
	GdkPixbuf* pix;
	GHashTable* _tmp11_;
	const gchar* _tmp12_;
	gconstpointer _tmp13_ = NULL;
	AlmAppChooseInfo* _tmp14_;
	AlmAppChooseInfo* app_choose_info;
	AlmAppChooseInfo* _tmp15_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (app_info != NULL);
	g_return_if_fail (last_accessed != NULL);
	_tmp0_ = app_info;
	_tmp1_ = g_app_info_get_id (_tmp0_);
	_tmp2_ = g_strdup (_tmp1_);
	id = _tmp2_;
	_tmp3_ = app_info;
	_tmp4_ = g_app_info_get_name (_tmp3_);
	_tmp5_ = g_strdup (_tmp4_);
	name = _tmp5_;
	_tmp6_ = app_info;
	_tmp7_ = g_app_info_get_icon (_tmp6_);
	_tmp8_ = _g_object_ref0 (_tmp7_);
	icon = _tmp8_;
	_tmp9_ = icon;
	_tmp10_ = alm_applications_tree_view_get_pixbuf_from_gio_icon (_tmp9_, 32);
	pix = _tmp10_;
	_tmp11_ = self->priv->blocked_apps;
	_tmp12_ = id;
	_tmp13_ = g_hash_table_lookup (_tmp11_, _tmp12_);
	_tmp14_ = _alm_app_choose_info_ref0 ((AlmAppChooseInfo*) _tmp13_);
	app_choose_info = _tmp14_;
	_tmp15_ = app_choose_info;
	if (_tmp15_ == NULL) {
		GtkTreeIter iter = {0};
		AlmAppSelectionTreeView* _tmp16_;
		GtkListStore* _tmp17_;
		GtkListStore* _tmp18_;
		GtkTreeIter _tmp19_ = {0};
		AlmAppSelectionTreeView* _tmp20_;
		GtkListStore* _tmp21_;
		GtkListStore* _tmp22_;
		GtkTreeIter _tmp23_;
		const gchar* _tmp24_;
		GdkPixbuf* _tmp25_;
		const gchar* _tmp26_;
		const gchar* _tmp27_;
		gint64 _tmp28_;
		GHashTable* _tmp29_;
		const gchar* _tmp30_;
		gchar* _tmp31_;
		const gchar* _tmp32_;
		const gchar* _tmp33_;
		GdkPixbuf* _tmp34_;
		const gchar* _tmp35_;
		gint64 _tmp36_;
		guint _tmp37_;
		AlmAppChooseInfo* _tmp38_;
		gint64 _tmp39_;
		_tmp16_ = self->priv->treeview;
		_tmp17_ = alm_app_selection_tree_view_get_liststore (_tmp16_);
		_tmp18_ = _tmp17_;
		gtk_list_store_append (_tmp18_, &_tmp19_);
		iter = _tmp19_;
		_tmp20_ = self->priv->treeview;
		_tmp21_ = alm_app_selection_tree_view_get_liststore (_tmp20_);
		_tmp22_ = _tmp21_;
		_tmp23_ = iter;
		_tmp24_ = name;
		_tmp25_ = pix;
		_tmp26_ = id;
		_tmp27_ = last_accessed;
		_tmp28_ = last_accessed_time;
		gtk_list_store_set (_tmp22_, &_tmp23_, 0, _tmp24_, 1, _tmp25_, 2, _tmp26_, 3, _tmp27_, 4, _tmp28_, 5, 0, -1, -1);
		_tmp29_ = self->priv->blocked_apps;
		_tmp30_ = id;
		_tmp31_ = g_strdup (_tmp30_);
		_tmp32_ = id;
		_tmp33_ = name;
		_tmp34_ = pix;
		_tmp35_ = last_accessed;
		_tmp36_ = last_accessed_time;
		_tmp37_ = usage;
		_tmp38_ = alm_app_choose_info_new (_tmp32_, _tmp33_, _tmp34_, _tmp35_, _tmp36_, _tmp37_);
		g_hash_table_insert (_tmp29_, _tmp31_, _tmp38_);
		_tmp39_ = last_accessed_time;
		if (_tmp39_ > ((gint64) 0)) {
			AlmApplicationBlacklist* _tmp40_;
			const gchar* _tmp41_;
			GtkTreeIter _tmp42_;
			AlmAppSelectionTreeView* _tmp43_;
			GtkListStore* _tmp44_;
			GtkListStore* _tmp45_;
			_tmp40_ = self->priv->app_blacklist;
			_tmp41_ = id;
			_tmp42_ = iter;
			_tmp43_ = self->priv->treeview;
			_tmp44_ = alm_app_selection_tree_view_get_liststore (_tmp43_);
			_tmp45_ = _tmp44_;
			alm_application_blacklist_get_count_for_app (_tmp40_, _tmp41_, &_tmp42_, _tmp45_);
		}
	} else {
		AlmAppChooseInfo* _tmp46_;
		const gchar* _tmp47_;
		AlmAppChooseInfo* _tmp48_;
		_tmp46_ = app_choose_info;
		_tmp47_ = last_accessed;
		alm_app_choose_info_set_last_accessed (_tmp46_, _tmp47_);
		_tmp48_ = app_choose_info;
		alm_app_choose_info_set_usage (_tmp48_, (guint) 0);
	}
	_alm_app_choose_info_unref0 (app_choose_info);
	_g_object_unref0 (pix);
	_g_object_unref0 (icon);
	_g_free0 (name);
	_g_free0 (id);
}


void alm_applications_chooser_dialog_insert_app_liststore (AlmApplicationsChooserDialog* self, const gchar* app) {
	GHashTable* _tmp0_;
	const gchar* _tmp1_;
	gconstpointer _tmp2_ = NULL;
	AlmAppChooseInfo* _tmp3_;
	AlmAppChooseInfo* app_choose_info;
	AlmAppChooseInfo* _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (app != NULL);
	_tmp0_ = self->priv->unblocked_apps;
	_tmp1_ = app;
	_tmp2_ = g_hash_table_lookup (_tmp0_, _tmp1_);
	_tmp3_ = _alm_app_choose_info_ref0 ((AlmAppChooseInfo*) _tmp2_);
	app_choose_info = _tmp3_;
	_tmp4_ = app_choose_info;
	if (_tmp4_ != NULL) {
		GtkTreeIter iter = {0};
		AlmAppSelectionTreeView* _tmp5_;
		GtkListStore* _tmp6_;
		GtkListStore* _tmp7_;
		GtkTreeIter _tmp8_ = {0};
		AlmAppSelectionTreeView* _tmp9_;
		GtkListStore* _tmp10_;
		GtkListStore* _tmp11_;
		GtkTreeIter _tmp12_;
		AlmAppChooseInfo* _tmp13_;
		const gchar* _tmp14_;
		const gchar* _tmp15_;
		AlmAppChooseInfo* _tmp16_;
		GdkPixbuf* _tmp17_;
		GdkPixbuf* _tmp18_;
		const gchar* _tmp19_;
		AlmAppChooseInfo* _tmp20_;
		const gchar* _tmp21_;
		const gchar* _tmp22_;
		AlmAppChooseInfo* _tmp23_;
		gint64 _tmp24_;
		gint64 _tmp25_;
		AlmApplicationBlacklist* _tmp26_;
		AlmAppChooseInfo* _tmp27_;
		gchar* _tmp28_ = NULL;
		gchar* _tmp29_;
		GtkTreeIter _tmp30_;
		AlmAppSelectionTreeView* _tmp31_;
		GtkListStore* _tmp32_;
		GtkListStore* _tmp33_;
		_tmp5_ = self->priv->treeview;
		_tmp6_ = alm_app_selection_tree_view_get_liststore (_tmp5_);
		_tmp7_ = _tmp6_;
		gtk_list_store_insert (_tmp7_, &_tmp8_, 1);
		iter = _tmp8_;
		_tmp9_ = self->priv->treeview;
		_tmp10_ = alm_app_selection_tree_view_get_liststore (_tmp9_);
		_tmp11_ = _tmp10_;
		_tmp12_ = iter;
		_tmp13_ = app_choose_info;
		_tmp14_ = alm_app_choose_info_get_name (_tmp13_);
		_tmp15_ = _tmp14_;
		_tmp16_ = app_choose_info;
		_tmp17_ = alm_app_choose_info_get_icon (_tmp16_);
		_tmp18_ = _tmp17_;
		_tmp19_ = app;
		_tmp20_ = app_choose_info;
		_tmp21_ = alm_app_choose_info_get_last_accessed (_tmp20_);
		_tmp22_ = _tmp21_;
		_tmp23_ = app_choose_info;
		_tmp24_ = alm_app_choose_info_get_last_accessed_time (_tmp23_);
		_tmp25_ = _tmp24_;
		gtk_list_store_set (_tmp11_, &_tmp12_, 0, _tmp15_, 1, _tmp18_, 2, _tmp19_, 3, _tmp22_, 4, _tmp25_, -1, -1);
		_tmp26_ = self->priv->app_blacklist;
		_tmp27_ = app_choose_info;
		_tmp28_ = alm_app_choose_info_get_id (_tmp27_);
		_tmp29_ = _tmp28_;
		_tmp30_ = iter;
		_tmp31_ = self->priv->treeview;
		_tmp32_ = alm_app_selection_tree_view_get_liststore (_tmp31_);
		_tmp33_ = _tmp32_;
		alm_application_blacklist_get_count_for_app (_tmp26_, _tmp29_, &_tmp30_, _tmp33_);
		_g_free0 (_tmp29_);
	}
	_alm_app_choose_info_unref0 (app_choose_info);
}


static void alm_applications_chooser_dialog_set_up_ui (AlmApplicationsChooserDialog* self) {
	AlmApplicationBlacklist* _tmp0_;
	AlmAppSelectionTreeView* _tmp1_;
	AlmAppSelectionTreeView* _tmp2_;
	GtkBox* _tmp3_ = NULL;
	GtkBox* _tmp4_;
	GtkBox* area;
	AlmAppSelectionTreeView* _tmp5_;
	AlmAppSelectionTreeView* _tmp6_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->app_blacklist;
	_tmp1_ = alm_app_selection_tree_view_new (_tmp0_);
	_tmp2_ = g_object_ref_sink (_tmp1_);
	_g_object_unref0 (self->priv->treeview);
	self->priv->treeview = _tmp2_;
	_tmp3_ = gtk_dialog_get_content_area ((GtkDialog*) self);
	_tmp4_ = _g_object_ref0 (GTK_IS_BOX (_tmp3_) ? ((GtkBox*) _tmp3_) : NULL);
	area = _tmp4_;
	_tmp5_ = self->priv->treeview;
	gtk_box_pack_start (area, (GtkWidget*) _tmp5_, TRUE, TRUE, (guint) 0);
	gtk_dialog_add_buttons ((GtkDialog*) self, GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, GTK_STOCK_OK, GTK_RESPONSE_OK, NULL);
	_tmp6_ = self->priv->treeview;
	gtk_widget_show_all ((GtkWidget*) _tmp6_);
	_g_object_unref0 (area);
}


GtkTreeView* alm_applications_chooser_dialog_get_tree (AlmApplicationsChooserDialog* self) {
	GtkTreeView* result;
	AlmAppSelectionTreeView* _tmp0_;
	GtkTreeView* _tmp1_;
	GtkTreeView* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->treeview;
	_tmp1_ = alm_app_selection_tree_view_get_tree (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


GtkListStore* alm_applications_chooser_dialog_get_liststore (AlmApplicationsChooserDialog* self) {
	GtkListStore* result;
	AlmAppSelectionTreeView* _tmp0_;
	GtkListStore* _tmp1_;
	GtkListStore* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->treeview;
	_tmp1_ = alm_app_selection_tree_view_get_liststore (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


static void alm_applications_chooser_dialog_class_init (AlmApplicationsChooserDialogClass * klass) {
	alm_applications_chooser_dialog_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (AlmApplicationsChooserDialogPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_alm_applications_chooser_dialog_get_property;
	G_OBJECT_CLASS (klass)->finalize = alm_applications_chooser_dialog_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), ALM_APPLICATIONS_CHOOSER_DIALOG_TREE, g_param_spec_object ("tree", "tree", "tree", GTK_TYPE_TREE_VIEW, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), ALM_APPLICATIONS_CHOOSER_DIALOG_LISTSTORE, g_param_spec_object ("liststore", "liststore", "liststore", GTK_TYPE_LIST_STORE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void alm_applications_chooser_dialog_instance_init (AlmApplicationsChooserDialog * self) {
	self->priv = ALM_APPLICATIONS_CHOOSER_DIALOG_GET_PRIVATE (self);
}


static void alm_applications_chooser_dialog_finalize (GObject* obj) {
	AlmApplicationsChooserDialog * self;
	self = ALM_APPLICATIONS_CHOOSER_DIALOG (obj);
	_alm_application_blacklist_unref0 (self->priv->app_blacklist);
	_g_object_unref0 (self->priv->treeview);
	_g_hash_table_unref0 (self->priv->all_actors_list);
	_g_hash_table_unref0 (self->priv->actors_iter);
	_g_hash_table_unref0 (self->priv->blocked_apps);
	_g_hash_table_unref0 (self->priv->unblocked_apps);
	G_OBJECT_CLASS (alm_applications_chooser_dialog_parent_class)->finalize (obj);
}


GType alm_applications_chooser_dialog_get_type (void) {
	static volatile gsize alm_applications_chooser_dialog_type_id__volatile = 0;
	if (g_once_init_enter (&alm_applications_chooser_dialog_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AlmApplicationsChooserDialogClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) alm_applications_chooser_dialog_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AlmApplicationsChooserDialog), 0, (GInstanceInitFunc) alm_applications_chooser_dialog_instance_init, NULL };
		GType alm_applications_chooser_dialog_type_id;
		alm_applications_chooser_dialog_type_id = g_type_register_static (GTK_TYPE_DIALOG, "AlmApplicationsChooserDialog", &g_define_type_info, 0);
		g_once_init_leave (&alm_applications_chooser_dialog_type_id__volatile, alm_applications_chooser_dialog_type_id);
	}
	return alm_applications_chooser_dialog_type_id__volatile;
}


static void _vala_alm_applications_chooser_dialog_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	AlmApplicationsChooserDialog * self;
	self = ALM_APPLICATIONS_CHOOSER_DIALOG (object);
	switch (property_id) {
		case ALM_APPLICATIONS_CHOOSER_DIALOG_TREE:
		g_value_set_object (value, alm_applications_chooser_dialog_get_tree (self));
		break;
		case ALM_APPLICATIONS_CHOOSER_DIALOG_LISTSTORE:
		g_value_set_object (value, alm_applications_chooser_dialog_get_liststore (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


AlmUsageCellRenderer* alm_usage_cell_renderer_construct (GType object_type) {
	AlmUsageCellRenderer * self = NULL;
	self = (AlmUsageCellRenderer*) g_object_new (object_type, NULL);
	self->priv->usage_num = 0;
	return self;
}


AlmUsageCellRenderer* alm_usage_cell_renderer_new (void) {
	return alm_usage_cell_renderer_construct (ALM_TYPE_USAGE_CELL_RENDERER);
}


static void alm_usage_cell_renderer_real_get_size (GtkCellRenderer* base, GtkWidget* widget, GdkRectangle* cell_area, gint* x_offset, gint* y_offset, gint* width, gint* height) {
	AlmUsageCellRenderer * self;
	gint _vala_x_offset = 0;
	gint _vala_y_offset = 0;
	gint _vala_width = 0;
	gint _vala_height = 0;
	self = (AlmUsageCellRenderer*) base;
	g_return_if_fail (widget != NULL);
	_vala_x_offset = ALM_USAGE_CELL_RENDERER_xpadding;
	_vala_y_offset = ALM_USAGE_CELL_RENDERER_ypadding;
	_vala_width = ((ALM_USAGE_CELL_RENDERER_RECT_WIDTH * ALM_USAGE_CELL_RENDERER_RECT_NUM) + (ALM_USAGE_CELL_RENDERER_xpadding * 2)) + (ALM_USAGE_CELL_RENDERER_RECT_SPACING * 9);
	_vala_height = ALM_USAGE_CELL_RENDERER_RECT_HEIGHT + (ALM_USAGE_CELL_RENDERER_ypadding * 2);
	if (x_offset) {
		*x_offset = _vala_x_offset;
	}
	if (y_offset) {
		*y_offset = _vala_y_offset;
	}
	if (width) {
		*width = _vala_width;
	}
	if (height) {
		*height = _vala_height;
	}
}


static void alm_usage_cell_renderer_real_render (GtkCellRenderer* base, cairo_t* ctx, GtkWidget* widget, GdkRectangle* background_area, GdkRectangle* cell_area, GtkCellRendererState flags) {
	AlmUsageCellRenderer * self;
	GdkRectangle _tmp0_;
	gint _tmp1_;
	gint x;
	GdkRectangle _tmp2_;
	gint _tmp3_;
	gint y;
	self = (AlmUsageCellRenderer*) base;
	g_return_if_fail (ctx != NULL);
	g_return_if_fail (widget != NULL);
	g_return_if_fail (background_area != NULL);
	g_return_if_fail (cell_area != NULL);
	_tmp0_ = *cell_area;
	_tmp1_ = _tmp0_.x;
	x = _tmp1_ + ALM_USAGE_CELL_RENDERER_xpadding;
	_tmp2_ = *cell_area;
	_tmp3_ = _tmp2_.y;
	y = _tmp3_ + ALM_USAGE_CELL_RENDERER_ypadding;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp4_;
			_tmp4_ = TRUE;
			while (TRUE) {
				gboolean _tmp5_;
				gint _tmp7_;
				gint _tmp8_;
				gint _tmp9_;
				cairo_t* _tmp10_;
				cairo_t* _tmp11_;
				gint _tmp12_;
				gint _tmp13_;
				cairo_t* _tmp14_;
				gint _tmp15_;
				_tmp5_ = _tmp4_;
				if (!_tmp5_) {
					gint _tmp6_;
					_tmp6_ = i;
					i = _tmp6_ + 1;
				}
				_tmp4_ = FALSE;
				_tmp7_ = i;
				_tmp8_ = alm_usage_cell_renderer_get_usage (self);
				_tmp9_ = _tmp8_;
				if (!(_tmp7_ < _tmp9_)) {
					break;
				}
				_tmp10_ = ctx;
				cairo_set_source_rgb (_tmp10_, 0.4, 0.4, 0.4);
				_tmp11_ = ctx;
				_tmp12_ = x;
				_tmp13_ = y;
				cairo_rectangle (_tmp11_, (gdouble) _tmp12_, (gdouble) _tmp13_, (gdouble) ALM_USAGE_CELL_RENDERER_RECT_WIDTH, (gdouble) ALM_USAGE_CELL_RENDERER_RECT_HEIGHT);
				_tmp14_ = ctx;
				cairo_fill (_tmp14_);
				_tmp15_ = x;
				x = _tmp15_ + (ALM_USAGE_CELL_RENDERER_RECT_SPACING + ALM_USAGE_CELL_RENDERER_RECT_WIDTH);
			}
		}
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp16_;
			_tmp16_ = TRUE;
			while (TRUE) {
				gboolean _tmp17_;
				gint _tmp19_;
				gint _tmp20_;
				gint _tmp21_;
				cairo_t* _tmp22_;
				cairo_t* _tmp23_;
				gint _tmp24_;
				gint _tmp25_;
				cairo_t* _tmp26_;
				gint _tmp27_;
				_tmp17_ = _tmp16_;
				if (!_tmp17_) {
					gint _tmp18_;
					_tmp18_ = i;
					i = _tmp18_ + 1;
				}
				_tmp16_ = FALSE;
				_tmp19_ = i;
				_tmp20_ = alm_usage_cell_renderer_get_usage (self);
				_tmp21_ = _tmp20_;
				if (!(_tmp19_ < (ALM_USAGE_CELL_RENDERER_RECT_NUM - _tmp21_))) {
					break;
				}
				_tmp22_ = ctx;
				cairo_set_source_rgb (_tmp22_, 0.7, 0.7, 0.7);
				_tmp23_ = ctx;
				_tmp24_ = x;
				_tmp25_ = y;
				cairo_rectangle (_tmp23_, (gdouble) _tmp24_, (gdouble) _tmp25_, (gdouble) ALM_USAGE_CELL_RENDERER_RECT_WIDTH, (gdouble) ALM_USAGE_CELL_RENDERER_RECT_HEIGHT);
				_tmp26_ = ctx;
				cairo_fill (_tmp26_);
				_tmp27_ = x;
				x = _tmp27_ + (ALM_USAGE_CELL_RENDERER_RECT_SPACING + ALM_USAGE_CELL_RENDERER_RECT_WIDTH);
			}
		}
	}
}


gint alm_usage_cell_renderer_get_usage (AlmUsageCellRenderer* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->usage_num;
	result = _tmp0_;
	return result;
}


void alm_usage_cell_renderer_set_usage (AlmUsageCellRenderer* self, gint value) {
	gint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	if (_tmp0_ > 10) {
		self->priv->usage_num = 10;
	} else {
		gint _tmp1_;
		_tmp1_ = value;
		self->priv->usage_num = _tmp1_;
	}
	g_object_notify ((GObject *) self, "usage");
}


static void alm_usage_cell_renderer_class_init (AlmUsageCellRendererClass * klass) {
	alm_usage_cell_renderer_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (AlmUsageCellRendererPrivate));
	GTK_CELL_RENDERER_CLASS (klass)->get_size = alm_usage_cell_renderer_real_get_size;
	GTK_CELL_RENDERER_CLASS (klass)->render = alm_usage_cell_renderer_real_render;
	G_OBJECT_CLASS (klass)->get_property = _vala_alm_usage_cell_renderer_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_alm_usage_cell_renderer_set_property;
	G_OBJECT_CLASS (klass)->finalize = alm_usage_cell_renderer_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), ALM_USAGE_CELL_RENDERER_USAGE, g_param_spec_int ("usage", "usage", "usage", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void alm_usage_cell_renderer_instance_init (AlmUsageCellRenderer * self) {
	self->priv = ALM_USAGE_CELL_RENDERER_GET_PRIVATE (self);
}


static void alm_usage_cell_renderer_finalize (GObject* obj) {
	AlmUsageCellRenderer * self;
	self = ALM_USAGE_CELL_RENDERER (obj);
	G_OBJECT_CLASS (alm_usage_cell_renderer_parent_class)->finalize (obj);
}


GType alm_usage_cell_renderer_get_type (void) {
	static volatile gsize alm_usage_cell_renderer_type_id__volatile = 0;
	if (g_once_init_enter (&alm_usage_cell_renderer_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AlmUsageCellRendererClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) alm_usage_cell_renderer_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AlmUsageCellRenderer), 0, (GInstanceInitFunc) alm_usage_cell_renderer_instance_init, NULL };
		GType alm_usage_cell_renderer_type_id;
		alm_usage_cell_renderer_type_id = g_type_register_static (GTK_TYPE_CELL_RENDERER, "AlmUsageCellRenderer", &g_define_type_info, 0);
		g_once_init_leave (&alm_usage_cell_renderer_type_id__volatile, alm_usage_cell_renderer_type_id);
	}
	return alm_usage_cell_renderer_type_id__volatile;
}


static void _vala_alm_usage_cell_renderer_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	AlmUsageCellRenderer * self;
	self = ALM_USAGE_CELL_RENDERER (object);
	switch (property_id) {
		case ALM_USAGE_CELL_RENDERER_USAGE:
		g_value_set_int (value, alm_usage_cell_renderer_get_usage (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_alm_usage_cell_renderer_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	AlmUsageCellRenderer * self;
	self = ALM_USAGE_CELL_RENDERER (object);
	switch (property_id) {
		case ALM_USAGE_CELL_RENDERER_USAGE:
		alm_usage_cell_renderer_set_usage (self, g_value_get_int (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


AlmAppChooseInfo* alm_app_choose_info_construct (GType object_type, const gchar* id, const gchar* app_name, GdkPixbuf* app_icon, const gchar* last_accessed_time_s, gint64 last_accessed_time_i, guint usage_rating) {
	AlmAppChooseInfo* self = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	GdkPixbuf* _tmp2_;
	GdkPixbuf* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	gint64 _tmp6_;
	guint _tmp7_;
	const gchar* _tmp8_;
	gchar* _tmp9_;
	g_return_val_if_fail (id != NULL, NULL);
	g_return_val_if_fail (app_name != NULL, NULL);
	g_return_val_if_fail (last_accessed_time_s != NULL, NULL);
	self = (AlmAppChooseInfo*) g_type_create_instance (object_type);
	_tmp0_ = app_name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->app_name);
	self->priv->app_name = _tmp1_;
	_tmp2_ = app_icon;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (self->priv->app_icon);
	self->priv->app_icon = _tmp3_;
	_tmp4_ = last_accessed_time_s;
	_tmp5_ = g_strdup (_tmp4_);
	_g_free0 (self->priv->last_accessed_time_s);
	self->priv->last_accessed_time_s = _tmp5_;
	_tmp6_ = last_accessed_time_i;
	self->priv->last_accessed_time_i = _tmp6_;
	_tmp7_ = usage_rating;
	self->priv->usage_rating = _tmp7_;
	_tmp8_ = id;
	_tmp9_ = g_strdup (_tmp8_);
	_g_free0 (self->priv->app_id);
	self->priv->app_id = _tmp9_;
	return self;
}


AlmAppChooseInfo* alm_app_choose_info_new (const gchar* id, const gchar* app_name, GdkPixbuf* app_icon, const gchar* last_accessed_time_s, gint64 last_accessed_time_i, guint usage_rating) {
	return alm_app_choose_info_construct (ALM_TYPE_APP_CHOOSE_INFO, id, app_name, app_icon, last_accessed_time_s, last_accessed_time_i, usage_rating);
}


gchar* alm_app_choose_info_get_id (AlmAppChooseInfo* self) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->app_id;
	_tmp1_ = g_strdup (_tmp0_);
	result = _tmp1_;
	return result;
}


const gchar* alm_app_choose_info_get_name (AlmAppChooseInfo* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->app_name;
	result = _tmp0_;
	return result;
}


void alm_app_choose_info_set_name (AlmAppChooseInfo* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->app_name);
	self->priv->app_name = _tmp1_;
}


GdkPixbuf* alm_app_choose_info_get_icon (AlmAppChooseInfo* self) {
	GdkPixbuf* result;
	GdkPixbuf* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->app_icon;
	result = _tmp0_;
	return result;
}


void alm_app_choose_info_set_icon (AlmAppChooseInfo* self, GdkPixbuf* value) {
	GdkPixbuf* _tmp0_;
	GdkPixbuf* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->app_icon);
	self->priv->app_icon = _tmp1_;
}


const gchar* alm_app_choose_info_get_last_accessed (AlmAppChooseInfo* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->last_accessed_time_s;
	result = _tmp0_;
	return result;
}


void alm_app_choose_info_set_last_accessed (AlmAppChooseInfo* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->last_accessed_time_s);
	self->priv->last_accessed_time_s = _tmp1_;
}


gint64 alm_app_choose_info_get_last_accessed_time (AlmAppChooseInfo* self) {
	gint64 result;
	gint64 _tmp0_;
	g_return_val_if_fail (self != NULL, 0LL);
	_tmp0_ = self->priv->last_accessed_time_i;
	result = _tmp0_;
	return result;
}


void alm_app_choose_info_set_last_accessed_time (AlmAppChooseInfo* self, gint64 value) {
	gint64 _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->last_accessed_time_i = _tmp0_;
}


guint alm_app_choose_info_get_usage (AlmAppChooseInfo* self) {
	guint result;
	guint _tmp0_;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = self->priv->usage_rating;
	result = _tmp0_;
	return result;
}


void alm_app_choose_info_set_usage (AlmAppChooseInfo* self, guint value) {
	guint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->usage_rating = _tmp0_;
}


static void alm_value_app_choose_info_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void alm_value_app_choose_info_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		alm_app_choose_info_unref (value->data[0].v_pointer);
	}
}


static void alm_value_app_choose_info_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = alm_app_choose_info_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer alm_value_app_choose_info_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* alm_value_app_choose_info_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		AlmAppChooseInfo* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = alm_app_choose_info_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* alm_value_app_choose_info_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	AlmAppChooseInfo** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = alm_app_choose_info_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* alm_param_spec_app_choose_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	AlmParamSpecAppChooseInfo* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ALM_TYPE_APP_CHOOSE_INFO), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer alm_value_get_app_choose_info (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ALM_TYPE_APP_CHOOSE_INFO), NULL);
	return value->data[0].v_pointer;
}


void alm_value_set_app_choose_info (GValue* value, gpointer v_object) {
	AlmAppChooseInfo* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ALM_TYPE_APP_CHOOSE_INFO));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ALM_TYPE_APP_CHOOSE_INFO));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		alm_app_choose_info_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		alm_app_choose_info_unref (old);
	}
}


void alm_value_take_app_choose_info (GValue* value, gpointer v_object) {
	AlmAppChooseInfo* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ALM_TYPE_APP_CHOOSE_INFO));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ALM_TYPE_APP_CHOOSE_INFO));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		alm_app_choose_info_unref (old);
	}
}


static void alm_app_choose_info_class_init (AlmAppChooseInfoClass * klass) {
	alm_app_choose_info_parent_class = g_type_class_peek_parent (klass);
	ALM_APP_CHOOSE_INFO_CLASS (klass)->finalize = alm_app_choose_info_finalize;
	g_type_class_add_private (klass, sizeof (AlmAppChooseInfoPrivate));
}


static void alm_app_choose_info_instance_init (AlmAppChooseInfo * self) {
	self->priv = ALM_APP_CHOOSE_INFO_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void alm_app_choose_info_finalize (AlmAppChooseInfo* obj) {
	AlmAppChooseInfo * self;
	self = ALM_APP_CHOOSE_INFO (obj);
	_g_free0 (self->priv->app_id);
	_g_free0 (self->priv->app_name);
	_g_object_unref0 (self->priv->app_icon);
	_g_free0 (self->priv->last_accessed_time_s);
}


GType alm_app_choose_info_get_type (void) {
	static volatile gsize alm_app_choose_info_type_id__volatile = 0;
	if (g_once_init_enter (&alm_app_choose_info_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { alm_value_app_choose_info_init, alm_value_app_choose_info_free_value, alm_value_app_choose_info_copy_value, alm_value_app_choose_info_peek_pointer, "p", alm_value_app_choose_info_collect_value, "p", alm_value_app_choose_info_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (AlmAppChooseInfoClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) alm_app_choose_info_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AlmAppChooseInfo), 0, (GInstanceInitFunc) alm_app_choose_info_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType alm_app_choose_info_type_id;
		alm_app_choose_info_type_id = g_type_register_fundamental (g_type_fundamental_next (), "AlmAppChooseInfo", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&alm_app_choose_info_type_id__volatile, alm_app_choose_info_type_id);
	}
	return alm_app_choose_info_type_id__volatile;
}


gpointer alm_app_choose_info_ref (gpointer instance) {
	AlmAppChooseInfo* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void alm_app_choose_info_unref (gpointer instance) {
	AlmAppChooseInfo* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ALM_APP_CHOOSE_INFO_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



