/* blacklist-dbus.c generated by valac 0.14.2, the Vala compiler
 * generated from blacklist-dbus.vala, do not modify */

/* -*- Mode: vala; tab-width: 4; intend-tabs-mode: t -*- */
/* alm
 *
 * Copyright (C) 2012 Manish Sinha <manishsinha@ubuntu.com>
 * Copyright (C) 2011 Collabora Ltd.
 *             Authored by Siegfried-Angel Gevatter Pujals <siegfried@gevatter.com>
 *             Authored by Seif Lotfy <seif@lotfy.com>
 *
 * alm is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * alm is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.";
 */

#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <zeitgeist.h>
#include <gtk/gtk.h>
#include <gobject/gvaluecollector.h>


#define ALM_TYPE_BLACKLIST_INTERFACE (alm_blacklist_interface_get_type ())
#define ALM_BLACKLIST_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ALM_TYPE_BLACKLIST_INTERFACE, AlmBlacklistInterface))
#define ALM_IS_BLACKLIST_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ALM_TYPE_BLACKLIST_INTERFACE))
#define ALM_BLACKLIST_INTERFACE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), ALM_TYPE_BLACKLIST_INTERFACE, AlmBlacklistInterfaceIface))

typedef struct _AlmBlacklistInterface AlmBlacklistInterface;
typedef struct _AlmBlacklistInterfaceIface AlmBlacklistInterfaceIface;

#define ALM_TYPE_BLACKLIST_INTERFACE_PROXY (alm_blacklist_interface_proxy_get_type ())
typedef GDBusProxy AlmBlacklistInterfaceProxy;
typedef GDBusProxyClass AlmBlacklistInterfaceProxyClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))

#define ALM_TYPE_BLACKLIST (alm_blacklist_get_type ())
#define ALM_BLACKLIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ALM_TYPE_BLACKLIST, AlmBlacklist))
#define ALM_BLACKLIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ALM_TYPE_BLACKLIST, AlmBlacklistClass))
#define ALM_IS_BLACKLIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ALM_TYPE_BLACKLIST))
#define ALM_IS_BLACKLIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ALM_TYPE_BLACKLIST))
#define ALM_BLACKLIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ALM_TYPE_BLACKLIST, AlmBlacklistClass))

typedef struct _AlmBlacklist AlmBlacklist;
typedef struct _AlmBlacklistClass AlmBlacklistClass;
typedef struct _AlmBlacklistPrivate AlmBlacklistPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define _alm_blacklist_unref0(var) ((var == NULL) ? NULL : (var = (alm_blacklist_unref (var), NULL)))
#define _g_ptr_array_unref0(var) ((var == NULL) ? NULL : (var = (g_ptr_array_unref (var), NULL)))
#define _g_array_unref0(var) ((var == NULL) ? NULL : (var = (g_array_unref (var), NULL)))
typedef struct _AlmBlacklistFindEventsData AlmBlacklistFindEventsData;

#define ALM_TYPE_APPLICATIONS_CHOOSER_DIALOG (alm_applications_chooser_dialog_get_type ())
#define ALM_APPLICATIONS_CHOOSER_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ALM_TYPE_APPLICATIONS_CHOOSER_DIALOG, AlmApplicationsChooserDialog))
#define ALM_APPLICATIONS_CHOOSER_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ALM_TYPE_APPLICATIONS_CHOOSER_DIALOG, AlmApplicationsChooserDialogClass))
#define ALM_IS_APPLICATIONS_CHOOSER_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ALM_TYPE_APPLICATIONS_CHOOSER_DIALOG))
#define ALM_IS_APPLICATIONS_CHOOSER_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ALM_TYPE_APPLICATIONS_CHOOSER_DIALOG))
#define ALM_APPLICATIONS_CHOOSER_DIALOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ALM_TYPE_APPLICATIONS_CHOOSER_DIALOG, AlmApplicationsChooserDialogClass))

typedef struct _AlmApplicationsChooserDialog AlmApplicationsChooserDialog;
typedef struct _AlmApplicationsChooserDialogClass AlmApplicationsChooserDialogClass;
typedef struct _AlmBlacklistFindAllAppsData AlmBlacklistFindAllAppsData;
typedef struct _AlmParamSpecBlacklist AlmParamSpecBlacklist;

#define ALM_TYPE_UTILITIES (alm_utilities_get_type ())
#define ALM_UTILITIES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ALM_TYPE_UTILITIES, AlmUtilities))
#define ALM_UTILITIES_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ALM_TYPE_UTILITIES, AlmUtilitiesClass))
#define ALM_IS_UTILITIES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ALM_TYPE_UTILITIES))
#define ALM_IS_UTILITIES_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ALM_TYPE_UTILITIES))
#define ALM_UTILITIES_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ALM_TYPE_UTILITIES, AlmUtilitiesClass))

typedef struct _AlmUtilities AlmUtilities;
typedef struct _AlmUtilitiesClass AlmUtilitiesClass;
typedef struct _AlmUtilitiesPrivate AlmUtilitiesPrivate;
#define _g_variant_iter_free0(var) ((var == NULL) ? NULL : (var = (g_variant_iter_free (var), NULL)))
#define _g_variant_type_free0(var) ((var == NULL) ? NULL : (var = (g_variant_type_free (var), NULL)))
#define _g_variant_builder_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_builder_unref (var), NULL)))
typedef struct _AlmParamSpecUtilities AlmParamSpecUtilities;

struct _AlmBlacklistInterfaceIface {
	GTypeInterface parent_iface;
	void (*add_template) (AlmBlacklistInterface* self, const gchar* blacklist_id, GVariant* blacklist_template, GError** error);
	GVariant* (*get_templates) (AlmBlacklistInterface* self, GError** error);
	void (*remove_template) (AlmBlacklistInterface* self, const gchar* blacklist_id, GError** error);
};

typedef void (*AlmProcessFetchedEventsHandler) (GList* evs, void* user_data);
struct _AlmBlacklist {
	GTypeInstance parent_instance;
	volatile int ref_count;
	AlmBlacklistPrivate * priv;
};

struct _AlmBlacklistClass {
	GTypeClass parent_class;
	void (*finalize) (AlmBlacklist *self);
};

struct _AlmBlacklistPrivate {
	AlmBlacklistInterface* blacklist;
	GHashTable* blacklists;
	ZeitgeistLog* log;
	gchar* incognito_id;
	ZeitgeistEvent* incognito_event;
};

struct _AlmBlacklistFindEventsData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	AlmBlacklist* self;
	gchar* id;
	GtkTreeIter iter;
	GtkListStore* store;
	ZeitgeistEvent* _tmp0_;
	ZeitgeistEvent* _tmp1_;
	ZeitgeistEvent* event;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	GPtrArray* _tmp5_;
	GPtrArray* events;
	GPtrArray* _tmp6_;
	GObject* _tmp7_;
	ZeitgeistEvent* _tmp8_;
	ZeitgeistEvent* _tmp9_;
	ZeitgeistEvent* event2;
	ZeitgeistSubject* _tmp10_;
	ZeitgeistSubject* _tmp11_;
	ZeitgeistSubject* subj;
	const gchar* _tmp12_;
	gchar* _tmp13_;
	gchar* _tmp14_;
	GPtrArray* _tmp15_;
	GObject* _tmp16_;
	ZeitgeistLog* _tmp17_;
	ZeitgeistTimeRange* _tmp18_;
	ZeitgeistTimeRange* _tmp19_;
	GPtrArray* _tmp20_;
	GArray* _tmp21_;
	GArray* _tmp22_;
	GArray* results;
	guint _tmp23_;
	guint counter;
	GtkListStore* _tmp24_;
	GtkTreeIter _tmp25_;
	guint _tmp26_;
	GValue _tmp27_;
	GError * _inner_error_;
};

struct _AlmBlacklistFindAllAppsData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	AlmBlacklist* self;
	AlmApplicationsChooserDialog* dialog;
	ZeitgeistEvent* _tmp0_;
	ZeitgeistEvent* _tmp1_;
	ZeitgeistEvent* event;
	GPtrArray* _tmp2_;
	GPtrArray* events;
	GPtrArray* _tmp3_;
	GObject* _tmp4_;
	ZeitgeistEvent* _tmp5_;
	ZeitgeistEvent* _tmp6_;
	ZeitgeistEvent* event2;
	ZeitgeistSubject* _tmp7_;
	ZeitgeistSubject* _tmp8_;
	ZeitgeistSubject* subj;
	GPtrArray* _tmp9_;
	GObject* _tmp10_;
	GPtrArray* _tmp11_;
	ZeitgeistLog* _tmp12_;
	ZeitgeistTimeRange* _tmp13_;
	ZeitgeistTimeRange* _tmp14_;
	GPtrArray* _tmp15_;
	ZeitgeistResultSet* _tmp16_;
	ZeitgeistResultSet* _tmp17_;
	ZeitgeistResultSet* results;
	GHashFunc _tmp18_;
	GEqualFunc _tmp19_;
	GHashTable* _tmp20_;
	GHashTable* all_actors;
	gint i;
	gboolean _tmp21_;
	gboolean _tmp22_;
	gint _tmp23_;
	gint _tmp24_;
	guint _tmp25_;
	ZeitgeistEvent* _tmp26_;
	ZeitgeistEvent* _tmp27_;
	ZeitgeistEvent* ev;
	ZeitgeistEvent* _tmp28_;
	ZeitgeistEvent* _tmp29_;
	const gchar* _tmp30_;
	gchar* _tmp31_;
	gchar* actor;
	gboolean _tmp32_;
	const gchar* _tmp33_;
	const gchar* _tmp34_;
	gboolean _tmp35_;
	gboolean _tmp36_;
	GHashTable* _tmp37_;
	const gchar* _tmp38_;
	gchar* _tmp39_;
	ZeitgeistEvent* _tmp40_;
	gint64 _tmp41_;
	gint64* _tmp42_;
	AlmApplicationsChooserDialog* _tmp43_;
	GHashTable* _tmp44_;
	GError * _inner_error_;
};

struct _AlmParamSpecBlacklist {
	GParamSpec parent_instance;
};

struct _AlmUtilities {
	GTypeInstance parent_instance;
	volatile int ref_count;
	AlmUtilitiesPrivate * priv;
};

struct _AlmUtilitiesClass {
	GTypeClass parent_class;
	void (*finalize) (AlmUtilities *self);
};

struct _AlmParamSpecUtilities {
	GParamSpec parent_instance;
};


static gpointer alm_blacklist_parent_class = NULL;
static gpointer alm_utilities_parent_class = NULL;

GType alm_blacklist_interface_proxy_get_type (void) G_GNUC_CONST;
guint alm_blacklist_interface_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType alm_blacklist_interface_get_type (void) G_GNUC_CONST;
void alm_blacklist_interface_add_template (AlmBlacklistInterface* self, const gchar* blacklist_id, GVariant* blacklist_template, GError** error);
GVariant* alm_blacklist_interface_get_templates (AlmBlacklistInterface* self, GError** error);
void alm_blacklist_interface_remove_template (AlmBlacklistInterface* self, const gchar* blacklist_id, GError** error);
static void g_cclosure_user_marshal_VOID__STRING_VARIANT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void alm_blacklist_interface_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters);
static void _dbus_handle_alm_blacklist_interface_template_added (AlmBlacklistInterface* self, GVariant* parameters);
static void _dbus_handle_alm_blacklist_interface_template_removed (AlmBlacklistInterface* self, GVariant* parameters);
static void alm_blacklist_interface_proxy_add_template (AlmBlacklistInterface* self, const gchar* blacklist_id, GVariant* blacklist_template, GError** error);
static GVariant* alm_blacklist_interface_proxy_get_templates (AlmBlacklistInterface* self, GError** error);
static void alm_blacklist_interface_proxy_remove_template (AlmBlacklistInterface* self, const gchar* blacklist_id, GError** error);
static void alm_blacklist_interface_proxy_alm_blacklist_interface_interface_init (AlmBlacklistInterfaceIface* iface);
static void _dbus_alm_blacklist_interface_add_template (AlmBlacklistInterface* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_alm_blacklist_interface_get_templates (AlmBlacklistInterface* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_alm_blacklist_interface_remove_template (AlmBlacklistInterface* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void alm_blacklist_interface_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
static GVariant* alm_blacklist_interface_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
static gboolean alm_blacklist_interface_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
static void _dbus_alm_blacklist_interface_template_added (GObject* _sender, const gchar* blacklist_id, GVariant* blacklist_template, gpointer* _data);
static void _dbus_alm_blacklist_interface_template_removed (GObject* _sender, const gchar* blacklist_id, GVariant* blacklist_template, gpointer* _data);
static void _alm_blacklist_interface_unregister_object (gpointer user_data);
gpointer alm_blacklist_ref (gpointer instance);
void alm_blacklist_unref (gpointer instance);
GParamSpec* alm_param_spec_blacklist (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void alm_value_set_blacklist (GValue* value, gpointer v_object);
void alm_value_take_blacklist (GValue* value, gpointer v_object);
gpointer alm_value_get_blacklist (const GValue* value);
GType alm_blacklist_get_type (void) G_GNUC_CONST;
#define ALM_BLACKLIST_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ALM_TYPE_BLACKLIST, AlmBlacklistPrivate))
enum  {
	ALM_BLACKLIST_DUMMY_PROPERTY
};
AlmBlacklist* alm_blacklist_new (void);
AlmBlacklist* alm_blacklist_construct (GType object_type);
static void alm_blacklist_on_template_added (AlmBlacklist* self, const gchar* blacklist_id, GVariant* blacklist_template);
static void _alm_blacklist_on_template_added_alm_blacklist_interface_template_added (AlmBlacklistInterface* _sender, const gchar* blacklist_id, GVariant* blacklist_template, gpointer self);
static void alm_blacklist_on_template_removed (AlmBlacklist* self, const gchar* blacklist_id, GVariant* blacklist_template);
static void _alm_blacklist_on_template_removed_alm_blacklist_interface_template_removed (AlmBlacklistInterface* _sender, const gchar* blacklist_id, GVariant* blacklist_template, gpointer self);
void alm_blacklist_add_template (AlmBlacklist* self, const gchar* blacklist_id, ZeitgeistEvent* blacklist_template);
void alm_blacklist_remove_template (AlmBlacklist* self, const gchar* blacklist_id);
void alm_blacklist_set_incognito (AlmBlacklist* self, gboolean status);
GHashTable* alm_blacklist_get_templates (AlmBlacklist* self);
GHashTable* alm_utilities_from_variant (GVariant* templates_variant);
gboolean alm_blacklist_get_incognito (AlmBlacklist* self);
GHashTable* alm_blacklist_get_all_templates (AlmBlacklist* self);
gboolean alm_utilities_matches_event_template (ZeitgeistEvent* event, ZeitgeistEvent* template_event);
static void alm_blacklist_find_events_data_free (gpointer _data);
void alm_blacklist_find_events (AlmBlacklist* self, const gchar* id, GtkTreeIter* iter, GtkListStore* store, GAsyncReadyCallback _callback_, gpointer _user_data_);
void alm_blacklist_find_events_finish (AlmBlacklist* self, GAsyncResult* _res_);
static gboolean alm_blacklist_find_events_co (AlmBlacklistFindEventsData* _data_);
static void alm_blacklist_find_events_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
void alm_blacklist_get_count_for_app (AlmBlacklist* self, const gchar* app_id, GtkTreeIter* iter, GtkListStore* store);
static void alm_blacklist_find_all_apps_data_free (gpointer _data);
GType alm_applications_chooser_dialog_get_type (void) G_GNUC_CONST;
void alm_blacklist_find_all_apps (AlmBlacklist* self, AlmApplicationsChooserDialog* dialog, GAsyncReadyCallback _callback_, gpointer _user_data_);
void alm_blacklist_find_all_apps_finish (AlmBlacklist* self, GAsyncResult* _res_);
static gboolean alm_blacklist_find_all_apps_co (AlmBlacklistFindAllAppsData* _data_);
static void alm_blacklist_find_all_apps_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void _g_free0_ (gpointer var);
static gint64* _int64_dup (gint64* self);
void alm_applications_chooser_dialog_handle_app_population (AlmApplicationsChooserDialog* self, GHashTable* all_actors);
void alm_blacklist_get_all_applications (AlmBlacklist* self, AlmApplicationsChooserDialog* dialog);
static void g_cclosure_user_marshal_VOID__STRING_OBJECT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void alm_blacklist_finalize (AlmBlacklist* obj);
gpointer alm_utilities_ref (gpointer instance);
void alm_utilities_unref (gpointer instance);
GParamSpec* alm_param_spec_utilities (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void alm_value_set_utilities (GValue* value, gpointer v_object);
void alm_value_take_utilities (GValue* value, gpointer v_object);
gpointer alm_value_get_utilities (const GValue* value);
GType alm_utilities_get_type (void) G_GNUC_CONST;
enum  {
	ALM_UTILITIES_DUMMY_PROPERTY
};
#define ALM_UTILITIES_SIG_EVENT "asaasay"
#define ALM_UTILITIES_SIG_BLACKLIST "a{s(" ALM_UTILITIES_SIG_EVENT ")}"
static gboolean alm_utilities_check_field_match (const gchar* property, const gchar* template_property, const gchar* property_name);
gboolean alm_utilities_matches_subject_template (ZeitgeistSubject* subject, ZeitgeistSubject* template_subject);
gboolean alm_utilities_parse_negation (gchar** val);
static void _g_object_unref0_ (gpointer var);
GVariant* alm_utilities_to_variant (GHashTable* blacklist);
AlmUtilities* alm_utilities_new (void);
AlmUtilities* alm_utilities_construct (GType object_type);
static void alm_utilities_finalize (AlmUtilities* obj);

static const GDBusArgInfo _alm_blacklist_interface_dbus_arg_info_add_template_blacklist_id = {-1, "blacklist_id", "s"};
static const GDBusArgInfo _alm_blacklist_interface_dbus_arg_info_add_template_blacklist_template = {-1, "blacklist_template", "(asaasay)"};
static const GDBusArgInfo * const _alm_blacklist_interface_dbus_arg_info_add_template_in[] = {&_alm_blacklist_interface_dbus_arg_info_add_template_blacklist_id, &_alm_blacklist_interface_dbus_arg_info_add_template_blacklist_template, NULL};
static const GDBusArgInfo * const _alm_blacklist_interface_dbus_arg_info_add_template_out[] = {NULL};
static const GDBusMethodInfo _alm_blacklist_interface_dbus_method_info_add_template = {-1, "AddTemplate", (GDBusArgInfo **) (&_alm_blacklist_interface_dbus_arg_info_add_template_in), (GDBusArgInfo **) (&_alm_blacklist_interface_dbus_arg_info_add_template_out)};
static const GDBusArgInfo _alm_blacklist_interface_dbus_arg_info_get_templates_result = {-1, "result", "a{s(asaasay)}"};
static const GDBusArgInfo * const _alm_blacklist_interface_dbus_arg_info_get_templates_in[] = {NULL};
static const GDBusArgInfo * const _alm_blacklist_interface_dbus_arg_info_get_templates_out[] = {&_alm_blacklist_interface_dbus_arg_info_get_templates_result, NULL};
static const GDBusMethodInfo _alm_blacklist_interface_dbus_method_info_get_templates = {-1, "GetTemplates", (GDBusArgInfo **) (&_alm_blacklist_interface_dbus_arg_info_get_templates_in), (GDBusArgInfo **) (&_alm_blacklist_interface_dbus_arg_info_get_templates_out)};
static const GDBusArgInfo _alm_blacklist_interface_dbus_arg_info_remove_template_blacklist_id = {-1, "blacklist_id", "s"};
static const GDBusArgInfo * const _alm_blacklist_interface_dbus_arg_info_remove_template_in[] = {&_alm_blacklist_interface_dbus_arg_info_remove_template_blacklist_id, NULL};
static const GDBusArgInfo * const _alm_blacklist_interface_dbus_arg_info_remove_template_out[] = {NULL};
static const GDBusMethodInfo _alm_blacklist_interface_dbus_method_info_remove_template = {-1, "RemoveTemplate", (GDBusArgInfo **) (&_alm_blacklist_interface_dbus_arg_info_remove_template_in), (GDBusArgInfo **) (&_alm_blacklist_interface_dbus_arg_info_remove_template_out)};
static const GDBusMethodInfo * const _alm_blacklist_interface_dbus_method_info[] = {&_alm_blacklist_interface_dbus_method_info_add_template, &_alm_blacklist_interface_dbus_method_info_get_templates, &_alm_blacklist_interface_dbus_method_info_remove_template, NULL};
static const GDBusArgInfo _alm_blacklist_interface_dbus_arg_info_template_added_blacklist_id = {-1, "blacklist_id", "s"};
static const GDBusArgInfo _alm_blacklist_interface_dbus_arg_info_template_added_blacklist_template = {-1, "blacklist_template", "s(asaasay)"};
static const GDBusArgInfo * const _alm_blacklist_interface_dbus_arg_info_template_added[] = {&_alm_blacklist_interface_dbus_arg_info_template_added_blacklist_id, &_alm_blacklist_interface_dbus_arg_info_template_added_blacklist_template, NULL};
static const GDBusSignalInfo _alm_blacklist_interface_dbus_signal_info_template_added = {-1, "TemplateAdded", (GDBusArgInfo **) (&_alm_blacklist_interface_dbus_arg_info_template_added)};
static const GDBusArgInfo _alm_blacklist_interface_dbus_arg_info_template_removed_blacklist_id = {-1, "blacklist_id", "s"};
static const GDBusArgInfo _alm_blacklist_interface_dbus_arg_info_template_removed_blacklist_template = {-1, "blacklist_template", "s(asaasay)"};
static const GDBusArgInfo * const _alm_blacklist_interface_dbus_arg_info_template_removed[] = {&_alm_blacklist_interface_dbus_arg_info_template_removed_blacklist_id, &_alm_blacklist_interface_dbus_arg_info_template_removed_blacklist_template, NULL};
static const GDBusSignalInfo _alm_blacklist_interface_dbus_signal_info_template_removed = {-1, "TemplateRemoved", (GDBusArgInfo **) (&_alm_blacklist_interface_dbus_arg_info_template_removed)};
static const GDBusSignalInfo * const _alm_blacklist_interface_dbus_signal_info[] = {&_alm_blacklist_interface_dbus_signal_info_template_added, &_alm_blacklist_interface_dbus_signal_info_template_removed, NULL};
static const GDBusPropertyInfo * const _alm_blacklist_interface_dbus_property_info[] = {NULL};
static const GDBusInterfaceInfo _alm_blacklist_interface_dbus_interface_info = {-1, "org.gnome.zeitgeist.Blacklist", (GDBusMethodInfo **) (&_alm_blacklist_interface_dbus_method_info), (GDBusSignalInfo **) (&_alm_blacklist_interface_dbus_signal_info), (GDBusPropertyInfo **) (&_alm_blacklist_interface_dbus_property_info)};
static const GDBusInterfaceVTable _alm_blacklist_interface_dbus_interface_vtable = {alm_blacklist_interface_dbus_interface_method_call, alm_blacklist_interface_dbus_interface_get_property, alm_blacklist_interface_dbus_interface_set_property};

void alm_blacklist_interface_add_template (AlmBlacklistInterface* self, const gchar* blacklist_id, GVariant* blacklist_template, GError** error) {
	g_return_if_fail (self != NULL);
	ALM_BLACKLIST_INTERFACE_GET_INTERFACE (self)->add_template (self, blacklist_id, blacklist_template, error);
}


GVariant* alm_blacklist_interface_get_templates (AlmBlacklistInterface* self, GError** error) {
	g_return_val_if_fail (self != NULL, NULL);
	return ALM_BLACKLIST_INTERFACE_GET_INTERFACE (self)->get_templates (self, error);
}


void alm_blacklist_interface_remove_template (AlmBlacklistInterface* self, const gchar* blacklist_id, GError** error) {
	g_return_if_fail (self != NULL);
	ALM_BLACKLIST_INTERFACE_GET_INTERFACE (self)->remove_template (self, blacklist_id, error);
}


static void g_cclosure_user_marshal_VOID__STRING_VARIANT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_VARIANT) (gpointer data1, const char* arg_1, gpointer arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_VARIANT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_VARIANT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_variant (param_values + 2), data2);
}


static void alm_blacklist_interface_base_init (AlmBlacklistInterfaceIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		g_signal_new ("template_added", ALM_TYPE_BLACKLIST_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_VARIANT, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_VARIANT);
		g_signal_new ("template_removed", ALM_TYPE_BLACKLIST_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_VARIANT, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_VARIANT);
	}
}


GType alm_blacklist_interface_get_type (void) {
	static volatile gsize alm_blacklist_interface_type_id__volatile = 0;
	if (g_once_init_enter (&alm_blacklist_interface_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AlmBlacklistInterfaceIface), (GBaseInitFunc) alm_blacklist_interface_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType alm_blacklist_interface_type_id;
		alm_blacklist_interface_type_id = g_type_register_static (G_TYPE_INTERFACE, "AlmBlacklistInterface", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (alm_blacklist_interface_type_id, G_TYPE_OBJECT);
		g_type_set_qdata (alm_blacklist_interface_type_id, g_quark_from_static_string ("vala-dbus-proxy-type"), (void*) alm_blacklist_interface_proxy_get_type);
		g_type_set_qdata (alm_blacklist_interface_type_id, g_quark_from_static_string ("vala-dbus-interface-name"), "org.gnome.zeitgeist.Blacklist");
		g_type_set_qdata (alm_blacklist_interface_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) alm_blacklist_interface_register_object);
		g_once_init_leave (&alm_blacklist_interface_type_id__volatile, alm_blacklist_interface_type_id);
	}
	return alm_blacklist_interface_type_id__volatile;
}


G_DEFINE_TYPE_EXTENDED (AlmBlacklistInterfaceProxy, alm_blacklist_interface_proxy, G_TYPE_DBUS_PROXY, 0, G_IMPLEMENT_INTERFACE (ALM_TYPE_BLACKLIST_INTERFACE, alm_blacklist_interface_proxy_alm_blacklist_interface_interface_init) )
static void alm_blacklist_interface_proxy_class_init (AlmBlacklistInterfaceProxyClass* klass) {
	G_DBUS_PROXY_CLASS (klass)->g_signal = alm_blacklist_interface_proxy_g_signal;
}


static void _dbus_handle_alm_blacklist_interface_template_added (AlmBlacklistInterface* self, GVariant* parameters) {
	GVariantIter _arguments_iter;
	gchar* blacklist_id = NULL;
	GVariant* _tmp0_;
	GVariant* blacklist_template = NULL;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp0_ = g_variant_iter_next_value (&_arguments_iter);
	blacklist_id = g_variant_dup_string (_tmp0_, NULL);
	g_variant_unref (_tmp0_);
	blacklist_template = g_variant_iter_next_value (&_arguments_iter);
	g_signal_emit_by_name (self, "template-added", blacklist_id, blacklist_template);
	_g_free0 (blacklist_id);
	_g_variant_unref0 (blacklist_template);
}


static void _dbus_handle_alm_blacklist_interface_template_removed (AlmBlacklistInterface* self, GVariant* parameters) {
	GVariantIter _arguments_iter;
	gchar* blacklist_id = NULL;
	GVariant* _tmp1_;
	GVariant* blacklist_template = NULL;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp1_ = g_variant_iter_next_value (&_arguments_iter);
	blacklist_id = g_variant_dup_string (_tmp1_, NULL);
	g_variant_unref (_tmp1_);
	blacklist_template = g_variant_iter_next_value (&_arguments_iter);
	g_signal_emit_by_name (self, "template-removed", blacklist_id, blacklist_template);
	_g_free0 (blacklist_id);
	_g_variant_unref0 (blacklist_template);
}


static void alm_blacklist_interface_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters) {
	if (strcmp (signal_name, "TemplateAdded") == 0) {
		_dbus_handle_alm_blacklist_interface_template_added ((AlmBlacklistInterface*) proxy, parameters);
	} else if (strcmp (signal_name, "TemplateRemoved") == 0) {
		_dbus_handle_alm_blacklist_interface_template_removed ((AlmBlacklistInterface*) proxy, parameters);
	}
}


static void alm_blacklist_interface_proxy_init (AlmBlacklistInterfaceProxy* self) {
}


static void alm_blacklist_interface_proxy_add_template (AlmBlacklistInterface* self, const gchar* blacklist_id, GVariant* blacklist_template, GError** error) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	GDBusMessage *_reply_message;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.gnome.zeitgeist.Blacklist", "AddTemplate");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (blacklist_id));
	g_variant_builder_add_value (&_arguments_builder, blacklist_template);
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	_reply_message = g_dbus_connection_send_message_with_reply_sync (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, error);
	g_object_unref (_message);
	if (!_reply_message) {
		return;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return;
	}
	g_object_unref (_reply_message);
}


static GVariant* alm_blacklist_interface_proxy_get_templates (AlmBlacklistInterface* self, GError** error) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	GDBusMessage *_reply_message;
	GVariant *_reply;
	GVariantIter _reply_iter;
	GVariant* _result;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.gnome.zeitgeist.Blacklist", "GetTemplates");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	_reply_message = g_dbus_connection_send_message_with_reply_sync (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, error);
	g_object_unref (_message);
	if (!_reply_message) {
		return NULL;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return NULL;
	}
	_reply = g_dbus_message_get_body (_reply_message);
	g_variant_iter_init (&_reply_iter, _reply);
	_result = g_variant_iter_next_value (&_reply_iter);
	g_object_unref (_reply_message);
	return _result;
}


static void alm_blacklist_interface_proxy_remove_template (AlmBlacklistInterface* self, const gchar* blacklist_id, GError** error) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	GDBusMessage *_reply_message;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.gnome.zeitgeist.Blacklist", "RemoveTemplate");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (blacklist_id));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	_reply_message = g_dbus_connection_send_message_with_reply_sync (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, error);
	g_object_unref (_message);
	if (!_reply_message) {
		return;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return;
	}
	g_object_unref (_reply_message);
}


static void alm_blacklist_interface_proxy_alm_blacklist_interface_interface_init (AlmBlacklistInterfaceIface* iface) {
	iface->add_template = alm_blacklist_interface_proxy_add_template;
	iface->get_templates = alm_blacklist_interface_proxy_get_templates;
	iface->remove_template = alm_blacklist_interface_proxy_remove_template;
}


static void _dbus_alm_blacklist_interface_add_template (AlmBlacklistInterface* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gchar* blacklist_id = NULL;
	GVariant* _tmp2_;
	GVariant* blacklist_template = NULL;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp2_ = g_variant_iter_next_value (&_arguments_iter);
	blacklist_id = g_variant_dup_string (_tmp2_, NULL);
	g_variant_unref (_tmp2_);
	blacklist_template = g_variant_iter_next_value (&_arguments_iter);
	alm_blacklist_interface_add_template (self, blacklist_id, blacklist_template, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	_g_free0 (blacklist_id);
	_g_variant_unref0 (blacklist_template);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_alm_blacklist_interface_get_templates (AlmBlacklistInterface* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	GVariant* result;
	g_variant_iter_init (&_arguments_iter, parameters);
	result = alm_blacklist_interface_get_templates (self, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, result);
	_g_variant_unref0 (result);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_alm_blacklist_interface_remove_template (AlmBlacklistInterface* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gchar* blacklist_id = NULL;
	GVariant* _tmp3_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp3_ = g_variant_iter_next_value (&_arguments_iter);
	blacklist_id = g_variant_dup_string (_tmp3_, NULL);
	g_variant_unref (_tmp3_);
	alm_blacklist_interface_remove_template (self, blacklist_id, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	_g_free0 (blacklist_id);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void alm_blacklist_interface_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	if (strcmp (method_name, "AddTemplate") == 0) {
		_dbus_alm_blacklist_interface_add_template (object, parameters, invocation);
	} else if (strcmp (method_name, "GetTemplates") == 0) {
		_dbus_alm_blacklist_interface_get_templates (object, parameters, invocation);
	} else if (strcmp (method_name, "RemoveTemplate") == 0) {
		_dbus_alm_blacklist_interface_remove_template (object, parameters, invocation);
	} else {
		g_object_unref (invocation);
	}
}


static GVariant* alm_blacklist_interface_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return NULL;
}


static gboolean alm_blacklist_interface_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return FALSE;
}


static void _dbus_alm_blacklist_interface_template_added (GObject* _sender, const gchar* blacklist_id, GVariant* blacklist_template, gpointer* _data) {
	GDBusConnection * _connection;
	const gchar * _path;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	_connection = _data[1];
	_path = _data[2];
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (blacklist_id));
	g_variant_builder_add_value (&_arguments_builder, blacklist_template);
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_connection_emit_signal (_connection, NULL, _path, "org.gnome.zeitgeist.Blacklist", "TemplateAdded", _arguments, NULL);
}


static void _dbus_alm_blacklist_interface_template_removed (GObject* _sender, const gchar* blacklist_id, GVariant* blacklist_template, gpointer* _data) {
	GDBusConnection * _connection;
	const gchar * _path;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	_connection = _data[1];
	_path = _data[2];
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (blacklist_id));
	g_variant_builder_add_value (&_arguments_builder, blacklist_template);
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_connection_emit_signal (_connection, NULL, _path, "org.gnome.zeitgeist.Blacklist", "TemplateRemoved", _arguments, NULL);
}


guint alm_blacklist_interface_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
	guint result;
	gpointer *data;
	data = g_new (gpointer, 3);
	data[0] = g_object_ref (object);
	data[1] = g_object_ref (connection);
	data[2] = g_strdup (path);
	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_alm_blacklist_interface_dbus_interface_info), &_alm_blacklist_interface_dbus_interface_vtable, data, _alm_blacklist_interface_unregister_object, error);
	if (!result) {
		return 0;
	}
	g_signal_connect (object, "template-added", (GCallback) _dbus_alm_blacklist_interface_template_added, data);
	g_signal_connect (object, "template-removed", (GCallback) _dbus_alm_blacklist_interface_template_removed, data);
	return result;
}


static void _alm_blacklist_interface_unregister_object (gpointer user_data) {
	gpointer* data;
	data = user_data;
	g_signal_handlers_disconnect_by_func (data[0], _dbus_alm_blacklist_interface_template_added, data);
	g_signal_handlers_disconnect_by_func (data[0], _dbus_alm_blacklist_interface_template_removed, data);
	g_object_unref (data[0]);
	g_object_unref (data[1]);
	g_free (data[2]);
	g_free (data);
}


static void _alm_blacklist_on_template_added_alm_blacklist_interface_template_added (AlmBlacklistInterface* _sender, const gchar* blacklist_id, GVariant* blacklist_template, gpointer self) {
	alm_blacklist_on_template_added (self, blacklist_id, blacklist_template);
}


static void _alm_blacklist_on_template_removed_alm_blacklist_interface_template_removed (AlmBlacklistInterface* _sender, const gchar* blacklist_id, GVariant* blacklist_template, gpointer self) {
	alm_blacklist_on_template_removed (self, blacklist_id, blacklist_template);
}


AlmBlacklist* alm_blacklist_construct (GType object_type) {
	AlmBlacklist* self = NULL;
	AlmBlacklistInterface* _tmp0_ = NULL;
	AlmBlacklistInterface* _tmp1_;
	AlmBlacklistInterface* _tmp2_;
	AlmBlacklistInterface* _tmp3_;
	ZeitgeistLog* _tmp4_;
	ZeitgeistEvent* _tmp5_;
	ZeitgeistEvent* _tmp6_;
	GError * _inner_error_ = NULL;
	self = (AlmBlacklist*) g_type_create_instance (object_type);
	_tmp0_ = g_initable_new (ALM_TYPE_BLACKLIST_INTERFACE_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", "org.gnome.zeitgeist.Engine", "g-bus-type", G_BUS_TYPE_SESSION, "g-object-path", "/org/gnome/zeitgeist/blacklist", "g-interface-name", "org.gnome.zeitgeist.Blacklist", NULL);
	_tmp1_ = (AlmBlacklistInterface*) _tmp0_;
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_g_object_unref0 (self->priv->blacklist);
	self->priv->blacklist = _tmp1_;
	_tmp2_ = self->priv->blacklist;
	g_signal_connect (_tmp2_, "template-added", (GCallback) _alm_blacklist_on_template_added_alm_blacklist_interface_template_added, self);
	_tmp3_ = self->priv->blacklist;
	g_signal_connect (_tmp3_, "template-removed", (GCallback) _alm_blacklist_on_template_removed_alm_blacklist_interface_template_removed, self);
	_tmp4_ = zeitgeist_log_new ();
	_g_object_unref0 (self->priv->log);
	self->priv->log = _tmp4_;
	_tmp5_ = zeitgeist_event_new ();
	_tmp6_ = g_object_ref_sink (_tmp5_);
	_g_object_unref0 (self->priv->incognito_event);
	self->priv->incognito_event = _tmp6_;
	return self;
}


AlmBlacklist* alm_blacklist_new (void) {
	return alm_blacklist_construct (ALM_TYPE_BLACKLIST);
}


void alm_blacklist_add_template (AlmBlacklist* self, const gchar* blacklist_id, ZeitgeistEvent* blacklist_template) {
	AlmBlacklistInterface* _tmp0_;
	const gchar* _tmp1_;
	ZeitgeistEvent* _tmp2_;
	GVariant* _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (blacklist_id != NULL);
	g_return_if_fail (blacklist_template != NULL);
	_tmp0_ = self->priv->blacklist;
	_tmp1_ = blacklist_id;
	_tmp2_ = blacklist_template;
	_tmp3_ = zeitgeist_event_to_variant (_tmp2_);
	alm_blacklist_interface_add_template (_tmp0_, _tmp1_, _tmp3_, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


void alm_blacklist_remove_template (AlmBlacklist* self, const gchar* blacklist_id) {
	AlmBlacklistInterface* _tmp0_;
	const gchar* _tmp1_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (blacklist_id != NULL);
	_tmp0_ = self->priv->blacklist;
	_tmp1_ = blacklist_id;
	alm_blacklist_interface_remove_template (_tmp0_, _tmp1_, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


void alm_blacklist_set_incognito (AlmBlacklist* self, gboolean status) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = status;
	if (_tmp0_) {
		const gchar* _tmp1_;
		ZeitgeistEvent* _tmp2_;
		_tmp1_ = self->priv->incognito_id;
		_tmp2_ = self->priv->incognito_event;
		alm_blacklist_add_template (self, _tmp1_, _tmp2_);
	} else {
		const gchar* _tmp3_;
		_tmp3_ = self->priv->incognito_id;
		alm_blacklist_remove_template (self, _tmp3_);
	}
}


static gpointer _g_hash_table_ref0 (gpointer self) {
	return self ? g_hash_table_ref (self) : NULL;
}


GHashTable* alm_blacklist_get_templates (AlmBlacklist* self) {
	GHashTable* result = NULL;
	AlmBlacklistInterface* _tmp0_;
	GVariant* _tmp1_ = NULL;
	GVariant* var_blacklists;
	GHashTable* _tmp2_ = NULL;
	GHashTable* _tmp3_;
	GHashTable* _tmp4_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->blacklist;
	_tmp1_ = alm_blacklist_interface_get_templates (_tmp0_, &_inner_error_);
	var_blacklists = _tmp1_;
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = alm_utilities_from_variant (var_blacklists);
	_g_hash_table_unref0 (self->priv->blacklists);
	self->priv->blacklists = _tmp2_;
	_tmp3_ = self->priv->blacklists;
	_tmp4_ = _g_hash_table_ref0 (_tmp3_);
	result = _tmp4_;
	_g_variant_unref0 (var_blacklists);
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void alm_blacklist_on_template_added (AlmBlacklist* self, const gchar* blacklist_id, GVariant* blacklist_template) {
	GVariant* _tmp0_;
	ZeitgeistEvent* _tmp1_;
	ZeitgeistEvent* _tmp2_;
	ZeitgeistEvent* ev;
	const gchar* _tmp3_;
	ZeitgeistEvent* _tmp4_;
	const gchar* _tmp5_;
	const gchar* _tmp6_;
	GHashTable* _tmp7_;
	const gchar* _tmp8_;
	gchar* _tmp9_;
	ZeitgeistEvent* _tmp10_;
	ZeitgeistEvent* _tmp11_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (blacklist_id != NULL);
	g_return_if_fail (blacklist_template != NULL);
	_tmp0_ = blacklist_template;
	_tmp1_ = zeitgeist_event_new_from_variant (_tmp0_);
	_tmp2_ = g_object_ref_sink (_tmp1_);
	ev = _tmp2_;
	_tmp3_ = blacklist_id;
	_tmp4_ = ev;
	g_signal_emit_by_name (self, "template-added", _tmp3_, _tmp4_);
	_tmp5_ = blacklist_id;
	_tmp6_ = self->priv->incognito_id;
	if (g_strcmp0 (_tmp5_, _tmp6_) == 0) {
		g_signal_emit_by_name (self, "incognito-toggled", TRUE);
	}
	_tmp7_ = self->priv->blacklists;
	_tmp8_ = blacklist_id;
	_tmp9_ = g_strdup (_tmp8_);
	_tmp10_ = ev;
	_tmp11_ = _g_object_ref0 (_tmp10_);
	g_hash_table_insert (_tmp7_, _tmp9_, _tmp11_);
	_g_object_unref0 (ev);
}


static void alm_blacklist_on_template_removed (AlmBlacklist* self, const gchar* blacklist_id, GVariant* blacklist_template) {
	GVariant* _tmp0_;
	ZeitgeistEvent* _tmp1_;
	ZeitgeistEvent* _tmp2_;
	ZeitgeistEvent* ev;
	const gchar* _tmp3_;
	ZeitgeistEvent* _tmp4_;
	const gchar* _tmp5_;
	const gchar* _tmp6_;
	GHashTable* _tmp7_;
	const gchar* _tmp8_;
	gconstpointer _tmp9_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (blacklist_id != NULL);
	g_return_if_fail (blacklist_template != NULL);
	_tmp0_ = blacklist_template;
	_tmp1_ = zeitgeist_event_new_from_variant (_tmp0_);
	_tmp2_ = g_object_ref_sink (_tmp1_);
	ev = _tmp2_;
	_tmp3_ = blacklist_id;
	_tmp4_ = ev;
	g_signal_emit_by_name (self, "template-removed", _tmp3_, _tmp4_);
	_tmp5_ = blacklist_id;
	_tmp6_ = self->priv->incognito_id;
	if (g_strcmp0 (_tmp5_, _tmp6_) == 0) {
		g_signal_emit_by_name (self, "incognito-toggled", FALSE);
	}
	_tmp7_ = self->priv->blacklists;
	_tmp8_ = blacklist_id;
	_tmp9_ = g_hash_table_lookup (_tmp7_, _tmp8_);
	if (((ZeitgeistEvent*) _tmp9_) != NULL) {
		GHashTable* _tmp10_;
		const gchar* _tmp11_;
		_tmp10_ = self->priv->blacklists;
		_tmp11_ = blacklist_id;
		g_hash_table_remove (_tmp10_, _tmp11_);
	}
	_g_object_unref0 (ev);
}


gboolean alm_blacklist_get_incognito (AlmBlacklist* self) {
	gboolean result = FALSE;
	GHashTable* _tmp0_;
	GHashTable* _tmp3_;
	GHashTable* _tmp4_;
	GList* _tmp5_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->blacklists;
	if (_tmp0_ == NULL) {
		GHashTable* _tmp1_ = NULL;
		GHashTable* _tmp2_;
		_tmp1_ = alm_blacklist_get_templates (self);
		_tmp2_ = _tmp1_;
		_g_hash_table_unref0 (_tmp2_);
	}
	_tmp3_ = alm_blacklist_get_all_templates (self);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_hash_table_get_values (_tmp4_);
	{
		GList* ev_collection = NULL;
		GList* ev_it = NULL;
		ev_collection = _tmp5_;
		for (ev_it = ev_collection; ev_it != NULL; ev_it = ev_it->next) {
			ZeitgeistEvent* _tmp6_;
			ZeitgeistEvent* ev = NULL;
			_tmp6_ = _g_object_ref0 ((ZeitgeistEvent*) ev_it->data);
			ev = _tmp6_;
			{
				ZeitgeistEvent* _tmp7_;
				ZeitgeistEvent* _tmp8_;
				gboolean _tmp9_ = FALSE;
				_tmp7_ = ev;
				_tmp8_ = self->priv->incognito_event;
				_tmp9_ = alm_utilities_matches_event_template (_tmp7_, _tmp8_);
				if (_tmp9_) {
					result = TRUE;
					_g_object_unref0 (ev);
					_g_list_free0 (ev_collection);
					return result;
				}
				_g_object_unref0 (ev);
			}
		}
		_g_list_free0 (ev_collection);
	}
	result = FALSE;
	return result;
}


static void alm_blacklist_find_events_data_free (gpointer _data) {
	AlmBlacklistFindEventsData* _data_;
	_data_ = _data;
	_g_free0 (_data_->id);
	_g_object_unref0 (_data_->store);
	_alm_blacklist_unref0 (_data_->self);
	g_slice_free (AlmBlacklistFindEventsData, _data_);
}


static gpointer _alm_blacklist_ref0 (gpointer self) {
	return self ? alm_blacklist_ref (self) : NULL;
}


void alm_blacklist_find_events (AlmBlacklist* self, const gchar* id, GtkTreeIter* iter, GtkListStore* store, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	AlmBlacklistFindEventsData* _data_;
	AlmBlacklist* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	GtkTreeIter _tmp3_;
	GtkListStore* _tmp4_;
	GtkListStore* _tmp5_;
	_data_ = g_slice_new0 (AlmBlacklistFindEventsData);
	_data_->_async_result = g_simple_async_result_new (NULL, _callback_, _user_data_, alm_blacklist_find_events);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, alm_blacklist_find_events_data_free);
	_tmp0_ = _alm_blacklist_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = id;
	_tmp2_ = g_strdup (_tmp1_);
	_data_->id = _tmp2_;
	_tmp3_ = *iter;
	_data_->iter = _tmp3_;
	_tmp4_ = store;
	_tmp5_ = _g_object_ref0 (_tmp4_);
	_data_->store = _tmp5_;
	alm_blacklist_find_events_co (_data_);
}


void alm_blacklist_find_events_finish (AlmBlacklist* self, GAsyncResult* _res_) {
	AlmBlacklistFindEventsData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void alm_blacklist_find_events_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	AlmBlacklistFindEventsData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	alm_blacklist_find_events_co (_data_);
}


static gboolean alm_blacklist_find_events_co (AlmBlacklistFindEventsData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = zeitgeist_event_new ();
	_data_->_tmp1_ = g_object_ref_sink (_data_->_tmp0_);
	_data_->event = _data_->_tmp1_;
	zeitgeist_event_set_manifestation (_data_->event, ZEITGEIST_ZG_USER_ACTIVITY);
	_data_->_tmp2_ = _data_->id;
	_data_->_tmp3_ = g_strconcat ("application://", _data_->_tmp2_, NULL);
	_data_->_tmp4_ = _data_->_tmp3_;
	zeitgeist_event_set_actor (_data_->event, _data_->_tmp4_);
	_g_free0 (_data_->_tmp4_);
	_data_->_tmp5_ = g_ptr_array_new ();
	_data_->events = _data_->_tmp5_;
	_data_->_tmp6_ = _data_->events;
	_data_->_tmp7_ = NULL;
	_data_->_tmp7_ = g_object_ref (G_IS_OBJECT (_data_->event) ? ((GObject*) _data_->event) : NULL);
	g_ptr_array_add (_data_->_tmp6_, _data_->_tmp7_);
	_data_->_tmp8_ = zeitgeist_event_new ();
	_data_->_tmp9_ = g_object_ref_sink (_data_->_tmp8_);
	_data_->event2 = _data_->_tmp9_;
	zeitgeist_event_set_manifestation (_data_->event2, ZEITGEIST_ZG_USER_ACTIVITY);
	_data_->_tmp10_ = zeitgeist_subject_new ();
	_data_->_tmp11_ = g_object_ref_sink (_data_->_tmp10_);
	_data_->subj = _data_->_tmp11_;
	_data_->_tmp12_ = _data_->id;
	_data_->_tmp13_ = g_strconcat ("application://", _data_->_tmp12_, NULL);
	_data_->_tmp14_ = _data_->_tmp13_;
	zeitgeist_subject_set_uri (_data_->subj, _data_->_tmp14_);
	_g_free0 (_data_->_tmp14_);
	zeitgeist_event_add_subject (_data_->event2, _data_->subj);
	_data_->_tmp15_ = _data_->events;
	_data_->_tmp16_ = NULL;
	_data_->_tmp16_ = g_object_ref (G_IS_OBJECT (_data_->event2) ? ((GObject*) _data_->event2) : NULL);
	g_ptr_array_add (_data_->_tmp15_, _data_->_tmp16_);
	_data_->_tmp17_ = _data_->self->priv->log;
	_data_->_tmp18_ = zeitgeist_time_range_new_anytime ();
	_data_->_tmp19_ = g_object_ref_sink (_data_->_tmp18_);
	_data_->_tmp20_ = _data_->events;
	_data_->events = NULL;
	_data_->_state_ = 1;
	zeitgeist_log_find_event_ids (_data_->_tmp17_, _data_->_tmp19_, _data_->_tmp20_, ZEITGEIST_STORAGE_STATE_ANY, (guint32) 0, ZEITGEIST_RESULT_TYPE_MOST_RECENT_EVENTS, NULL, alm_blacklist_find_events_ready, _data_);
	return FALSE;
	_state_1:
	_data_->_tmp21_ = NULL;
	_data_->_tmp21_ = zeitgeist_log_find_event_ids_finish (_data_->_tmp17_, _data_->_res_, &_data_->_inner_error_);
	_data_->_tmp22_ = _data_->_tmp21_;
	_g_object_unref0 (_data_->_tmp19_);
	_data_->results = _data_->_tmp22_;
	if (_data_->_inner_error_ != NULL) {
		_g_object_unref0 (_data_->subj);
		_g_object_unref0 (_data_->event2);
		_g_ptr_array_unref0 (_data_->events);
		_g_object_unref0 (_data_->event);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		return FALSE;
	}
	_data_->_tmp23_ = _data_->results->len;
	_data_->counter = _data_->_tmp23_ / 100;
	_data_->_tmp24_ = _data_->store;
	_data_->_tmp25_ = _data_->iter;
	_data_->_tmp26_ = _data_->counter;
	memset (&_data_->_tmp27_, 0, sizeof (GValue));
	g_value_init (&_data_->_tmp27_, G_TYPE_UINT);
	g_value_set_uint (&_data_->_tmp27_, _data_->_tmp26_);
	gtk_list_store_set_value (_data_->_tmp24_, &_data_->_tmp25_, 5, &_data_->_tmp27_);
	G_IS_VALUE (&_data_->_tmp27_) ? (g_value_unset (&_data_->_tmp27_), NULL) : NULL;
	_g_array_unref0 (_data_->results);
	_g_object_unref0 (_data_->subj);
	_g_object_unref0 (_data_->event2);
	_g_ptr_array_unref0 (_data_->events);
	_g_object_unref0 (_data_->event);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


void alm_blacklist_get_count_for_app (AlmBlacklist* self, const gchar* app_id, GtkTreeIter* iter, GtkListStore* store) {
	const gchar* _tmp0_;
	GtkTreeIter _tmp1_;
	GtkListStore* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (app_id != NULL);
	g_return_if_fail (iter != NULL);
	g_return_if_fail (store != NULL);
	_tmp0_ = app_id;
	_tmp1_ = *iter;
	_tmp2_ = store;
	alm_blacklist_find_events (self, _tmp0_, &_tmp1_, _tmp2_, NULL, NULL);
}


static void alm_blacklist_find_all_apps_data_free (gpointer _data) {
	AlmBlacklistFindAllAppsData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->dialog);
	_alm_blacklist_unref0 (_data_->self);
	g_slice_free (AlmBlacklistFindAllAppsData, _data_);
}


void alm_blacklist_find_all_apps (AlmBlacklist* self, AlmApplicationsChooserDialog* dialog, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	AlmBlacklistFindAllAppsData* _data_;
	AlmBlacklist* _tmp0_;
	AlmApplicationsChooserDialog* _tmp1_;
	AlmApplicationsChooserDialog* _tmp2_;
	_data_ = g_slice_new0 (AlmBlacklistFindAllAppsData);
	_data_->_async_result = g_simple_async_result_new (NULL, _callback_, _user_data_, alm_blacklist_find_all_apps);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, alm_blacklist_find_all_apps_data_free);
	_tmp0_ = _alm_blacklist_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = dialog;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_data_->dialog = _tmp2_;
	alm_blacklist_find_all_apps_co (_data_);
}


void alm_blacklist_find_all_apps_finish (AlmBlacklist* self, GAsyncResult* _res_) {
	AlmBlacklistFindAllAppsData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void alm_blacklist_find_all_apps_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	AlmBlacklistFindAllAppsData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	alm_blacklist_find_all_apps_co (_data_);
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* _tmp0_;
	glong _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* end;
	gchar* _tmp3_;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_;
	gboolean _tmp3_;
	glong _tmp9_;
	glong _tmp15_;
	glong _tmp18_;
	glong _tmp19_;
	glong _tmp20_;
	glong _tmp21_;
	glong _tmp22_;
	gchar* _tmp23_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		glong _tmp4_;
		glong _tmp5_;
		glong _tmp6_ = 0L;
		_tmp4_ = offset;
		_tmp5_ = len;
		_tmp6_ = string_strnlen ((gchar*) self, _tmp4_ + _tmp5_);
		string_length = _tmp6_;
	} else {
		gint _tmp7_;
		gint _tmp8_;
		_tmp7_ = strlen (self);
		_tmp8_ = _tmp7_;
		string_length = (glong) _tmp8_;
	}
	_tmp9_ = offset;
	if (_tmp9_ < ((glong) 0)) {
		glong _tmp10_;
		glong _tmp11_;
		glong _tmp12_;
		_tmp10_ = string_length;
		_tmp11_ = offset;
		offset = _tmp10_ + _tmp11_;
		_tmp12_ = offset;
		g_return_val_if_fail (_tmp12_ >= ((glong) 0), NULL);
	} else {
		glong _tmp13_;
		glong _tmp14_;
		_tmp13_ = offset;
		_tmp14_ = string_length;
		g_return_val_if_fail (_tmp13_ <= _tmp14_, NULL);
	}
	_tmp15_ = len;
	if (_tmp15_ < ((glong) 0)) {
		glong _tmp16_;
		glong _tmp17_;
		_tmp16_ = string_length;
		_tmp17_ = offset;
		len = _tmp16_ - _tmp17_;
	}
	_tmp18_ = offset;
	_tmp19_ = len;
	_tmp20_ = string_length;
	g_return_val_if_fail ((_tmp18_ + _tmp19_) <= _tmp20_, NULL);
	_tmp21_ = offset;
	_tmp22_ = len;
	_tmp23_ = g_strndup (((gchar*) self) + _tmp21_, (gsize) _tmp22_);
	result = _tmp23_;
	return result;
}


static gint64* _int64_dup (gint64* self) {
	gint64* dup;
	dup = g_new0 (gint64, 1);
	memcpy (dup, self, sizeof (gint64));
	return dup;
}


static gpointer __int64_dup0 (gpointer self) {
	return self ? _int64_dup (self) : NULL;
}


static gboolean alm_blacklist_find_all_apps_co (AlmBlacklistFindAllAppsData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = zeitgeist_event_new ();
	_data_->_tmp1_ = g_object_ref_sink (_data_->_tmp0_);
	_data_->event = _data_->_tmp1_;
	zeitgeist_event_set_manifestation (_data_->event, ZEITGEIST_ZG_USER_ACTIVITY);
	zeitgeist_event_set_actor (_data_->event, "application://*");
	_data_->_tmp2_ = g_ptr_array_new ();
	_data_->events = _data_->_tmp2_;
	_data_->_tmp3_ = _data_->events;
	_data_->_tmp4_ = NULL;
	_data_->_tmp4_ = g_object_ref (G_IS_OBJECT (_data_->event) ? ((GObject*) _data_->event) : NULL);
	g_ptr_array_add (_data_->_tmp3_, _data_->_tmp4_);
	_data_->_tmp5_ = zeitgeist_event_new ();
	_data_->_tmp6_ = g_object_ref_sink (_data_->_tmp5_);
	_data_->event2 = _data_->_tmp6_;
	zeitgeist_event_set_manifestation (_data_->event2, ZEITGEIST_ZG_USER_ACTIVITY);
	_data_->_tmp7_ = zeitgeist_subject_new ();
	_data_->_tmp8_ = g_object_ref_sink (_data_->_tmp7_);
	_data_->subj = _data_->_tmp8_;
	zeitgeist_subject_set_uri (_data_->subj, "application://*");
	zeitgeist_event_add_subject (_data_->event2, _data_->subj);
	_data_->_tmp9_ = _data_->events;
	_data_->_tmp10_ = NULL;
	_data_->_tmp10_ = g_object_ref (G_IS_OBJECT (_data_->event2) ? ((GObject*) _data_->event2) : NULL);
	g_ptr_array_add (_data_->_tmp9_, _data_->_tmp10_);
	_data_->_tmp11_ = g_ptr_array_new ();
	_g_ptr_array_unref0 (_data_->events);
	_data_->events = _data_->_tmp11_;
	_data_->_tmp12_ = _data_->self->priv->log;
	_data_->_tmp13_ = zeitgeist_time_range_new_anytime ();
	_data_->_tmp14_ = g_object_ref_sink (_data_->_tmp13_);
	_data_->_tmp15_ = _data_->events;
	_data_->events = NULL;
	_data_->_state_ = 1;
	zeitgeist_log_find_events (_data_->_tmp12_, _data_->_tmp14_, _data_->_tmp15_, ZEITGEIST_STORAGE_STATE_ANY, (guint32) 0, ZEITGEIST_RESULT_TYPE_MOST_POPULAR_ACTOR, NULL, alm_blacklist_find_all_apps_ready, _data_);
	return FALSE;
	_state_1:
	_data_->_tmp16_ = NULL;
	_data_->_tmp16_ = zeitgeist_log_find_events_finish (_data_->_tmp12_, _data_->_res_, &_data_->_inner_error_);
	_data_->_tmp17_ = _data_->_tmp16_;
	_g_object_unref0 (_data_->_tmp14_);
	_data_->results = _data_->_tmp17_;
	if (_data_->_inner_error_ != NULL) {
		_g_object_unref0 (_data_->subj);
		_g_object_unref0 (_data_->event2);
		_g_ptr_array_unref0 (_data_->events);
		_g_object_unref0 (_data_->event);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		return FALSE;
	}
	_data_->_tmp18_ = g_str_hash;
	_data_->_tmp19_ = g_str_equal;
	_data_->_tmp20_ = g_hash_table_new_full (_data_->_tmp18_, _data_->_tmp19_, _g_free0_, _g_free0_);
	_data_->all_actors = _data_->_tmp20_;
	{
		_data_->i = 0;
		{
			_data_->_tmp21_ = TRUE;
			while (TRUE) {
				_data_->_tmp22_ = _data_->_tmp21_;
				if (!_data_->_tmp22_) {
					_data_->_tmp23_ = _data_->i;
					_data_->i = _data_->_tmp23_ + 1;
				}
				_data_->_tmp21_ = FALSE;
				_data_->_tmp24_ = _data_->i;
				_data_->_tmp25_ = 0U;
				_data_->_tmp25_ = zeitgeist_result_set_size (_data_->results);
				if (!(((guint) _data_->_tmp24_) < _data_->_tmp25_)) {
					break;
				}
				_data_->_tmp26_ = NULL;
				_data_->_tmp26_ = zeitgeist_result_set_next (_data_->results);
				_data_->_tmp27_ = _g_object_ref0 (_data_->_tmp26_);
				_data_->ev = _data_->_tmp27_;
				_data_->_tmp28_ = _data_->ev;
				if (_data_->_tmp28_ != NULL) {
				}
				{
					_data_->_tmp29_ = _data_->ev;
					_data_->_tmp30_ = NULL;
					_data_->_tmp30_ = zeitgeist_event_get_actor (_data_->_tmp29_);
					_data_->_tmp31_ = g_strdup (_data_->_tmp30_);
					_data_->actor = _data_->_tmp31_;
					_data_->_tmp33_ = _data_->actor;
					if (_data_->_tmp33_ != NULL) {
						_data_->_tmp34_ = _data_->actor;
						_data_->_tmp35_ = FALSE;
						_data_->_tmp35_ = g_str_has_prefix (_data_->_tmp34_, "application://");
						_data_->_tmp32_ = _data_->_tmp35_;
					} else {
						_data_->_tmp32_ = FALSE;
					}
					_data_->_tmp36_ = _data_->_tmp32_;
					if (_data_->_tmp36_) {
						_data_->_tmp37_ = _data_->all_actors;
						_data_->_tmp38_ = _data_->actor;
						_data_->_tmp39_ = NULL;
						_data_->_tmp39_ = string_substring (_data_->_tmp38_, (glong) 14, (glong) (-1));
						_data_->_tmp40_ = _data_->ev;
						_data_->_tmp41_ = 0LL;
						_data_->_tmp41_ = zeitgeist_event_get_timestamp (_data_->_tmp40_);
						_data_->_tmp42_ = __int64_dup0 (&_data_->_tmp41_);
						g_hash_table_insert (_data_->_tmp37_, _data_->_tmp39_, _data_->_tmp42_);
					}
					_g_free0 (_data_->actor);
				}
				_g_object_unref0 (_data_->ev);
			}
		}
	}
	_data_->_tmp43_ = _data_->dialog;
	_data_->_tmp44_ = _data_->all_actors;
	alm_applications_chooser_dialog_handle_app_population (_data_->_tmp43_, _data_->_tmp44_);
	_g_hash_table_unref0 (_data_->all_actors);
	_g_object_unref0 (_data_->results);
	_g_object_unref0 (_data_->subj);
	_g_object_unref0 (_data_->event2);
	_g_ptr_array_unref0 (_data_->events);
	_g_object_unref0 (_data_->event);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


void alm_blacklist_get_all_applications (AlmBlacklist* self, AlmApplicationsChooserDialog* dialog) {
	AlmApplicationsChooserDialog* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dialog != NULL);
	_tmp0_ = dialog;
	alm_blacklist_find_all_apps (self, _tmp0_, NULL, NULL);
}


GHashTable* alm_blacklist_get_all_templates (AlmBlacklist* self) {
	GHashTable* result;
	GHashTable* _tmp0_;
	GHashTable* _tmp3_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->blacklists;
	if (_tmp0_ == NULL) {
		GHashTable* _tmp1_ = NULL;
		GHashTable* _tmp2_;
		_tmp1_ = alm_blacklist_get_templates (self);
		_tmp2_ = _tmp1_;
		_g_hash_table_unref0 (_tmp2_);
	}
	_tmp3_ = self->priv->blacklists;
	result = _tmp3_;
	return result;
}


static void g_cclosure_user_marshal_VOID__STRING_OBJECT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_OBJECT) (gpointer data1, const char* arg_1, gpointer arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_OBJECT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_OBJECT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_object (param_values + 2), data2);
}


static void alm_value_blacklist_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void alm_value_blacklist_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		alm_blacklist_unref (value->data[0].v_pointer);
	}
}


static void alm_value_blacklist_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = alm_blacklist_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer alm_value_blacklist_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* alm_value_blacklist_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		AlmBlacklist* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = alm_blacklist_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* alm_value_blacklist_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	AlmBlacklist** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = alm_blacklist_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* alm_param_spec_blacklist (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	AlmParamSpecBlacklist* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ALM_TYPE_BLACKLIST), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer alm_value_get_blacklist (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ALM_TYPE_BLACKLIST), NULL);
	return value->data[0].v_pointer;
}


void alm_value_set_blacklist (GValue* value, gpointer v_object) {
	AlmBlacklist* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ALM_TYPE_BLACKLIST));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ALM_TYPE_BLACKLIST));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		alm_blacklist_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		alm_blacklist_unref (old);
	}
}


void alm_value_take_blacklist (GValue* value, gpointer v_object) {
	AlmBlacklist* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ALM_TYPE_BLACKLIST));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ALM_TYPE_BLACKLIST));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		alm_blacklist_unref (old);
	}
}


static void alm_blacklist_class_init (AlmBlacklistClass * klass) {
	alm_blacklist_parent_class = g_type_class_peek_parent (klass);
	ALM_BLACKLIST_CLASS (klass)->finalize = alm_blacklist_finalize;
	g_type_class_add_private (klass, sizeof (AlmBlacklistPrivate));
	g_signal_new ("template_added", ALM_TYPE_BLACKLIST, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_OBJECT, G_TYPE_NONE, 2, G_TYPE_STRING, ZEITGEIST_TYPE_EVENT);
	g_signal_new ("template_removed", ALM_TYPE_BLACKLIST, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_OBJECT, G_TYPE_NONE, 2, G_TYPE_STRING, ZEITGEIST_TYPE_EVENT);
	g_signal_new ("incognito_toggled", ALM_TYPE_BLACKLIST, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__BOOLEAN, G_TYPE_NONE, 1, G_TYPE_BOOLEAN);
}


static void alm_blacklist_instance_init (AlmBlacklist * self) {
	gchar* _tmp0_;
	self->priv = ALM_BLACKLIST_GET_PRIVATE (self);
	_tmp0_ = g_strdup ("block-all");
	self->priv->incognito_id = _tmp0_;
	self->ref_count = 1;
}


static void alm_blacklist_finalize (AlmBlacklist* obj) {
	AlmBlacklist * self;
	self = ALM_BLACKLIST (obj);
	_g_object_unref0 (self->priv->blacklist);
	_g_hash_table_unref0 (self->priv->blacklists);
	_g_object_unref0 (self->priv->log);
	_g_free0 (self->priv->incognito_id);
	_g_object_unref0 (self->priv->incognito_event);
}


GType alm_blacklist_get_type (void) {
	static volatile gsize alm_blacklist_type_id__volatile = 0;
	if (g_once_init_enter (&alm_blacklist_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { alm_value_blacklist_init, alm_value_blacklist_free_value, alm_value_blacklist_copy_value, alm_value_blacklist_peek_pointer, "p", alm_value_blacklist_collect_value, "p", alm_value_blacklist_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (AlmBlacklistClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) alm_blacklist_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AlmBlacklist), 0, (GInstanceInitFunc) alm_blacklist_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType alm_blacklist_type_id;
		alm_blacklist_type_id = g_type_register_fundamental (g_type_fundamental_next (), "AlmBlacklist", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&alm_blacklist_type_id__volatile, alm_blacklist_type_id);
	}
	return alm_blacklist_type_id__volatile;
}


gpointer alm_blacklist_ref (gpointer instance) {
	AlmBlacklist* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void alm_blacklist_unref (gpointer instance) {
	AlmBlacklist* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ALM_BLACKLIST_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


gboolean alm_utilities_matches_event_template (ZeitgeistEvent* event, ZeitgeistEvent* template_event) {
	gboolean result = FALSE;
	ZeitgeistEvent* _tmp0_;
	const gchar* _tmp1_ = NULL;
	ZeitgeistEvent* _tmp2_;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	ZeitgeistEvent* _tmp5_;
	const gchar* _tmp6_ = NULL;
	ZeitgeistEvent* _tmp7_;
	const gchar* _tmp8_ = NULL;
	gboolean _tmp9_ = FALSE;
	ZeitgeistEvent* _tmp10_;
	const gchar* _tmp11_ = NULL;
	ZeitgeistEvent* _tmp12_;
	const gchar* _tmp13_ = NULL;
	gboolean _tmp14_ = FALSE;
	ZeitgeistEvent* _tmp15_;
	gint _tmp16_ = 0;
	g_return_val_if_fail (event != NULL, FALSE);
	g_return_val_if_fail (template_event != NULL, FALSE);
	_tmp0_ = event;
	_tmp1_ = zeitgeist_event_get_interpretation (_tmp0_);
	_tmp2_ = template_event;
	_tmp3_ = zeitgeist_event_get_interpretation (_tmp2_);
	_tmp4_ = alm_utilities_check_field_match (_tmp1_, _tmp3_, "ev-int");
	if (!_tmp4_) {
		result = FALSE;
		return result;
	}
	_tmp5_ = event;
	_tmp6_ = zeitgeist_event_get_manifestation (_tmp5_);
	_tmp7_ = template_event;
	_tmp8_ = zeitgeist_event_get_manifestation (_tmp7_);
	_tmp9_ = alm_utilities_check_field_match (_tmp6_, _tmp8_, "ev-mani");
	if (!_tmp9_) {
		result = FALSE;
		return result;
	}
	_tmp10_ = event;
	_tmp11_ = zeitgeist_event_get_actor (_tmp10_);
	_tmp12_ = template_event;
	_tmp13_ = zeitgeist_event_get_actor (_tmp12_);
	_tmp14_ = alm_utilities_check_field_match (_tmp11_, _tmp13_, "ev-actor");
	if (!_tmp14_) {
		result = FALSE;
		return result;
	}
	_tmp15_ = event;
	_tmp16_ = zeitgeist_event_num_subjects (_tmp15_);
	if (_tmp16_ == 0) {
		result = TRUE;
		return result;
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp17_;
			_tmp17_ = TRUE;
			while (TRUE) {
				gboolean _tmp18_;
				gint _tmp20_;
				ZeitgeistEvent* _tmp21_;
				gint _tmp22_ = 0;
				_tmp18_ = _tmp17_;
				if (!_tmp18_) {
					gint _tmp19_;
					_tmp19_ = i;
					i = _tmp19_ + 1;
				}
				_tmp17_ = FALSE;
				_tmp20_ = i;
				_tmp21_ = event;
				_tmp22_ = zeitgeist_event_num_subjects (_tmp21_);
				if (!(_tmp20_ < _tmp22_)) {
					break;
				}
				{
					gint j;
					j = 0;
					{
						gboolean _tmp23_;
						_tmp23_ = TRUE;
						while (TRUE) {
							gboolean _tmp24_;
							gint _tmp26_;
							ZeitgeistEvent* _tmp27_;
							gint _tmp28_ = 0;
							ZeitgeistEvent* _tmp29_;
							gint _tmp30_;
							ZeitgeistSubject* _tmp31_ = NULL;
							ZeitgeistEvent* _tmp32_;
							gint _tmp33_;
							ZeitgeistSubject* _tmp34_ = NULL;
							gboolean _tmp35_ = FALSE;
							_tmp24_ = _tmp23_;
							if (!_tmp24_) {
								gint _tmp25_;
								_tmp25_ = j;
								j = _tmp25_ + 1;
							}
							_tmp23_ = FALSE;
							_tmp26_ = j;
							_tmp27_ = template_event;
							_tmp28_ = zeitgeist_event_num_subjects (_tmp27_);
							if (!(_tmp26_ < _tmp28_)) {
								break;
							}
							_tmp29_ = event;
							_tmp30_ = i;
							_tmp31_ = zeitgeist_event_get_subject (_tmp29_, _tmp30_);
							_tmp32_ = template_event;
							_tmp33_ = j;
							_tmp34_ = zeitgeist_event_get_subject (_tmp32_, _tmp33_);
							_tmp35_ = alm_utilities_matches_subject_template (_tmp31_, _tmp34_);
							if (_tmp35_) {
								result = TRUE;
								return result;
							}
						}
					}
				}
			}
		}
	}
	result = FALSE;
	return result;
}


gboolean alm_utilities_matches_subject_template (ZeitgeistSubject* subject, ZeitgeistSubject* template_subject) {
	gboolean result = FALSE;
	ZeitgeistSubject* _tmp0_;
	const gchar* _tmp1_ = NULL;
	ZeitgeistSubject* _tmp2_;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	ZeitgeistSubject* _tmp5_;
	const gchar* _tmp6_ = NULL;
	ZeitgeistSubject* _tmp7_;
	const gchar* _tmp8_ = NULL;
	gboolean _tmp9_ = FALSE;
	ZeitgeistSubject* _tmp10_;
	const gchar* _tmp11_ = NULL;
	ZeitgeistSubject* _tmp12_;
	const gchar* _tmp13_ = NULL;
	gboolean _tmp14_ = FALSE;
	ZeitgeistSubject* _tmp15_;
	const gchar* _tmp16_ = NULL;
	ZeitgeistSubject* _tmp17_;
	const gchar* _tmp18_ = NULL;
	gboolean _tmp19_ = FALSE;
	ZeitgeistSubject* _tmp20_;
	const gchar* _tmp21_ = NULL;
	ZeitgeistSubject* _tmp22_;
	const gchar* _tmp23_ = NULL;
	gboolean _tmp24_ = FALSE;
	g_return_val_if_fail (subject != NULL, FALSE);
	g_return_val_if_fail (template_subject != NULL, FALSE);
	_tmp0_ = subject;
	_tmp1_ = zeitgeist_subject_get_uri (_tmp0_);
	_tmp2_ = template_subject;
	_tmp3_ = zeitgeist_subject_get_uri (_tmp2_);
	_tmp4_ = alm_utilities_check_field_match (_tmp1_, _tmp3_, "sub-uri");
	if (!_tmp4_) {
		result = FALSE;
		return result;
	}
	_tmp5_ = subject;
	_tmp6_ = zeitgeist_subject_get_interpretation (_tmp5_);
	_tmp7_ = template_subject;
	_tmp8_ = zeitgeist_subject_get_interpretation (_tmp7_);
	_tmp9_ = alm_utilities_check_field_match (_tmp6_, _tmp8_, "sub-int");
	if (!_tmp9_) {
		result = FALSE;
		return result;
	}
	_tmp10_ = subject;
	_tmp11_ = zeitgeist_subject_get_manifestation (_tmp10_);
	_tmp12_ = template_subject;
	_tmp13_ = zeitgeist_subject_get_manifestation (_tmp12_);
	_tmp14_ = alm_utilities_check_field_match (_tmp11_, _tmp13_, "sub-mani");
	if (!_tmp14_) {
		result = FALSE;
		return result;
	}
	_tmp15_ = subject;
	_tmp16_ = zeitgeist_subject_get_origin (_tmp15_);
	_tmp17_ = template_subject;
	_tmp18_ = zeitgeist_subject_get_origin (_tmp17_);
	_tmp19_ = alm_utilities_check_field_match (_tmp16_, _tmp18_, "sub-origin");
	if (!_tmp19_) {
		result = FALSE;
		return result;
	}
	_tmp20_ = subject;
	_tmp21_ = zeitgeist_subject_get_mimetype (_tmp20_);
	_tmp22_ = template_subject;
	_tmp23_ = zeitgeist_subject_get_mimetype (_tmp22_);
	_tmp24_ = alm_utilities_check_field_match (_tmp21_, _tmp23_, "sub-mime");
	if (!_tmp24_) {
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}


static gboolean alm_utilities_check_field_match (const gchar* property, const gchar* template_property, const gchar* property_name) {
	gboolean result = FALSE;
	gboolean matches;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* parsed;
	gboolean _tmp2_ = FALSE;
	const gchar* _tmp3_;
	gboolean _tmp5_;
	gboolean is_negated;
	const gchar* _tmp6_;
	gboolean _tmp9_ = FALSE;
	gboolean _tmp10_;
	gboolean _tmp13_;
	g_return_val_if_fail (property_name != NULL, FALSE);
	matches = FALSE;
	_tmp0_ = template_property;
	_tmp1_ = g_strdup (_tmp0_);
	parsed = _tmp1_;
	_tmp3_ = template_property;
	if (_tmp3_ != NULL) {
		gboolean _tmp4_ = FALSE;
		_tmp4_ = alm_utilities_parse_negation (&parsed);
		_tmp2_ = _tmp4_;
	} else {
		_tmp2_ = FALSE;
	}
	_tmp5_ = _tmp2_;
	is_negated = _tmp5_;
	_tmp6_ = parsed;
	if (g_strcmp0 (_tmp6_, "") == 0) {
		result = TRUE;
		_g_free0 (parsed);
		return result;
	} else {
		const gchar* _tmp7_;
		const gchar* _tmp8_;
		_tmp7_ = parsed;
		_tmp8_ = property;
		if (g_strcmp0 (_tmp7_, _tmp8_) == 0) {
			matches = TRUE;
		}
	}
	_tmp10_ = is_negated;
	if (_tmp10_) {
		gboolean _tmp11_;
		_tmp11_ = matches;
		_tmp9_ = !_tmp11_;
	} else {
		gboolean _tmp12_;
		_tmp12_ = matches;
		_tmp9_ = _tmp12_;
	}
	_tmp13_ = _tmp9_;
	result = _tmp13_;
	_g_free0 (parsed);
	return result;
}


gboolean alm_utilities_parse_negation (gchar** val) {
	gboolean result = FALSE;
	const gchar* _tmp0_;
	gboolean _tmp1_ = FALSE;
	const gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (val != NULL, FALSE);
	_tmp0_ = *val;
	_tmp1_ = g_str_has_prefix (_tmp0_, "!");
	if (!_tmp1_) {
		result = FALSE;
		return result;
	}
	_tmp2_ = *val;
	_tmp3_ = string_substring (_tmp2_, (glong) 1, (glong) (-1));
	_g_free0 (*val);
	*val = _tmp3_;
	result = TRUE;
	return result;
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


GHashTable* alm_utilities_from_variant (GVariant* templates_variant) {
	GHashTable* result = NULL;
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GHashTable* _tmp2_;
	GHashTable* blacklist;
	GVariant* _tmp3_;
	const gchar* _tmp4_ = NULL;
	g_return_val_if_fail (templates_variant != NULL, NULL);
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, _g_free0_, _g_object_unref0_);
	blacklist = _tmp2_;
	_tmp3_ = templates_variant;
	_tmp4_ = g_variant_get_type_string (_tmp3_);
	g_warn_if_fail (g_strcmp0 (_tmp4_, ALM_UTILITIES_SIG_BLACKLIST) == 0);
	{
		GVariant* _tmp5_;
		GVariantIter* _tmp6_ = NULL;
		GVariantIter* _template_variant_it;
		GVariant* template_variant = NULL;
		_tmp5_ = templates_variant;
		_tmp6_ = g_variant_iter_new (_tmp5_);
		_template_variant_it = _tmp6_;
		while (TRUE) {
			GVariantIter* _tmp7_;
			GVariant* _tmp8_ = NULL;
			GVariant* _tmp9_;
			GVariant* _tmp10_;
			GVariantIter* _tmp11_ = NULL;
			GVariantIter* iter;
			GVariantIter* _tmp12_;
			GVariant* _tmp13_ = NULL;
			GVariant* _tmp14_;
			const gchar* _tmp15_ = NULL;
			gchar* _tmp16_;
			gchar* _tmp17_;
			gchar* template_id;
			GVariantIter* _tmp18_;
			GVariant* _tmp19_ = NULL;
			GVariant* ev_variant;
			GVariant* _tmp20_;
			_tmp7_ = _template_variant_it;
			_tmp8_ = g_variant_iter_next_value (_tmp7_);
			_g_variant_unref0 (template_variant);
			template_variant = _tmp8_;
			_tmp9_ = template_variant;
			if (!(_tmp9_ != NULL)) {
				break;
			}
			_tmp10_ = template_variant;
			_tmp11_ = g_variant_iter_new (_tmp10_);
			iter = _tmp11_;
			_tmp12_ = iter;
			_tmp13_ = g_variant_iter_next_value (_tmp12_);
			_tmp14_ = _tmp13_;
			_tmp15_ = g_variant_get_string (_tmp14_, NULL);
			_tmp16_ = g_strdup (_tmp15_);
			_tmp17_ = _tmp16_;
			_g_variant_unref0 (_tmp14_);
			template_id = _tmp17_;
			_tmp18_ = iter;
			_tmp19_ = g_variant_iter_next_value (_tmp18_);
			ev_variant = _tmp19_;
			_tmp20_ = ev_variant;
			if (_tmp20_ != NULL) {
				GVariant* _tmp21_;
				ZeitgeistEvent* _tmp22_;
				ZeitgeistEvent* _tmp23_;
				ZeitgeistEvent* template;
				GHashTable* _tmp24_;
				const gchar* _tmp25_;
				gchar* _tmp26_;
				ZeitgeistEvent* _tmp27_;
				ZeitgeistEvent* _tmp28_;
				_tmp21_ = ev_variant;
				_tmp22_ = zeitgeist_event_new_from_variant (_tmp21_);
				_tmp23_ = g_object_ref_sink (_tmp22_);
				template = _tmp23_;
				_tmp24_ = blacklist;
				_tmp25_ = template_id;
				_tmp26_ = g_strdup (_tmp25_);
				_tmp27_ = template;
				_tmp28_ = _g_object_ref0 (_tmp27_);
				g_hash_table_insert (_tmp24_, _tmp26_, _tmp28_);
				_g_object_unref0 (template);
			}
			_g_variant_unref0 (ev_variant);
			_g_free0 (template_id);
			_g_variant_iter_free0 (iter);
		}
		_g_variant_unref0 (template_variant);
		_g_variant_iter_free0 (_template_variant_it);
	}
	result = blacklist;
	return result;
}


GVariant* alm_utilities_to_variant (GHashTable* blacklist) {
	GVariant* result = NULL;
	GVariantType* _tmp0_;
	GVariantType* _tmp1_;
	GVariantBuilder* _tmp2_;
	GVariantBuilder* _tmp3_;
	GVariantBuilder* vb;
	GVariantBuilder* _tmp19_;
	GVariant* _tmp20_ = NULL;
	GVariant* _tmp21_;
	g_return_val_if_fail (blacklist != NULL, NULL);
	_tmp0_ = g_variant_type_new (ALM_UTILITIES_SIG_BLACKLIST);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_variant_builder_new (_tmp1_);
	_tmp3_ = _tmp2_;
	_g_variant_type_free0 (_tmp1_);
	vb = _tmp3_;
	{
		GHashTable* _tmp4_;
		GHashTableIter iter = {0};
		gchar* template_id = NULL;
		ZeitgeistEvent* event_template = NULL;
		_tmp4_ = blacklist;
		g_hash_table_iter_init (&iter, _tmp4_);
		while (TRUE) {
			gconstpointer _tmp5_ = NULL;
			gconstpointer _tmp6_ = NULL;
			gboolean _tmp7_ = FALSE;
			gchar* _tmp8_;
			ZeitgeistEvent* _tmp9_;
			GVariantBuilder* _tmp10_;
			GVariantType* _tmp11_;
			GVariantType* _tmp12_;
			GVariantBuilder* _tmp13_;
			const gchar* _tmp14_;
			GVariantBuilder* _tmp15_;
			ZeitgeistEvent* _tmp16_;
			GVariant* _tmp17_ = NULL;
			GVariantBuilder* _tmp18_;
			_tmp7_ = g_hash_table_iter_next (&iter, &_tmp5_, &_tmp6_);
			_g_free0 (template_id);
			_tmp8_ = g_strdup (_tmp5_);
			template_id = _tmp8_;
			_g_object_unref0 (event_template);
			_tmp9_ = _g_object_ref0 (_tmp6_);
			event_template = _tmp9_;
			if (!_tmp7_) {
				break;
			}
			_tmp10_ = vb;
			_tmp11_ = g_variant_type_new ("{s(" ALM_UTILITIES_SIG_EVENT ")}");
			_tmp12_ = _tmp11_;
			g_variant_builder_open (_tmp10_, _tmp12_);
			_g_variant_type_free0 (_tmp12_);
			_tmp13_ = vb;
			_tmp14_ = template_id;
			g_variant_builder_add (_tmp13_, "s", _tmp14_, NULL);
			_tmp15_ = vb;
			_tmp16_ = event_template;
			_tmp17_ = zeitgeist_event_to_variant (_tmp16_);
			g_variant_builder_add_value (_tmp15_, _tmp17_);
			_tmp18_ = vb;
			g_variant_builder_close (_tmp18_);
		}
		_g_object_unref0 (event_template);
		_g_free0 (template_id);
	}
	_tmp19_ = vb;
	_tmp20_ = g_variant_builder_end (_tmp19_);
	_tmp21_ = g_variant_ref_sink (_tmp20_);
	result = _tmp21_;
	_g_variant_builder_unref0 (vb);
	return result;
}


AlmUtilities* alm_utilities_construct (GType object_type) {
	AlmUtilities* self = NULL;
	self = (AlmUtilities*) g_type_create_instance (object_type);
	return self;
}


AlmUtilities* alm_utilities_new (void) {
	return alm_utilities_construct (ALM_TYPE_UTILITIES);
}


static void alm_value_utilities_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void alm_value_utilities_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		alm_utilities_unref (value->data[0].v_pointer);
	}
}


static void alm_value_utilities_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = alm_utilities_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer alm_value_utilities_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* alm_value_utilities_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		AlmUtilities* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = alm_utilities_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* alm_value_utilities_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	AlmUtilities** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = alm_utilities_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* alm_param_spec_utilities (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	AlmParamSpecUtilities* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ALM_TYPE_UTILITIES), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer alm_value_get_utilities (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ALM_TYPE_UTILITIES), NULL);
	return value->data[0].v_pointer;
}


void alm_value_set_utilities (GValue* value, gpointer v_object) {
	AlmUtilities* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ALM_TYPE_UTILITIES));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ALM_TYPE_UTILITIES));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		alm_utilities_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		alm_utilities_unref (old);
	}
}


void alm_value_take_utilities (GValue* value, gpointer v_object) {
	AlmUtilities* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ALM_TYPE_UTILITIES));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ALM_TYPE_UTILITIES));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		alm_utilities_unref (old);
	}
}


static void alm_utilities_class_init (AlmUtilitiesClass * klass) {
	alm_utilities_parent_class = g_type_class_peek_parent (klass);
	ALM_UTILITIES_CLASS (klass)->finalize = alm_utilities_finalize;
}


static void alm_utilities_instance_init (AlmUtilities * self) {
	self->ref_count = 1;
}


static void alm_utilities_finalize (AlmUtilities* obj) {
	AlmUtilities * self;
	self = ALM_UTILITIES (obj);
}


GType alm_utilities_get_type (void) {
	static volatile gsize alm_utilities_type_id__volatile = 0;
	if (g_once_init_enter (&alm_utilities_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { alm_value_utilities_init, alm_value_utilities_free_value, alm_value_utilities_copy_value, alm_value_utilities_peek_pointer, "p", alm_value_utilities_collect_value, "p", alm_value_utilities_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (AlmUtilitiesClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) alm_utilities_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AlmUtilities), 0, (GInstanceInitFunc) alm_utilities_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType alm_utilities_type_id;
		alm_utilities_type_id = g_type_register_fundamental (g_type_fundamental_next (), "AlmUtilities", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&alm_utilities_type_id__volatile, alm_utilities_type_id);
	}
	return alm_utilities_type_id__volatile;
}


gpointer alm_utilities_ref (gpointer instance) {
	AlmUtilities* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void alm_utilities_unref (gpointer instance) {
	AlmUtilities* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ALM_UTILITIES_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



