/* history-widget.c generated by valac 0.14.2, the Vala compiler
 * generated from history-widget.vala, do not modify */

/* -*- Mode: vala; tab-width: 4; intend-tabs-mode: t -*- */
/* alm
 *
 * Copyright (C) 2012 Seif Lotfy <seif@lotfy.com>
 * Copyright (C) 2012 Manish Sinha <manishsinha@ubuntu.com>
 * Copyright (C) 2012 Intel Corp.
 *               Authored by: Seif Lotfy <seif.lotfy@collabora.co.uk>
 *
alm is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * alm is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.";
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <zeitgeist.h>
#include <glib/gi18n-lib.h>
#include <float.h>
#include <math.h>
#include <pango/pango.h>
#include <gio/gio.h>
#include <gdk/gdk.h>


#define ALM_TYPE_HISTORY_WIDGET (alm_history_widget_get_type ())
#define ALM_HISTORY_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ALM_TYPE_HISTORY_WIDGET, AlmHistoryWidget))
#define ALM_HISTORY_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ALM_TYPE_HISTORY_WIDGET, AlmHistoryWidgetClass))
#define ALM_IS_HISTORY_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ALM_TYPE_HISTORY_WIDGET))
#define ALM_IS_HISTORY_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ALM_TYPE_HISTORY_WIDGET))
#define ALM_HISTORY_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ALM_TYPE_HISTORY_WIDGET, AlmHistoryWidgetClass))

typedef struct _AlmHistoryWidget AlmHistoryWidget;
typedef struct _AlmHistoryWidgetClass AlmHistoryWidgetClass;
typedef struct _AlmHistoryWidgetPrivate AlmHistoryWidgetPrivate;

#define ALM_TYPE_CALENDAR_WIDGET (alm_calendar_widget_get_type ())
#define ALM_CALENDAR_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ALM_TYPE_CALENDAR_WIDGET, AlmCalendarWidget))
#define ALM_CALENDAR_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ALM_TYPE_CALENDAR_WIDGET, AlmCalendarWidgetClass))
#define ALM_IS_CALENDAR_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ALM_TYPE_CALENDAR_WIDGET))
#define ALM_IS_CALENDAR_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ALM_TYPE_CALENDAR_WIDGET))
#define ALM_CALENDAR_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ALM_TYPE_CALENDAR_WIDGET, AlmCalendarWidgetClass))

typedef struct _AlmCalendarWidget AlmCalendarWidget;
typedef struct _AlmCalendarWidgetClass AlmCalendarWidgetClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_array_unref0(var) ((var == NULL) ? NULL : (var = (g_array_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_ptr_array_unref0(var) ((var == NULL) ? NULL : (var = (g_ptr_array_unref (var), NULL)))
typedef struct _AlmHistoryWidgetGetHistoryData AlmHistoryWidgetGetHistoryData;
typedef struct _AlmHistoryWidgetDeleteHistoryData AlmHistoryWidgetDeleteHistoryData;

#define ALM_TYPE_CALENDAR_DIALOG (alm_calendar_dialog_get_type ())
#define ALM_CALENDAR_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ALM_TYPE_CALENDAR_DIALOG, AlmCalendarDialog))
#define ALM_CALENDAR_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ALM_TYPE_CALENDAR_DIALOG, AlmCalendarDialogClass))
#define ALM_IS_CALENDAR_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ALM_TYPE_CALENDAR_DIALOG))
#define ALM_IS_CALENDAR_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ALM_TYPE_CALENDAR_DIALOG))
#define ALM_CALENDAR_DIALOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ALM_TYPE_CALENDAR_DIALOG, AlmCalendarDialogClass))

typedef struct _AlmCalendarDialog AlmCalendarDialog;
typedef struct _AlmCalendarDialogClass AlmCalendarDialogClass;
typedef struct _AlmCalendarDialogPrivate AlmCalendarDialogPrivate;
typedef struct _AlmCalendarWidgetPrivate AlmCalendarWidgetPrivate;
typedef struct _Block1Data Block1Data;
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))
typedef struct _Block2Data Block2Data;

struct _AlmHistoryWidget {
	GtkBox parent_instance;
	AlmHistoryWidgetPrivate * priv;
};

struct _AlmHistoryWidgetClass {
	GtkBoxClass parent_class;
};

struct _AlmHistoryWidgetPrivate {
	GeeArrayList* past_records;
	AlmCalendarWidget* calendar_box;
	GtkButtonBox* button_box;
	ZeitgeistLog* zg_log;
	GtkButton* del_button;
	GtkComboBoxText* history_erase_kind;
};

struct _AlmHistoryWidgetGetHistoryData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	AlmHistoryWidget* self;
	ZeitgeistTimeRange* tr;
	GtkDialog* _tmp0_;
	GtkDialog* _tmp1_;
	GtkDialog* dialog;
	GtkDialog* _tmp2_;
	GtkDialog* _tmp3_;
	GtkDialog* _tmp4_;
	const gchar* _tmp5_;
	GtkLabel* _tmp6_;
	GtkLabel* _tmp7_;
	GtkLabel* label;
	GtkLabel* _tmp8_;
	GtkLabel* _tmp9_;
	GtkLabel* _tmp10_;
	GtkDialog* _tmp11_;
	GtkBox* _tmp12_;
	GtkLabel* _tmp13_;
	GtkDialog* _tmp14_;
	GtkWidget* _tmp15_;
	GtkDialog* _tmp16_;
	GtkDialog* _tmp17_;
	GtkDialog* _tmp18_;
	gint _tmp19_;
	gint res;
	GtkDialog* _tmp20_;
	gint _tmp21_;
	GPtrArray* _tmp22_;
	GPtrArray* ptr_arr;
	GPtrArray* _tmp23_;
	ZeitgeistEvent* _tmp24_;
	ZeitgeistEvent* _tmp25_;
	ZeitgeistLog* _tmp26_;
	ZeitgeistTimeRange* _tmp27_;
	GPtrArray* _tmp28_;
	GArray* _tmp29_;
	GArray* ids;
	GArray* _tmp30_;
	GError* err;
	GError* _tmp31_;
	const gchar* _tmp32_;
	GError * _inner_error_;
};

struct _AlmHistoryWidgetDeleteHistoryData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	AlmHistoryWidget* self;
	GArray* ids;
	ZeitgeistLog* _tmp0_;
	GArray* _tmp1_;
	GArray* _tmp2_;
	gboolean _tmp3_;
	gboolean rs;
	GError* err;
	GError* _tmp4_;
	const gchar* _tmp5_;
	GError * _inner_error_;
};

struct _AlmCalendarDialog {
	GtkDialog parent_instance;
	AlmCalendarDialogPrivate * priv;
};

struct _AlmCalendarDialogClass {
	GtkDialogClass parent_class;
};

struct _AlmCalendarDialogPrivate {
	GtkCalendar* calendar;
};

struct _AlmCalendarWidget {
	GtkGrid parent_instance;
	AlmCalendarWidgetPrivate * priv;
};

struct _AlmCalendarWidgetClass {
	GtkGridClass parent_class;
};

struct _AlmCalendarWidgetPrivate {
	GtkEntry* start_entry;
	GtkEntry* end_entry;
	AlmCalendarDialog* start_dialog;
	AlmCalendarDialog* end_dialog;
	GtkButton* button;
	GtkLabel* invalid_label;
};

struct _Block1Data {
	int _ref_count_;
	AlmCalendarWidget * self;
	GtkButton* start_button;
	GtkButton* end_button;
};

struct _Block2Data {
	int _ref_count_;
	AlmCalendarWidget * self;
	GtkWidget* widget;
	GtkEntry* entry;
	AlmCalendarDialog* dialog;
};


static gpointer alm_history_widget_parent_class = NULL;
static gpointer alm_calendar_dialog_parent_class = NULL;
static gpointer alm_calendar_widget_parent_class = NULL;

GType alm_history_widget_get_type (void) G_GNUC_CONST;
GType alm_calendar_widget_get_type (void) G_GNUC_CONST;
#define ALM_HISTORY_WIDGET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ALM_TYPE_HISTORY_WIDGET, AlmHistoryWidgetPrivate))
enum  {
	ALM_HISTORY_WIDGET_DUMMY_PROPERTY
};
AlmHistoryWidget* alm_history_widget_new (void);
AlmHistoryWidget* alm_history_widget_construct (GType object_type);
void alm_history_widget_set_up_ui (AlmHistoryWidget* self);
static void __lambda4_ (AlmHistoryWidget* self);
static void alm_history_widget_on_history_combo_changed (AlmHistoryWidget* self, GtkComboBoxText* box);
static void ___lambda4__gtk_combo_box_changed (GtkComboBox* _sender, gpointer self);
AlmCalendarWidget* alm_calendar_widget_new (GtkButton* button);
AlmCalendarWidget* alm_calendar_widget_construct (GType object_type, GtkButton* button);
static void __lambda5_ (AlmHistoryWidget* self);
static void alm_history_widget_get_history (AlmHistoryWidget* self, ZeitgeistTimeRange* tr, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void alm_history_widget_get_history_finish (AlmHistoryWidget* self, GAsyncResult* _res_);
ZeitgeistTimeRange* alm_calendar_widget_get_range (AlmCalendarWidget* self);
static void ___lambda5__gtk_button_clicked (GtkButton* _sender, gpointer self);
static void alm_history_widget_get_history_data_free (gpointer _data);
static gboolean alm_history_widget_get_history_co (AlmHistoryWidgetGetHistoryData* _data_);
static gboolean _alm_history_widget_get_history_co_gsource_func (gpointer self);
static void alm_history_widget_get_history_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void alm_history_widget_delete_history (AlmHistoryWidget* self, GArray* ids, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void alm_history_widget_delete_history_finish (AlmHistoryWidget* self, GAsyncResult* _res_);
static void alm_history_widget_delete_history_data_free (gpointer _data);
static gboolean alm_history_widget_delete_history_co (AlmHistoryWidgetDeleteHistoryData* _data_);
static gboolean _alm_history_widget_delete_history_co_gsource_func (gpointer self);
static void alm_history_widget_delete_history_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void alm_history_widget_insert_calendar (AlmHistoryWidget* self);
static void alm_history_widget_remove_calendar (AlmHistoryWidget* self);
static void alm_history_widget_finalize (GObject* obj);
GType alm_calendar_dialog_get_type (void) G_GNUC_CONST;
#define ALM_CALENDAR_DIALOG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ALM_TYPE_CALENDAR_DIALOG, AlmCalendarDialogPrivate))
enum  {
	ALM_CALENDAR_DIALOG_DUMMY_PROPERTY
};
AlmCalendarDialog* alm_calendar_dialog_new (void);
AlmCalendarDialog* alm_calendar_dialog_construct (GType object_type);
GtkCalendar* alm_calendar_dialog_get_calendar_widget (AlmCalendarDialog* self);
static void alm_calendar_dialog_finalize (GObject* obj);
#define ALM_CALENDAR_WIDGET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ALM_TYPE_CALENDAR_WIDGET, AlmCalendarWidgetPrivate))
enum  {
	ALM_CALENDAR_WIDGET_DUMMY_PROPERTY
};
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (Block1Data* _data1_);
static void __lambda0_ (Block1Data* _data1_);
void alm_calendar_widget_on_clicked (AlmCalendarWidget* self, GtkWidget* widget, GtkEntry* entry, AlmCalendarDialog* dialog);
static void ___lambda0__gtk_button_clicked (GtkButton* _sender, gpointer self);
static void __lambda3_ (Block1Data* _data1_);
static void ___lambda3__gtk_button_clicked (GtkButton* _sender, gpointer self);
void alm_calendar_widget_set_up_calendar (AlmCalendarWidget* self, GtkButton* widget, GtkEntry* entry, AlmCalendarDialog* dialog);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (Block2Data* _data2_);
static gboolean __lambda1_ (Block2Data* _data2_, GtkWidget* w, GdkEventFocus* e);
static gboolean ___lambda1__gtk_widget_focus_out_event (GtkWidget* _sender, GdkEventFocus* event, gpointer self);
static void __lambda2_ (Block2Data* _data2_);
static void ___lambda2__gtk_calendar_day_selected_double_click (GtkCalendar* _sender, gpointer self);
static void alm_calendar_widget_finalize (GObject* obj);


AlmHistoryWidget* alm_history_widget_construct (GType object_type) {
	AlmHistoryWidget * self = NULL;
	ZeitgeistLog* _tmp0_;
	GeeArrayList* _tmp1_;
	GeeArrayList* _tmp2_;
	const gchar* _tmp3_ = NULL;
	GeeArrayList* _tmp4_;
	const gchar* _tmp5_ = NULL;
	GeeArrayList* _tmp6_;
	const gchar* _tmp7_ = NULL;
	GeeArrayList* _tmp8_;
	const gchar* _tmp9_ = NULL;
	GeeArrayList* _tmp10_;
	const gchar* _tmp11_ = NULL;
	self = (AlmHistoryWidget*) g_object_new (object_type, "orientation", GTK_ORIENTATION_VERTICAL, NULL);
	gtk_box_set_spacing ((GtkBox*) self, 0);
	gtk_container_set_border_width ((GtkContainer*) self, (guint) 12);
	_tmp0_ = zeitgeist_log_new ();
	_g_object_unref0 (self->priv->zg_log);
	self->priv->zg_log = _tmp0_;
	_tmp1_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL);
	_g_object_unref0 (self->priv->past_records);
	self->priv->past_records = _tmp1_;
	_tmp2_ = self->priv->past_records;
	_tmp3_ = _ ("The past hour");
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp2_, _tmp3_);
	_tmp4_ = self->priv->past_records;
	_tmp5_ = _ ("The past day");
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp4_, _tmp5_);
	_tmp6_ = self->priv->past_records;
	_tmp7_ = _ ("The past week");
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp6_, _tmp7_);
	_tmp8_ = self->priv->past_records;
	_tmp9_ = _ ("All");
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp8_, _tmp9_);
	_tmp10_ = self->priv->past_records;
	_tmp11_ = _ ("Advanced");
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp10_, _tmp11_);
	alm_history_widget_set_up_ui (self);
	return self;
}


AlmHistoryWidget* alm_history_widget_new (void) {
	return alm_history_widget_construct (ALM_TYPE_HISTORY_WIDGET);
}


static void __lambda4_ (AlmHistoryWidget* self) {
	GtkComboBoxText* _tmp0_;
	_tmp0_ = self->priv->history_erase_kind;
	alm_history_widget_on_history_combo_changed (self, _tmp0_);
}


static void ___lambda4__gtk_combo_box_changed (GtkComboBox* _sender, gpointer self) {
	__lambda4_ (self);
}


static void __lambda5_ (AlmHistoryWidget* self) {
	ZeitgeistTimeRange* tr = NULL;
	GtkComboBoxText* _tmp0_;
	gint _tmp1_ = 0;
	gint index;
	gint _tmp2_;
	_tmp0_ = self->priv->history_erase_kind;
	_tmp1_ = gtk_combo_box_get_active ((GtkComboBox*) _tmp0_);
	index = _tmp1_;
	_tmp2_ = index;
	if (_tmp2_ < 3) {
		gint range;
		gint _tmp3_;
		gint64 _tmp9_ = 0LL;
		gint64 end;
		gint64 _tmp10_;
		gint _tmp11_;
		gint64 start;
		gint64 _tmp12_;
		gint64 _tmp13_;
		ZeitgeistTimeRange* _tmp14_;
		ZeitgeistTimeRange* _tmp15_;
		ZeitgeistTimeRange* _tmp16_;
		range = (60 * 60) * 1000;
		_tmp3_ = index;
		if (_tmp3_ == 0) {
			gint _tmp4_;
			_tmp4_ = range;
			range = 1 * _tmp4_;
		} else {
			gint _tmp5_;
			_tmp5_ = index;
			if (_tmp5_ == 1) {
				gint _tmp6_;
				_tmp6_ = range;
				range = _tmp6_ * 24;
			} else {
				gint _tmp7_;
				_tmp7_ = index;
				if (_tmp7_ == 2) {
					gint _tmp8_;
					_tmp8_ = range;
					range = (_tmp8_ * 24) * 7;
				}
			}
		}
		_tmp9_ = zeitgeist_timestamp_for_now ();
		end = _tmp9_;
		_tmp10_ = end;
		_tmp11_ = range;
		start = _tmp10_ - _tmp11_;
		_tmp12_ = start;
		_tmp13_ = end;
		_tmp14_ = zeitgeist_time_range_new (_tmp12_, _tmp13_);
		_tmp15_ = g_object_ref_sink (_tmp14_);
		_g_object_unref0 (tr);
		tr = _tmp15_;
		_tmp16_ = tr;
		alm_history_widget_get_history (self, _tmp16_, NULL, NULL);
	} else {
		gint _tmp17_;
		_tmp17_ = index;
		if (_tmp17_ == 3) {
			ZeitgeistTimeRange* _tmp18_;
			ZeitgeistTimeRange* _tmp19_;
			ZeitgeistTimeRange* _tmp20_;
			_tmp18_ = zeitgeist_time_range_new_anytime ();
			_tmp19_ = g_object_ref_sink (_tmp18_);
			_g_object_unref0 (tr);
			tr = _tmp19_;
			_tmp20_ = tr;
			alm_history_widget_get_history (self, _tmp20_, NULL, NULL);
		} else {
			gint _tmp21_;
			_tmp21_ = index;
			if (_tmp21_ == 4) {
				AlmCalendarWidget* _tmp22_;
				ZeitgeistTimeRange* _tmp23_ = NULL;
				ZeitgeistTimeRange* _tmp24_;
				_tmp22_ = self->priv->calendar_box;
				_tmp23_ = alm_calendar_widget_get_range (_tmp22_);
				_g_object_unref0 (tr);
				tr = _tmp23_;
				_tmp24_ = tr;
				alm_history_widget_get_history (self, _tmp24_, NULL, NULL);
			}
		}
	}
	_g_object_unref0 (tr);
}


static void ___lambda5__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	__lambda5_ (self);
}


void alm_history_widget_set_up_ui (AlmHistoryWidget* self) {
	GtkBox* _tmp0_;
	GtkBox* _tmp1_;
	GtkBox* top_box;
	GtkBox* _tmp2_;
	GtkBox* _tmp3_;
	GtkBox* _tmp4_;
	GtkBox* _tmp5_;
	GtkBox* text_box;
	GtkLabel* _tmp6_;
	GtkLabel* _tmp7_;
	GtkLabel* header;
	GtkLabel* _tmp8_;
	const gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	gchar* _tmp11_;
	GtkLabel* _tmp12_;
	GtkLabel* _tmp13_;
	GtkBox* _tmp14_;
	GtkLabel* _tmp15_;
	GtkLabel* _tmp16_;
	GtkLabel* _tmp17_;
	GtkLabel* label;
	GtkLabel* _tmp18_;
	const gchar* _tmp19_ = NULL;
	gchar* _tmp20_ = NULL;
	gchar* _tmp21_;
	GtkLabel* _tmp22_;
	GtkLabel* _tmp23_;
	GtkLabel* _tmp24_;
	GtkBox* _tmp25_;
	GtkLabel* _tmp26_;
	GtkBox* _tmp27_;
	GtkBox* _tmp28_;
	GtkComboBoxText* _tmp29_;
	GtkComboBoxText* _tmp30_;
	GtkComboBoxText* _tmp31_;
	GtkComboBoxText* _tmp44_;
	GtkComboBoxText* _tmp45_;
	GtkBox* _tmp46_;
	GtkBox* _tmp47_;
	GtkBox* temp_box;
	GtkLabel* _tmp48_;
	GtkLabel* _tmp49_;
	GtkComboBoxText* _tmp50_;
	GtkLabel* _tmp51_;
	GtkLabel* _tmp52_;
	GtkBox* _tmp53_;
	GtkButtonBox* _tmp54_;
	GtkButtonBox* _tmp55_;
	GtkButtonBox* _tmp56_;
	GtkBox* _tmp57_;
	GtkBox* _tmp58_;
	GtkButtonBox* _tmp59_;
	GtkButton* _tmp60_;
	GtkButton* _tmp61_;
	GtkButton* _tmp62_;
	const gchar* _tmp63_ = NULL;
	GtkButton* _tmp64_;
	AlmCalendarWidget* _tmp65_;
	AlmCalendarWidget* _tmp66_;
	GtkButtonBox* _tmp67_;
	GtkComboBoxText* _tmp68_;
	GtkButtonBox* _tmp69_;
	GtkButton* _tmp70_;
	GtkButton* _tmp71_;
	g_return_if_fail (self != NULL);
	_tmp0_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 21);
	_tmp1_ = g_object_ref_sink (_tmp0_);
	top_box = _tmp1_;
	_tmp2_ = top_box;
	gtk_widget_set_margin_top ((GtkWidget*) _tmp2_, 9);
	_tmp3_ = top_box;
	gtk_box_pack_start ((GtkBox*) self, (GtkWidget*) _tmp3_, FALSE, FALSE, (guint) 0);
	gtk_orientable_set_orientation ((GtkOrientable*) self, GTK_ORIENTATION_VERTICAL);
	_tmp4_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
	_tmp5_ = g_object_ref_sink (_tmp4_);
	text_box = _tmp5_;
	_tmp6_ = (GtkLabel*) gtk_label_new ("");
	_tmp7_ = g_object_ref_sink (_tmp6_);
	header = _tmp7_;
	_tmp8_ = header;
	_tmp9_ = _ ("Forget activities");
	_tmp10_ = g_strdup_printf ("<b>%s:</b>", _tmp9_);
	_tmp11_ = _tmp10_;
	gtk_label_set_markup (_tmp8_, _tmp11_);
	_g_free0 (_tmp11_);
	_tmp12_ = header;
	gtk_misc_set_alignment ((GtkMisc*) _tmp12_, (gfloat) 0, (gfloat) 0.5);
	_tmp13_ = header;
	gtk_misc_set_padding ((GtkMisc*) _tmp13_, 0, 0);
	_tmp14_ = text_box;
	_tmp15_ = header;
	gtk_box_pack_start (_tmp14_, (GtkWidget*) _tmp15_, FALSE, FALSE, (guint) 0);
	_tmp16_ = (GtkLabel*) gtk_label_new (NULL);
	_tmp17_ = g_object_ref_sink (_tmp16_);
	label = _tmp17_;
	_tmp18_ = label;
	_tmp19_ = _ ("Every time a file or an application is used, some information can be s" \
"tored. This activity can be used to retrieve files during searches or " \
"as history in applications.");
	_tmp20_ = g_strdup_printf ("<span size='small'>%s</span>", _tmp19_);
	_tmp21_ = _tmp20_;
	gtk_label_set_markup (_tmp18_, _tmp21_);
	_g_free0 (_tmp21_);
	_tmp22_ = label;
	gtk_label_set_line_wrap (_tmp22_, TRUE);
	_tmp23_ = label;
	gtk_label_set_line_wrap_mode (_tmp23_, PANGO_WRAP_WORD);
	_tmp24_ = label;
	gtk_misc_set_alignment ((GtkMisc*) _tmp24_, (gfloat) 0, 0.5f);
	_tmp25_ = text_box;
	_tmp26_ = label;
	gtk_box_pack_start (_tmp25_, (GtkWidget*) _tmp26_, FALSE, FALSE, (guint) 6);
	_tmp27_ = top_box;
	_tmp28_ = text_box;
	gtk_box_pack_start (_tmp27_, (GtkWidget*) _tmp28_, FALSE, FALSE, (guint) 0);
	_tmp29_ = (GtkComboBoxText*) gtk_combo_box_text_new ();
	_tmp30_ = g_object_ref_sink (_tmp29_);
	_g_object_unref0 (self->priv->history_erase_kind);
	self->priv->history_erase_kind = _tmp30_;
	_tmp31_ = self->priv->history_erase_kind;
	gtk_widget_set_size_request ((GtkWidget*) _tmp31_, 190, 0);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp32_;
			_tmp32_ = TRUE;
			while (TRUE) {
				gboolean _tmp33_;
				gint _tmp35_;
				GeeArrayList* _tmp36_;
				gint _tmp37_;
				gint _tmp38_;
				GtkComboBoxText* _tmp39_;
				GeeArrayList* _tmp40_;
				gint _tmp41_;
				gpointer _tmp42_ = NULL;
				gchar* _tmp43_;
				_tmp33_ = _tmp32_;
				if (!_tmp33_) {
					gint _tmp34_;
					_tmp34_ = i;
					i = _tmp34_ + 1;
				}
				_tmp32_ = FALSE;
				_tmp35_ = i;
				_tmp36_ = self->priv->past_records;
				_tmp37_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp36_);
				_tmp38_ = _tmp37_;
				if (!(_tmp35_ < _tmp38_)) {
					break;
				}
				_tmp39_ = self->priv->history_erase_kind;
				_tmp40_ = self->priv->past_records;
				_tmp41_ = i;
				_tmp42_ = gee_abstract_list_get ((GeeAbstractList*) _tmp40_, _tmp41_);
				_tmp43_ = (gchar*) _tmp42_;
				gtk_combo_box_text_append (_tmp39_, "", _tmp43_);
				_g_free0 (_tmp43_);
			}
		}
	}
	_tmp44_ = self->priv->history_erase_kind;
	gtk_combo_box_set_active ((GtkComboBox*) _tmp44_, 0);
	_tmp45_ = self->priv->history_erase_kind;
	g_signal_connect_object ((GtkComboBox*) _tmp45_, "changed", (GCallback) ___lambda4__gtk_combo_box_changed, self, 0);
	gtk_orientable_set_orientation ((GtkOrientable*) self, GTK_ORIENTATION_VERTICAL);
	_tmp46_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
	_tmp47_ = g_object_ref_sink (_tmp46_);
	temp_box = _tmp47_;
	_tmp48_ = (GtkLabel*) gtk_label_new ("");
	_tmp49_ = g_object_ref_sink (_tmp48_);
	gtk_box_pack_start (temp_box, (GtkWidget*) _tmp49_, TRUE, TRUE, (guint) 0);
	_g_object_unref0 (_tmp49_);
	_tmp50_ = self->priv->history_erase_kind;
	gtk_box_pack_start (temp_box, (GtkWidget*) _tmp50_, TRUE, TRUE, (guint) 0);
	_tmp51_ = (GtkLabel*) gtk_label_new ("");
	_tmp52_ = g_object_ref_sink (_tmp51_);
	gtk_box_pack_start (temp_box, (GtkWidget*) _tmp52_, TRUE, TRUE, (guint) 0);
	_g_object_unref0 (_tmp52_);
	_tmp53_ = top_box;
	gtk_box_pack_end (_tmp53_, (GtkWidget*) temp_box, FALSE, FALSE, (guint) 0);
	_tmp54_ = (GtkButtonBox*) gtk_button_box_new (GTK_ORIENTATION_HORIZONTAL);
	_tmp55_ = g_object_ref_sink (_tmp54_);
	_g_object_unref0 (self->priv->button_box);
	self->priv->button_box = _tmp55_;
	_tmp56_ = self->priv->button_box;
	g_object_set (_tmp56_, "layout-style", GTK_BUTTONBOX_START, NULL);
	_tmp57_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
	_tmp58_ = g_object_ref_sink (_tmp57_);
	gtk_box_pack_end ((GtkBox*) self, (GtkWidget*) _tmp58_, TRUE, TRUE, (guint) 0);
	_g_object_unref0 (_tmp58_);
	_tmp59_ = self->priv->button_box;
	gtk_box_pack_end ((GtkBox*) self, (GtkWidget*) _tmp59_, FALSE, FALSE, (guint) 0);
	_tmp60_ = (GtkButton*) gtk_button_new_from_stock (GTK_STOCK_DELETE);
	_tmp61_ = g_object_ref_sink (_tmp60_);
	_g_object_unref0 (self->priv->del_button);
	self->priv->del_button = _tmp61_;
	_tmp62_ = self->priv->del_button;
	_tmp63_ = _ ("Delete history");
	gtk_button_set_label (_tmp62_, _tmp63_);
	_tmp64_ = self->priv->del_button;
	_tmp65_ = alm_calendar_widget_new (_tmp64_);
	_tmp66_ = g_object_ref_sink (_tmp65_);
	_g_object_unref0 (self->priv->calendar_box);
	self->priv->calendar_box = _tmp66_;
	_tmp67_ = self->priv->button_box;
	_tmp68_ = self->priv->history_erase_kind;
	gtk_box_pack_start ((GtkBox*) _tmp67_, (GtkWidget*) _tmp68_, FALSE, FALSE, (guint) 0);
	_tmp69_ = self->priv->button_box;
	_tmp70_ = self->priv->del_button;
	gtk_box_pack_start ((GtkBox*) _tmp69_, (GtkWidget*) _tmp70_, FALSE, FALSE, (guint) 0);
	_tmp71_ = self->priv->del_button;
	g_signal_connect_object (_tmp71_, "clicked", (GCallback) ___lambda5__gtk_button_clicked, self, 0);
	_g_object_unref0 (temp_box);
	_g_object_unref0 (label);
	_g_object_unref0 (header);
	_g_object_unref0 (text_box);
	_g_object_unref0 (top_box);
}


static void alm_history_widget_get_history_data_free (gpointer _data) {
	AlmHistoryWidgetGetHistoryData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->tr);
	_g_object_unref0 (_data_->self);
	g_slice_free (AlmHistoryWidgetGetHistoryData, _data_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void alm_history_widget_get_history (AlmHistoryWidget* self, ZeitgeistTimeRange* tr, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	AlmHistoryWidgetGetHistoryData* _data_;
	AlmHistoryWidget* _tmp0_;
	ZeitgeistTimeRange* _tmp1_;
	ZeitgeistTimeRange* _tmp2_;
	_data_ = g_slice_new0 (AlmHistoryWidgetGetHistoryData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, alm_history_widget_get_history);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, alm_history_widget_get_history_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = tr;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_data_->tr = _tmp2_;
	alm_history_widget_get_history_co (_data_);
}


static void alm_history_widget_get_history_finish (AlmHistoryWidget* self, GAsyncResult* _res_) {
	AlmHistoryWidgetGetHistoryData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static gboolean _alm_history_widget_get_history_co_gsource_func (gpointer self) {
	gboolean result;
	result = alm_history_widget_get_history_co (self);
	return result;
}


static void alm_history_widget_get_history_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	AlmHistoryWidgetGetHistoryData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	alm_history_widget_get_history_co (_data_);
}


static gboolean alm_history_widget_get_history_co (AlmHistoryWidgetGetHistoryData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	g_idle_add_full (G_PRIORITY_LOW, _alm_history_widget_get_history_co_gsource_func, _data_, NULL);
	_data_->_state_ = 1;
	return FALSE;
	_state_1:
	;
	_data_->_tmp0_ = (GtkDialog*) gtk_dialog_new ();
	_data_->_tmp1_ = g_object_ref_sink (_data_->_tmp0_);
	_data_->dialog = _data_->_tmp1_;
	_data_->_tmp2_ = _data_->dialog;
	gtk_dialog_add_button (_data_->_tmp2_, GTK_STOCK_CANCEL, (gint) GTK_RESPONSE_CANCEL);
	_data_->_tmp3_ = _data_->dialog;
	gtk_dialog_add_button (_data_->_tmp3_, GTK_STOCK_YES, (gint) GTK_RESPONSE_OK);
	_data_->_tmp4_ = _data_->dialog;
	gtk_window_set_title ((GtkWindow*) _data_->_tmp4_, "");
	_data_->_tmp5_ = NULL;
	_data_->_tmp5_ = _ ("This operation cannot be undone, are you sure you want to delete this " \
"activity?");
	_data_->_tmp6_ = (GtkLabel*) gtk_label_new (_data_->_tmp5_);
	_data_->_tmp7_ = g_object_ref_sink (_data_->_tmp6_);
	_data_->label = _data_->_tmp7_;
	_data_->_tmp8_ = _data_->label;
	gtk_label_set_line_wrap (_data_->_tmp8_, TRUE);
	_data_->_tmp9_ = _data_->label;
	gtk_label_set_line_wrap_mode (_data_->_tmp9_, PANGO_WRAP_WORD);
	_data_->_tmp10_ = _data_->label;
	gtk_misc_set_padding ((GtkMisc*) _data_->_tmp10_, 9, 9);
	_data_->_tmp11_ = _data_->dialog;
	_data_->_tmp12_ = NULL;
	_data_->_tmp12_ = gtk_dialog_get_content_area (_data_->_tmp11_);
	_data_->_tmp13_ = _data_->label;
	gtk_container_add (GTK_CONTAINER (_data_->_tmp12_), (GtkWidget*) _data_->_tmp13_);
	_data_->_tmp14_ = _data_->dialog;
	_data_->_tmp15_ = NULL;
	_data_->_tmp15_ = gtk_widget_get_toplevel ((GtkWidget*) _data_->self);
	gtk_window_set_transient_for ((GtkWindow*) _data_->_tmp14_, GTK_WINDOW (_data_->_tmp15_));
	_data_->_tmp16_ = _data_->dialog;
	gtk_window_set_modal ((GtkWindow*) _data_->_tmp16_, TRUE);
	_data_->_tmp17_ = _data_->dialog;
	gtk_widget_show_all ((GtkWidget*) _data_->_tmp17_);
	_data_->_tmp18_ = _data_->dialog;
	_data_->_tmp19_ = 0;
	_data_->_tmp19_ = gtk_dialog_run (_data_->_tmp18_);
	_data_->res = _data_->_tmp19_;
	_data_->_tmp20_ = _data_->dialog;
	gtk_widget_destroy ((GtkWidget*) _data_->_tmp20_);
	_data_->_tmp21_ = _data_->res;
	if (_data_->_tmp21_ == ((gint) GTK_RESPONSE_OK)) {
		_data_->_tmp22_ = g_ptr_array_new ();
		_data_->ptr_arr = _data_->_tmp22_;
		_data_->_tmp23_ = _data_->ptr_arr;
		_data_->_tmp24_ = zeitgeist_event_new ();
		_data_->_tmp25_ = g_object_ref_sink (_data_->_tmp24_);
		g_ptr_array_add (_data_->_tmp23_, _data_->_tmp25_);
		_g_object_unref0 (_data_->_tmp25_);
		{
			_data_->_tmp26_ = _data_->self->priv->zg_log;
			_data_->_tmp27_ = _data_->tr;
			_data_->_tmp28_ = _data_->ptr_arr;
			_data_->ptr_arr = NULL;
			_data_->_state_ = 2;
			zeitgeist_log_find_event_ids (_data_->_tmp26_, _data_->_tmp27_, _data_->_tmp28_, ZEITGEIST_STORAGE_STATE_ANY, (guint32) 0, 0, NULL, alm_history_widget_get_history_ready, _data_);
			return FALSE;
			_state_2:
			_data_->_tmp29_ = NULL;
			_data_->_tmp29_ = zeitgeist_log_find_event_ids_finish (_data_->_tmp26_, _data_->_res_, &_data_->_inner_error_);
			_data_->ids = _data_->_tmp29_;
			if (_data_->_inner_error_ != NULL) {
				goto __catch0_g_error;
			}
			_data_->_tmp30_ = _data_->ids;
			alm_history_widget_delete_history (_data_->self, _data_->_tmp30_, NULL, NULL);
			_g_array_unref0 (_data_->ids);
		}
		goto __finally0;
		__catch0_g_error:
		{
			_data_->err = _data_->_inner_error_;
			_data_->_inner_error_ = NULL;
			_data_->_tmp31_ = _data_->err;
			_data_->_tmp32_ = _data_->_tmp31_->message;
			g_warning ("history-widget.vala:169: %s", _data_->_tmp32_);
			_g_error_free0 (_data_->err);
		}
		__finally0:
		if (_data_->_inner_error_ != NULL) {
			_g_ptr_array_unref0 (_data_->ptr_arr);
			_g_object_unref0 (_data_->label);
			_g_object_unref0 (_data_->dialog);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
		_g_ptr_array_unref0 (_data_->ptr_arr);
	}
	_g_object_unref0 (_data_->label);
	_g_object_unref0 (_data_->dialog);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void alm_history_widget_delete_history_data_free (gpointer _data) {
	AlmHistoryWidgetDeleteHistoryData* _data_;
	_data_ = _data;
	_g_array_unref0 (_data_->ids);
	_g_object_unref0 (_data_->self);
	g_slice_free (AlmHistoryWidgetDeleteHistoryData, _data_);
}


static gpointer _g_array_ref0 (gpointer self) {
	return self ? g_array_ref (self) : NULL;
}


static void alm_history_widget_delete_history (AlmHistoryWidget* self, GArray* ids, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	AlmHistoryWidgetDeleteHistoryData* _data_;
	AlmHistoryWidget* _tmp0_;
	GArray* _tmp1_;
	GArray* _tmp2_;
	_data_ = g_slice_new0 (AlmHistoryWidgetDeleteHistoryData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, alm_history_widget_delete_history);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, alm_history_widget_delete_history_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = ids;
	_tmp2_ = _g_array_ref0 (_tmp1_);
	_data_->ids = _tmp2_;
	alm_history_widget_delete_history_co (_data_);
}


static void alm_history_widget_delete_history_finish (AlmHistoryWidget* self, GAsyncResult* _res_) {
	AlmHistoryWidgetDeleteHistoryData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static gboolean _alm_history_widget_delete_history_co_gsource_func (gpointer self) {
	gboolean result;
	result = alm_history_widget_delete_history_co (self);
	return result;
}


static void alm_history_widget_delete_history_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	AlmHistoryWidgetDeleteHistoryData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	alm_history_widget_delete_history_co (_data_);
}


static gboolean alm_history_widget_delete_history_co (AlmHistoryWidgetDeleteHistoryData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	g_idle_add_full (G_PRIORITY_LOW, _alm_history_widget_delete_history_co_gsource_func, _data_, NULL);
	_data_->_state_ = 1;
	return FALSE;
	_state_1:
	;
	{
		_data_->_tmp0_ = _data_->self->priv->zg_log;
		_data_->_tmp1_ = _data_->ids;
		_data_->_tmp2_ = _g_array_ref0 (_data_->_tmp1_);
		_data_->_state_ = 2;
		zeitgeist_log_delete_events (_data_->_tmp0_, _data_->_tmp2_, NULL, alm_history_widget_delete_history_ready, _data_);
		return FALSE;
		_state_2:
		_data_->_tmp3_ = FALSE;
		_data_->_tmp3_ = zeitgeist_log_delete_events_finish (_data_->_tmp0_, _data_->_res_, &_data_->_inner_error_);
		_data_->rs = _data_->_tmp3_;
		if (_data_->_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
	}
	goto __finally1;
	__catch1_g_error:
	{
		_data_->err = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->_tmp4_ = _data_->err;
		_data_->_tmp5_ = _data_->_tmp4_->message;
		g_warning ("history-widget.vala:184: %s", _data_->_tmp5_);
		_g_error_free0 (_data_->err);
	}
	__finally1:
	if (_data_->_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		return FALSE;
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void alm_history_widget_insert_calendar (AlmHistoryWidget* self) {
	AlmCalendarWidget* _tmp0_;
	GtkWidget* _tmp1_ = NULL;
	AlmCalendarWidget* _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->calendar_box;
	_tmp1_ = gtk_widget_get_parent ((GtkWidget*) _tmp0_);
	if (_tmp1_ == NULL) {
		AlmCalendarWidget* _tmp2_;
		_tmp2_ = self->priv->calendar_box;
		gtk_box_pack_start ((GtkBox*) self, (GtkWidget*) _tmp2_, FALSE, FALSE, (guint) 9);
	}
	_tmp3_ = self->priv->calendar_box;
	gtk_widget_show_all ((GtkWidget*) _tmp3_);
}


static void alm_history_widget_remove_calendar (AlmHistoryWidget* self) {
	AlmCalendarWidget* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->calendar_box;
	gtk_widget_hide ((GtkWidget*) _tmp0_);
}


static void alm_history_widget_on_history_combo_changed (AlmHistoryWidget* self, GtkComboBoxText* box) {
	GtkComboBoxText* _tmp0_;
	gint _tmp1_ = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (box != NULL);
	_tmp0_ = box;
	_tmp1_ = gtk_combo_box_get_active ((GtkComboBox*) _tmp0_);
	if (_tmp1_ == 4) {
		AlmCalendarWidget* _tmp2_;
		ZeitgeistTimeRange* _tmp3_ = NULL;
		ZeitgeistTimeRange* x;
		_tmp2_ = self->priv->calendar_box;
		_tmp3_ = alm_calendar_widget_get_range (_tmp2_);
		x = _tmp3_;
		alm_history_widget_insert_calendar (self);
		_g_object_unref0 (x);
	} else {
		GtkButton* _tmp4_;
		_tmp4_ = self->priv->del_button;
		gtk_widget_set_sensitive ((GtkWidget*) _tmp4_, TRUE);
		alm_history_widget_remove_calendar (self);
	}
}


static void alm_history_widget_class_init (AlmHistoryWidgetClass * klass) {
	alm_history_widget_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (AlmHistoryWidgetPrivate));
	G_OBJECT_CLASS (klass)->finalize = alm_history_widget_finalize;
}


static void alm_history_widget_instance_init (AlmHistoryWidget * self) {
	self->priv = ALM_HISTORY_WIDGET_GET_PRIVATE (self);
}


static void alm_history_widget_finalize (GObject* obj) {
	AlmHistoryWidget * self;
	self = ALM_HISTORY_WIDGET (obj);
	_g_object_unref0 (self->priv->past_records);
	_g_object_unref0 (self->priv->calendar_box);
	_g_object_unref0 (self->priv->button_box);
	_g_object_unref0 (self->priv->zg_log);
	_g_object_unref0 (self->priv->del_button);
	_g_object_unref0 (self->priv->history_erase_kind);
	G_OBJECT_CLASS (alm_history_widget_parent_class)->finalize (obj);
}


GType alm_history_widget_get_type (void) {
	static volatile gsize alm_history_widget_type_id__volatile = 0;
	if (g_once_init_enter (&alm_history_widget_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AlmHistoryWidgetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) alm_history_widget_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AlmHistoryWidget), 0, (GInstanceInitFunc) alm_history_widget_instance_init, NULL };
		GType alm_history_widget_type_id;
		alm_history_widget_type_id = g_type_register_static (GTK_TYPE_BOX, "AlmHistoryWidget", &g_define_type_info, 0);
		g_once_init_leave (&alm_history_widget_type_id__volatile, alm_history_widget_type_id);
	}
	return alm_history_widget_type_id__volatile;
}


AlmCalendarDialog* alm_calendar_dialog_construct (GType object_type) {
	AlmCalendarDialog * self = NULL;
	GtkCalendar* _tmp0_;
	GtkCalendar* _tmp1_;
	GtkBox* _tmp2_ = NULL;
	GtkCalendar* _tmp3_;
	GValue _tmp4_ = {0};
	self = (AlmCalendarDialog*) g_object_new (object_type, NULL);
	_tmp0_ = (GtkCalendar*) gtk_calendar_new ();
	_tmp1_ = g_object_ref_sink (_tmp0_);
	_g_object_unref0 (self->priv->calendar);
	self->priv->calendar = _tmp1_;
	_tmp2_ = gtk_dialog_get_content_area ((GtkDialog*) self);
	_tmp3_ = self->priv->calendar;
	gtk_container_add (GTK_CONTAINER (_tmp2_), (GtkWidget*) _tmp3_);
	gtk_window_set_decorated ((GtkWindow*) self, FALSE);
	gtk_window_set_position ((GtkWindow*) self, 0);
	g_value_init (&_tmp4_, G_TYPE_BOOLEAN);
	g_value_set_boolean (&_tmp4_, TRUE);
	g_object_set_property ((GObject*) self, "skip-taskbar-hint", &_tmp4_);
	G_IS_VALUE (&_tmp4_) ? (g_value_unset (&_tmp4_), NULL) : NULL;
	return self;
}


AlmCalendarDialog* alm_calendar_dialog_new (void) {
	return alm_calendar_dialog_construct (ALM_TYPE_CALENDAR_DIALOG);
}


GtkCalendar* alm_calendar_dialog_get_calendar_widget (AlmCalendarDialog* self) {
	GtkCalendar* result = NULL;
	GtkCalendar* _tmp0_;
	GtkCalendar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->calendar;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	result = _tmp1_;
	return result;
}


static void alm_calendar_dialog_class_init (AlmCalendarDialogClass * klass) {
	alm_calendar_dialog_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (AlmCalendarDialogPrivate));
	G_OBJECT_CLASS (klass)->finalize = alm_calendar_dialog_finalize;
}


static void alm_calendar_dialog_instance_init (AlmCalendarDialog * self) {
	self->priv = ALM_CALENDAR_DIALOG_GET_PRIVATE (self);
}


static void alm_calendar_dialog_finalize (GObject* obj) {
	AlmCalendarDialog * self;
	self = ALM_CALENDAR_DIALOG (obj);
	_g_object_unref0 (self->priv->calendar);
	G_OBJECT_CLASS (alm_calendar_dialog_parent_class)->finalize (obj);
}


GType alm_calendar_dialog_get_type (void) {
	static volatile gsize alm_calendar_dialog_type_id__volatile = 0;
	if (g_once_init_enter (&alm_calendar_dialog_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AlmCalendarDialogClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) alm_calendar_dialog_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AlmCalendarDialog), 0, (GInstanceInitFunc) alm_calendar_dialog_instance_init, NULL };
		GType alm_calendar_dialog_type_id;
		alm_calendar_dialog_type_id = g_type_register_static (GTK_TYPE_DIALOG, "AlmCalendarDialog", &g_define_type_info, 0);
		g_once_init_leave (&alm_calendar_dialog_type_id__volatile, alm_calendar_dialog_type_id);
	}
	return alm_calendar_dialog_type_id__volatile;
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (Block1Data* _data1_) {
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		_g_object_unref0 (_data1_->self);
		_g_object_unref0 (_data1_->end_button);
		_g_object_unref0 (_data1_->start_button);
		g_slice_free (Block1Data, _data1_);
	}
}


static void __lambda0_ (Block1Data* _data1_) {
	AlmCalendarWidget * self;
	GtkEntry* _tmp0_;
	AlmCalendarDialog* _tmp1_;
	self = _data1_->self;
	_tmp0_ = self->priv->start_entry;
	_tmp1_ = self->priv->start_dialog;
	alm_calendar_widget_on_clicked (self, (GtkWidget*) _data1_->start_button, _tmp0_, _tmp1_);
}


static void ___lambda0__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	__lambda0_ (self);
}


static void __lambda3_ (Block1Data* _data1_) {
	AlmCalendarWidget * self;
	GtkEntry* _tmp0_;
	AlmCalendarDialog* _tmp1_;
	self = _data1_->self;
	_tmp0_ = self->priv->end_entry;
	_tmp1_ = self->priv->end_dialog;
	alm_calendar_widget_on_clicked (self, (GtkWidget*) _data1_->end_button, _tmp0_, _tmp1_);
}


static void ___lambda3__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	__lambda3_ (self);
}


AlmCalendarWidget* alm_calendar_widget_construct (GType object_type, GtkButton* button) {
	AlmCalendarWidget * self = NULL;
	Block1Data* _data1_;
	GtkButton* _tmp0_;
	GtkButton* _tmp1_;
	AlmCalendarDialog* _tmp2_;
	AlmCalendarDialog* _tmp3_;
	AlmCalendarDialog* _tmp4_;
	AlmCalendarDialog* _tmp5_;
	GtkBox* _tmp6_;
	GtkBox* _tmp7_;
	GtkBox* box1;
	GtkEntry* _tmp8_;
	GtkEntry* _tmp9_;
	GtkButton* _tmp10_;
	GtkButton* _tmp11_;
	GtkArrow* _tmp12_;
	GtkArrow* _tmp13_;
	GtkArrow* arrow1;
	GtkEntry* _tmp14_;
	GtkEntry* _tmp15_;
	GtkEntry* _tmp16_;
	GtkBox* _tmp17_;
	GtkBox* _tmp18_;
	GtkBox* box2;
	GtkEntry* _tmp19_;
	GtkEntry* _tmp20_;
	GtkButton* _tmp21_;
	GtkButton* _tmp22_;
	GtkArrow* _tmp23_;
	GtkArrow* _tmp24_;
	GtkArrow* arrow2;
	GtkEntry* _tmp25_;
	GtkEntry* _tmp26_;
	GtkEntry* _tmp27_;
	GtkLabel* _tmp28_;
	GtkLabel* _tmp29_;
	GtkLabel* start_label;
	const gchar* _tmp30_ = NULL;
	GtkLabel* _tmp31_;
	GtkLabel* _tmp32_;
	GtkLabel* end_label;
	const gchar* _tmp33_ = NULL;
	GtkLabel* _tmp34_;
	GtkLabel* _tmp35_;
	GtkLabel* _tmp36_;
	const gchar* _tmp37_ = NULL;
	gchar* _tmp38_ = NULL;
	gchar* _tmp39_;
	GtkEntry* _tmp40_;
	AlmCalendarDialog* _tmp41_;
	GtkEntry* _tmp42_;
	AlmCalendarDialog* _tmp43_;
	g_return_val_if_fail (button != NULL, NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	self = (AlmCalendarWidget*) g_object_new (object_type, NULL);
	_data1_->self = g_object_ref (self);
	_tmp0_ = button;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->button);
	self->priv->button = _tmp1_;
	_tmp2_ = alm_calendar_dialog_new ();
	_tmp3_ = g_object_ref_sink (_tmp2_);
	_g_object_unref0 (self->priv->start_dialog);
	self->priv->start_dialog = _tmp3_;
	_tmp4_ = alm_calendar_dialog_new ();
	_tmp5_ = g_object_ref_sink (_tmp4_);
	_g_object_unref0 (self->priv->end_dialog);
	self->priv->end_dialog = _tmp5_;
	gtk_grid_set_row_spacing ((GtkGrid*) self, (guint) 10);
	gtk_grid_set_column_spacing ((GtkGrid*) self, (guint) 15);
	_tmp6_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
	_tmp7_ = g_object_ref_sink (_tmp6_);
	box1 = _tmp7_;
	_tmp8_ = (GtkEntry*) gtk_entry_new ();
	_tmp9_ = g_object_ref_sink (_tmp8_);
	_g_object_unref0 (self->priv->start_entry);
	self->priv->start_entry = _tmp9_;
	_tmp10_ = (GtkButton*) gtk_button_new ();
	_tmp11_ = g_object_ref_sink (_tmp10_);
	_data1_->start_button = _tmp11_;
	_tmp12_ = (GtkArrow*) gtk_arrow_new (GTK_ARROW_DOWN, 0);
	_tmp13_ = g_object_ref_sink (_tmp12_);
	arrow1 = _tmp13_;
	gtk_container_add ((GtkContainer*) _data1_->start_button, (GtkWidget*) arrow1);
	_tmp14_ = self->priv->start_entry;
	gtk_editable_set_editable ((GtkEditable*) _tmp14_, FALSE);
	_tmp15_ = self->priv->start_entry;
	gtk_widget_set_size_request ((GtkWidget*) _tmp15_, 100, -1);
	_tmp16_ = self->priv->start_entry;
	gtk_box_pack_start (box1, (GtkWidget*) _tmp16_, TRUE, TRUE, (guint) 0);
	gtk_box_pack_start (box1, (GtkWidget*) _data1_->start_button, TRUE, TRUE, (guint) 0);
	g_signal_connect_data (_data1_->start_button, "clicked", (GCallback) ___lambda0__gtk_button_clicked, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	_tmp17_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
	_tmp18_ = g_object_ref_sink (_tmp17_);
	box2 = _tmp18_;
	_tmp19_ = (GtkEntry*) gtk_entry_new ();
	_tmp20_ = g_object_ref_sink (_tmp19_);
	_g_object_unref0 (self->priv->end_entry);
	self->priv->end_entry = _tmp20_;
	_tmp21_ = (GtkButton*) gtk_button_new ();
	_tmp22_ = g_object_ref_sink (_tmp21_);
	_data1_->end_button = _tmp22_;
	_tmp23_ = (GtkArrow*) gtk_arrow_new (GTK_ARROW_DOWN, 0);
	_tmp24_ = g_object_ref_sink (_tmp23_);
	arrow2 = _tmp24_;
	gtk_container_add ((GtkContainer*) _data1_->end_button, (GtkWidget*) arrow2);
	_tmp25_ = self->priv->end_entry;
	gtk_editable_set_editable ((GtkEditable*) _tmp25_, FALSE);
	_tmp26_ = self->priv->end_entry;
	gtk_widget_set_size_request ((GtkWidget*) _tmp26_, 100, -1);
	_tmp27_ = self->priv->end_entry;
	gtk_box_pack_start (box2, (GtkWidget*) _tmp27_, TRUE, TRUE, (guint) 0);
	gtk_box_pack_start (box2, (GtkWidget*) _data1_->end_button, TRUE, TRUE, (guint) 0);
	g_signal_connect_data (_data1_->end_button, "clicked", (GCallback) ___lambda3__gtk_button_clicked, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	_tmp28_ = (GtkLabel*) gtk_label_new ("");
	_tmp29_ = g_object_ref_sink (_tmp28_);
	start_label = _tmp29_;
	_tmp30_ = _ ("From:");
	gtk_label_set_markup (start_label, _tmp30_);
	gtk_misc_set_alignment ((GtkMisc*) start_label, (gfloat) 1, (gfloat) (0 / 5));
	_tmp31_ = (GtkLabel*) gtk_label_new ("");
	_tmp32_ = g_object_ref_sink (_tmp31_);
	end_label = _tmp32_;
	_tmp33_ = _ ("To:");
	gtk_label_set_markup (end_label, _tmp33_);
	gtk_misc_set_alignment ((GtkMisc*) end_label, (gfloat) 1, (gfloat) (0 / 5));
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) start_label);
	gtk_grid_attach ((GtkGrid*) self, (GtkWidget*) box1, 1, 0, 1, 1);
	gtk_grid_attach ((GtkGrid*) self, (GtkWidget*) end_label, 0, 1, 1, 1);
	gtk_grid_attach ((GtkGrid*) self, (GtkWidget*) box2, 1, 1, 1, 1);
	_tmp34_ = (GtkLabel*) gtk_label_new ("");
	_tmp35_ = g_object_ref_sink (_tmp34_);
	_g_object_unref0 (self->priv->invalid_label);
	self->priv->invalid_label = _tmp35_;
	_tmp36_ = self->priv->invalid_label;
	_tmp37_ = _ ("Invalid Timerange");
	_tmp38_ = g_strdup_printf ("<span color='red'><b>%s</b></span>", _tmp37_);
	_tmp39_ = _tmp38_;
	gtk_label_set_markup (_tmp36_, _tmp39_);
	_g_free0 (_tmp39_);
	_tmp40_ = self->priv->start_entry;
	_tmp41_ = self->priv->start_dialog;
	alm_calendar_widget_set_up_calendar (self, _data1_->start_button, _tmp40_, _tmp41_);
	_tmp42_ = self->priv->end_entry;
	_tmp43_ = self->priv->end_dialog;
	alm_calendar_widget_set_up_calendar (self, _data1_->end_button, _tmp42_, _tmp43_);
	gtk_widget_show_all ((GtkWidget*) self);
	_g_object_unref0 (end_label);
	_g_object_unref0 (start_label);
	_g_object_unref0 (arrow2);
	_g_object_unref0 (box2);
	_g_object_unref0 (arrow1);
	_g_object_unref0 (box1);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return self;
}


AlmCalendarWidget* alm_calendar_widget_new (GtkButton* button) {
	return alm_calendar_widget_construct (ALM_TYPE_CALENDAR_WIDGET, button);
}


ZeitgeistTimeRange* alm_calendar_widget_get_range (AlmCalendarWidget* self) {
	ZeitgeistTimeRange* result = NULL;
	AlmCalendarDialog* _tmp0_;
	GtkCalendar* _tmp1_ = NULL;
	GtkCalendar* calendar;
	guint year = 0U;
	guint month = 0U;
	guint day = 0U;
	GtkCalendar* _tmp2_;
	guint _tmp3_ = 0U;
	guint _tmp4_ = 0U;
	guint _tmp5_ = 0U;
	guint _tmp6_;
	guint _tmp7_;
	guint _tmp8_;
	GDateTime* _tmp9_;
	GDateTime* date;
	GDateTime* _tmp10_;
	gint64 _tmp11_ = 0LL;
	gint64 start;
	AlmCalendarDialog* _tmp12_;
	GtkCalendar* _tmp13_ = NULL;
	GtkCalendar* _tmp14_;
	guint _tmp15_ = 0U;
	guint _tmp16_ = 0U;
	guint _tmp17_ = 0U;
	guint _tmp18_;
	guint _tmp19_;
	guint _tmp20_;
	GDateTime* _tmp21_;
	GDateTime* _tmp22_;
	gint64 _tmp23_ = 0LL;
	gint64 end;
	gint64 _tmp24_;
	gint64 _tmp25_;
	gint64 _tmp33_;
	gint64 _tmp34_;
	ZeitgeistTimeRange* _tmp35_;
	ZeitgeistTimeRange* _tmp36_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->start_dialog;
	_tmp1_ = alm_calendar_dialog_get_calendar_widget (_tmp0_);
	calendar = _tmp1_;
	_tmp2_ = calendar;
	gtk_calendar_get_date (_tmp2_, &_tmp3_, &_tmp4_, &_tmp5_);
	year = _tmp3_;
	month = _tmp4_;
	day = _tmp5_;
	_tmp6_ = year;
	_tmp7_ = month;
	_tmp8_ = day;
	_tmp9_ = g_date_time_new_local ((gint) _tmp6_, ((gint) _tmp7_) + 1, (gint) _tmp8_, 0, 0, (gdouble) 0);
	date = _tmp9_;
	_tmp10_ = date;
	_tmp11_ = g_date_time_to_unix (_tmp10_);
	start = _tmp11_ * 1000;
	_tmp12_ = self->priv->end_dialog;
	_tmp13_ = alm_calendar_dialog_get_calendar_widget (_tmp12_);
	_g_object_unref0 (calendar);
	calendar = _tmp13_;
	_tmp14_ = calendar;
	gtk_calendar_get_date (_tmp14_, &_tmp15_, &_tmp16_, &_tmp17_);
	year = _tmp15_;
	month = _tmp16_;
	day = _tmp17_;
	_tmp18_ = year;
	_tmp19_ = month;
	_tmp20_ = day;
	_tmp21_ = g_date_time_new_local ((gint) _tmp18_, ((gint) _tmp19_) + 1, (gint) _tmp20_, 0, 0, (gdouble) 0);
	_g_date_time_unref0 (date);
	date = _tmp21_;
	_tmp22_ = date;
	_tmp23_ = g_date_time_to_unix (_tmp22_);
	end = _tmp23_ * 1000;
	_tmp24_ = start;
	_tmp25_ = end;
	if (_tmp24_ > _tmp25_) {
		GtkButton* _tmp26_;
		GtkLabel* _tmp27_;
		GtkWidget* _tmp28_ = NULL;
		GtkLabel* _tmp30_;
		_tmp26_ = self->priv->button;
		gtk_widget_set_sensitive ((GtkWidget*) _tmp26_, FALSE);
		_tmp27_ = self->priv->invalid_label;
		_tmp28_ = gtk_widget_get_parent ((GtkWidget*) _tmp27_);
		if (_tmp28_ == NULL) {
			GtkLabel* _tmp29_;
			_tmp29_ = self->priv->invalid_label;
			gtk_grid_attach ((GtkGrid*) self, (GtkWidget*) _tmp29_, 2, 0, 1, 2);
		}
		_tmp30_ = self->priv->invalid_label;
		gtk_widget_show ((GtkWidget*) _tmp30_);
	} else {
		GtkButton* _tmp31_;
		GtkLabel* _tmp32_;
		_tmp31_ = self->priv->button;
		gtk_widget_set_sensitive ((GtkWidget*) _tmp31_, TRUE);
		_tmp32_ = self->priv->invalid_label;
		gtk_widget_hide ((GtkWidget*) _tmp32_);
	}
	_tmp33_ = start;
	_tmp34_ = end;
	_tmp35_ = zeitgeist_time_range_new (_tmp33_, _tmp34_);
	_tmp36_ = g_object_ref_sink (_tmp35_);
	result = _tmp36_;
	_g_date_time_unref0 (date);
	_g_object_unref0 (calendar);
	return result;
}


void alm_calendar_widget_set_up_calendar (AlmCalendarWidget* self, GtkButton* widget, GtkEntry* entry, AlmCalendarDialog* dialog) {
	AlmCalendarDialog* _tmp0_;
	GtkCalendar* _tmp1_ = NULL;
	GtkCalendar* calendar;
	guint year = 0U;
	guint month = 0U;
	guint day = 0U;
	guint _tmp2_ = 0U;
	guint _tmp3_ = 0U;
	guint _tmp4_ = 0U;
	GDateTime* _tmp5_;
	GDateTime* date;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* date_string;
	GtkEntry* _tmp8_;
	GtkButton* _tmp9_;
	AlmCalendarDialog* _tmp10_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	g_return_if_fail (entry != NULL);
	g_return_if_fail (dialog != NULL);
	_tmp0_ = dialog;
	_tmp1_ = alm_calendar_dialog_get_calendar_widget (_tmp0_);
	calendar = _tmp1_;
	gtk_calendar_get_date (calendar, &_tmp2_, &_tmp3_, &_tmp4_);
	year = _tmp2_;
	month = _tmp3_;
	day = _tmp4_;
	_tmp5_ = g_date_time_new_local ((gint) year, ((gint) month) + 1, (gint) day, 0, 0, (gdouble) 0);
	date = _tmp5_;
	_tmp6_ = _ ("%d %B %Y");
	_tmp7_ = g_date_time_format (date, _tmp6_);
	date_string = _tmp7_;
	_tmp8_ = entry;
	gtk_entry_set_text (_tmp8_, date_string);
	_tmp9_ = widget;
	gtk_widget_set_sensitive ((GtkWidget*) _tmp9_, TRUE);
	_tmp10_ = dialog;
	gtk_widget_hide ((GtkWidget*) _tmp10_);
	_g_free0 (date_string);
	_g_date_time_unref0 (date);
	_g_object_unref0 (calendar);
}


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void block2_data_unref (Block2Data* _data2_) {
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		_g_object_unref0 (_data2_->self);
		_g_object_unref0 (_data2_->widget);
		_g_object_unref0 (_data2_->entry);
		_g_object_unref0 (_data2_->dialog);
		g_slice_free (Block2Data, _data2_);
	}
}


static gboolean __lambda1_ (Block2Data* _data2_, GtkWidget* w, GdkEventFocus* e) {
	AlmCalendarWidget * self;
	gboolean result = FALSE;
	AlmCalendarDialog* _tmp0_;
	GtkWidget* _tmp1_;
	self = _data2_->self;
	g_return_val_if_fail (w != NULL, FALSE);
	g_return_val_if_fail (e != NULL, FALSE);
	_tmp0_ = _data2_->dialog;
	gtk_widget_hide ((GtkWidget*) _tmp0_);
	_tmp1_ = _data2_->widget;
	gtk_widget_set_sensitive (_tmp1_, TRUE);
	result = FALSE;
	return result;
}


static gboolean ___lambda1__gtk_widget_focus_out_event (GtkWidget* _sender, GdkEventFocus* event, gpointer self) {
	gboolean result;
	result = __lambda1_ (self, _sender, event);
	return result;
}


static void __lambda2_ (Block2Data* _data2_) {
	AlmCalendarWidget * self;
	AlmCalendarDialog* _tmp0_;
	GtkCalendar* _tmp1_ = NULL;
	GtkCalendar* calendar;
	guint year = 0U;
	guint month = 0U;
	guint day = 0U;
	guint _tmp2_ = 0U;
	guint _tmp3_ = 0U;
	guint _tmp4_ = 0U;
	GDateTime* _tmp5_;
	GDateTime* date;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* date_string;
	GtkEntry* _tmp8_;
	GtkWidget* _tmp9_;
	AlmCalendarDialog* _tmp10_;
	ZeitgeistTimeRange* _tmp11_ = NULL;
	ZeitgeistTimeRange* range;
	self = _data2_->self;
	_tmp0_ = _data2_->dialog;
	_tmp1_ = alm_calendar_dialog_get_calendar_widget (_tmp0_);
	calendar = _tmp1_;
	gtk_calendar_get_date (calendar, &_tmp2_, &_tmp3_, &_tmp4_);
	year = _tmp2_;
	month = _tmp3_;
	day = _tmp4_;
	_tmp5_ = g_date_time_new_local ((gint) year, ((gint) month) + 1, (gint) day, 0, 0, (gdouble) 0);
	date = _tmp5_;
	_tmp6_ = _ ("%d %B %Y");
	_tmp7_ = g_date_time_format (date, _tmp6_);
	date_string = _tmp7_;
	_tmp8_ = _data2_->entry;
	gtk_entry_set_text (_tmp8_, date_string);
	_tmp9_ = _data2_->widget;
	gtk_widget_set_sensitive (_tmp9_, TRUE);
	_tmp10_ = _data2_->dialog;
	gtk_widget_hide ((GtkWidget*) _tmp10_);
	_tmp11_ = alm_calendar_widget_get_range (self);
	range = _tmp11_;
	_g_object_unref0 (range);
	_g_free0 (date_string);
	_g_date_time_unref0 (date);
	_g_object_unref0 (calendar);
}


static void ___lambda2__gtk_calendar_day_selected_double_click (GtkCalendar* _sender, gpointer self) {
	__lambda2_ (self);
}


void alm_calendar_widget_on_clicked (AlmCalendarWidget* self, GtkWidget* widget, GtkEntry* entry, AlmCalendarDialog* dialog) {
	Block2Data* _data2_;
	GtkWidget* _tmp0_;
	GtkWidget* _tmp1_;
	GtkEntry* _tmp2_;
	GtkEntry* _tmp3_;
	AlmCalendarDialog* _tmp4_;
	AlmCalendarDialog* _tmp5_;
	AlmCalendarDialog* _tmp6_;
	GdkWindow* _tmp7_ = NULL;
	GdkWindow* _tmp8_;
	GdkWindow* parent_window;
	gint window_x = 0;
	gint window_y = 0;
	gint _tmp9_ = 0;
	gint _tmp10_ = 0;
	GtkAllocation allocation = {0};
	GtkEntry* _tmp11_;
	GtkAllocation _tmp12_ = {0};
	AlmCalendarDialog* _tmp13_;
	GtkAllocation _tmp14_;
	gint _tmp15_;
	GtkAllocation _tmp16_;
	gint _tmp17_;
	GtkAllocation _tmp18_;
	gint _tmp19_;
	AlmCalendarDialog* _tmp20_;
	GtkAllocation _tmp21_;
	gint _tmp22_;
	AlmCalendarDialog* _tmp23_;
	GtkWidget* _tmp24_;
	AlmCalendarDialog* _tmp25_;
	AlmCalendarDialog* _tmp26_;
	GtkCalendar* _tmp27_ = NULL;
	GtkCalendar* cal;
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	g_return_if_fail (entry != NULL);
	g_return_if_fail (dialog != NULL);
	_data2_ = g_slice_new0 (Block2Data);
	_data2_->_ref_count_ = 1;
	_data2_->self = g_object_ref (self);
	_tmp0_ = widget;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_data2_->widget = _tmp1_;
	_tmp2_ = entry;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_data2_->entry = _tmp3_;
	_tmp4_ = dialog;
	_tmp5_ = _g_object_ref0 (_tmp4_);
	_data2_->dialog = _tmp5_;
	_tmp6_ = _data2_->dialog;
	gtk_widget_show_all ((GtkWidget*) _tmp6_);
	_tmp7_ = gtk_widget_get_parent_window ((GtkWidget*) self);
	_tmp8_ = _g_object_ref0 (_tmp7_);
	parent_window = _tmp8_;
	gdk_window_get_position (parent_window, &_tmp9_, &_tmp10_);
	window_x = _tmp9_;
	window_y = _tmp10_;
	_tmp11_ = _data2_->entry;
	gtk_widget_get_allocation ((GtkWidget*) _tmp11_, &_tmp12_);
	allocation = _tmp12_;
	_tmp13_ = _data2_->dialog;
	_tmp14_ = allocation;
	_tmp15_ = _tmp14_.x;
	_tmp16_ = allocation;
	_tmp17_ = _tmp16_.y;
	_tmp18_ = allocation;
	_tmp19_ = _tmp18_.height;
	gtk_window_move ((GtkWindow*) _tmp13_, window_x + _tmp15_, (window_y + _tmp17_) + _tmp19_);
	_tmp20_ = _data2_->dialog;
	_tmp21_ = allocation;
	_tmp22_ = _tmp21_.width;
	gtk_widget_set_size_request ((GtkWidget*) _tmp20_, _tmp22_, -1);
	_tmp23_ = _data2_->dialog;
	gtk_window_set_resizable ((GtkWindow*) _tmp23_, FALSE);
	_tmp24_ = _data2_->widget;
	gtk_widget_set_sensitive (_tmp24_, FALSE);
	_tmp25_ = _data2_->dialog;
	g_signal_connect_data ((GtkWidget*) _tmp25_, "focus-out-event", (GCallback) ___lambda1__gtk_widget_focus_out_event, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, G_CONNECT_AFTER);
	_tmp26_ = _data2_->dialog;
	_tmp27_ = alm_calendar_dialog_get_calendar_widget (_tmp26_);
	cal = _tmp27_;
	g_signal_connect_data (cal, "day-selected-double-click", (GCallback) ___lambda2__gtk_calendar_day_selected_double_click, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
	_g_object_unref0 (cal);
	_g_object_unref0 (parent_window);
	block2_data_unref (_data2_);
	_data2_ = NULL;
}


static void alm_calendar_widget_class_init (AlmCalendarWidgetClass * klass) {
	alm_calendar_widget_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (AlmCalendarWidgetPrivate));
	G_OBJECT_CLASS (klass)->finalize = alm_calendar_widget_finalize;
}


static void alm_calendar_widget_instance_init (AlmCalendarWidget * self) {
	self->priv = ALM_CALENDAR_WIDGET_GET_PRIVATE (self);
}


static void alm_calendar_widget_finalize (GObject* obj) {
	AlmCalendarWidget * self;
	self = ALM_CALENDAR_WIDGET (obj);
	_g_object_unref0 (self->priv->start_entry);
	_g_object_unref0 (self->priv->end_entry);
	_g_object_unref0 (self->priv->start_dialog);
	_g_object_unref0 (self->priv->end_dialog);
	_g_object_unref0 (self->priv->button);
	_g_object_unref0 (self->priv->invalid_label);
	G_OBJECT_CLASS (alm_calendar_widget_parent_class)->finalize (obj);
}


GType alm_calendar_widget_get_type (void) {
	static volatile gsize alm_calendar_widget_type_id__volatile = 0;
	if (g_once_init_enter (&alm_calendar_widget_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AlmCalendarWidgetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) alm_calendar_widget_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AlmCalendarWidget), 0, (GInstanceInitFunc) alm_calendar_widget_instance_init, NULL };
		GType alm_calendar_widget_type_id;
		alm_calendar_widget_type_id = g_type_register_static (GTK_TYPE_GRID, "AlmCalendarWidget", &g_define_type_info, 0);
		g_once_init_leave (&alm_calendar_widget_type_id__volatile, alm_calendar_widget_type_id);
	}
	return alm_calendar_widget_type_id__volatile;
}



